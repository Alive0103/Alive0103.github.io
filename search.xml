<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>是啊，我也曾彻夜难眠</title>
      <link href="/2025/05/04/%E6%88%91%E4%B9%9F%E6%9B%BE%E5%BD%BB%E5%A4%9C%E9%9A%BE%E7%9C%A0/"/>
      <url>/2025/05/04/%E6%88%91%E4%B9%9F%E6%9B%BE%E5%BD%BB%E5%A4%9C%E9%9A%BE%E7%9C%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>赠尔一缕剑气，愿尔所向披靡。</p></blockquote><p>嘿，朋友，不知道现在的你是何心境，或许你还在纠结，或许也和现在的我一样孤注一掷，感谢你的停留，来听听我的故事。</p><p>鱼皮也写过这篇，我看了，依旧彻夜难眠，一个人一个解法，别人的路终究不是我的，而我的也不会是你的，仅供参考。</p><blockquote><p>写在前面，以下为本人参加的40场左右面试的面试官和几任mentor，从事职业多为后端开发，工作年限约为10年，主要针对就业环境，职业规划和工作细节展开。希望能给你带来一些思考。</p></blockquote><p>Q：当下后端就业市场的环境？</p><p>A1：红海，相当萧条了，如果不能很好地看到业务的本质基本等于入局即淘汰。</p><p>A2：传统后端可能会稍微缩水，冷的不是岗位而是大量看不见机会的人。不论做什么保持前瞻性目光和随机而动的能力是相当必要的，没有人一下就能选好终身适合自己的方向，你看当初选择传统后端现在跳AI应用开发的人，他们当初会想到今天吗？但正因为时时的学习积累和具有洞察力的眼光让他有了二次生长的能力。</p><p>Q：女生从事后端开发您怎么看？</p><p>A1：能过机筛的简历中男女比（48：2），首先选择后端的女生少，其次她们多数缺乏技术热情和钻研精神，代码能力普遍偏弱，不太抗压，再者是社会客观要求导致的，后端的现状对于女生而言不是一个好的选择。</p><p>A2：我周围有很多女生会做得比男生好，但技术热情确实普遍相对较低，我们持open的态度，首先干活的应当是人，只要能力+各方面适合，我觉得每个人都值得一个机会。</p><p>A3：（这是一位女生，我觉得她温柔而坚定）当然会觉得不易，我们的付出往往是他人的几倍，要记得做好自己，保持快乐。</p><p>Q：您认为在您当前的这个岗位上具有不可替代性吗？有的话是怎么做的？</p><p>A：当然是没有的，CEO还常常换不是吗？但你需要有过硬的技术和良好的协作能力，需要具有看到事物本质的能力，才能走得远一点。</p><blockquote><p>后来我也常常被问这个问题，我们被同样的模子雕刻成相似的形状，有着相同的技能，那又凭什么要求我们一定要不可替代？如果真的不可替代相比您也不敢招我吧hh。</p></blockquote><p>Q：如何看到业务的本质？</p><p>A1：客户说的需求和你实现起来可能是两码事，你要以一个owner的视角去开发项目，多想想这个需求的实现侧和使用侧的异同以及实现起来的技术难点是否有有效方案等（通常发生在需求评审环节），常常需要多方对齐，只有全都理解清楚后才能开始干活。</p><p>A2：做功能如果仅仅局限于做完是不可取的，需要看到有没有可复用的东西，以及合适的兜底策略，或者潜在风险，总结自己是否有所收获。</p><p>A3：你在做一件事情之前，比如现在给了你一个需求，你不能只是把他干好，那是牛马，你要思考，为什么有这个需求，这个需求能解决什么问题，上下游是什么，这个需求如何解决，为什么这样解决，能给公司带来什么样的价值，复用性如何，中间什么环节会出问题，出了问题如何快速定位排查，有没有兜底方案，稳定性怎么保障。</p><p>Q：对我的建议？</p><p>M1（PM）：从事前端（指销售岗），理由：女生 + 懂技术的销售赚的比程序员多，比较轻松。</p><p>M2：不应当因为语言/岗位就限制自己的选择，不应当因为自己会什么就投什么岗，应当看市场需要什么再去准备什么，看看国外的机会，还有相信自己。</p><p>P：传统的大语言模型研究（NLP）已经相当完备，走工业化实践会好很多。</p><p>Q：三年工作经验的本科 vs 刚毕业的研究生，同等技术水平，选谁？</p><p>A1：本科生，能和研究生一个水平证明他不需要读研也可以一样厉害。</p><p>PM：和技术没关系，看人，谁性格好合得来就要谁，因为大家水平一样，日常协作业务肯定要选气场相合的做同事。</p><p>HR：看岗位和项目的长短期，长期来看会选研究生，本科如果不是向下跳的话会不稳定。</p><p>M2：看岗位+平台，如果这种情况发生证明本科生跳槽了，那要考虑他为什么跳槽，可能会不稳定，大平台的核心岗会倾向研究生，一般岗位倾向本科。</p><p>Q：本科（几乎没经验） vs 双非（经验拉满），选谁？</p><p>A1（初创公司）：本科，团队成员从一开始就要保证质量，技术只是一方面，需要综合素质高的人，业务的发展不能急于求成。</p><p>A2（初创公司）：双非，需要能干活高效的人，公司负担不了太多培养成本。</p><p>A3（某厂）：我看重的是你这个人，包括潜力、性格、技术，学历只是一部分。</p><p>Q：某面试官在回答问题时坦言：“我们做这些不过是为了赚钱而已。”对这个现象你怎么看？</p><p>A1：非常合理，赚钱正是我们正在做事情的动力。</p><p>追问：那你的技术热情是否会因为日复一日的工作而磨灭？</p><p>A1：不会，我看得见我正在做的工作的价值，赚钱是动力。如果有一天你觉得自己的工作没有价值可能有两个原因：</p><p>1.你对自己的业务理解不深刻</p><p>2.你太菜了，只能局限于表面的功能实现</p><p>A2：是为了赚钱，但需要在工作/生活中保持对生活的热情，要快乐。</p><p>Q：关于AI时代的看法</p><ul><li><p>算法（搜光推）：高薪、高压、适应时代、可替代性较弱，但需谨防泡沫经济和后浪的冲击。</p></li><li><p>传统后端：需求大、高压、可替代性正提高，需要有技术有思考的人，懂业务的开发不会消失。</p></li><li><p>Agent应用开发：新兴方向、入行成本低，复合型技术，大模型变现的关键。</p></li><li><p>大前端：新兴方向，由前端发展而来，掺杂后端工作，门槛较低，可替代性未知。</p></li></ul><p>被筛选/淘汰的从来都不是技术，而是人的思维。王无术的视频（虽然是为了卖课）对处于任何状态的你都会有启发~</p><p>【考研上岸又如何？AI大模型冲击+学历通胀的就业市场【王无术】】 <a href="https://www.bilibili.com/video/BV1M1FTexEAg/?share_source=copy_web&amp;vd_source=4bd852f834f2d9a6a8ce0609a36001d4">https://www.bilibili.com/video/BV1M1FTexEAg/?share_source=copy_web&amp;vd_source=4bd852f834f2d9a6a8ce0609a36001d4</a></p><p>但又怎么可能不遗憾呢？因为承载着他人的真心，因为不计代价的付出，或许怎样的结局都早已配不上这一路的颠沛流离。无需权衡太多利弊，祸福本就相依。</p><p>同行的朋友，如果你正走在我不曾选择的道路上，请务必用力生活，另一条道路上我也正用心感受你不曾做的选择。</p><p>祝好。</p><hr><p>写给自己的碎碎念：</p><p>是的，我切实感受到了后端环境的冷和女性在就业市场上的劣势，也听见了所谓“适合”的建议，或许我就是叛逆的，听不惯说教的，但正因为我还年少啊，不希望未来的我因为世俗上的一句“她应当”而后悔，还记得上面PM的建议吗？他是一个温柔到骨子里的人，也是真心为我好，但也是这样他一遍遍地劝告，我一遍遍地反驳，让我找到真正的选择。</p><blockquote><p>得益于极度真诚的一群人才有现在的我，而他们因为种种资源的不公已然麻木。或许我是他们的眼睛，代他们看看外面的世界，真心予人勇气，我拼命想看得高一点再高一点，好在再见时告诉他们：嘿！你瞧，是我们，是我们都能做得到。</p><p>在成长的过程中我们的锐气都在被削减，或许在很多年之后我也会和别人说不要走后端，似乎是在见证了太多的失败，我们越来越畏惧走错步子。人在不同阶段看到和想到的事物不一样，选择自然不同，无愧于心就好，我希望我做的每一个决定都是我自由意志选择的结果而非被经验裹挟，无论好坏。</p><p>许是少年意气，许是年少无知，或许会碰得头破血流吧，那么愿赌服输。</p><p>我会永远记得那个背负了重重否定逆天改命的我，后来啊，这个小小的我一次又一次拉着我冲出漫漫长夜，冲出我们既定的命运。</p></blockquote><p>不管结果如何，当下的你相当张扬勇敢，每一步的选择都环环相扣，或许未来因为种种原因你不能放手一搏，我不怪你，请记住，我不期望你一定要有显赫的成就，我希望你能<strong>找到自己，保持鲜活</strong>，有思想的人就是鲜活的。</p><p>尽管向后展望吧，我们拥有无尽的热忱呢！</p><p>山水有相逢，不管当下的你决定如何，想要的就要去争取！希望我做的每一个决定是因为我想，而非利益所指，永远愿用真心换真心。</p><p>取一个花名，就叫温铮吧</p><p>祝福一个女孩，请不要祝她贤良淑德，宜室宜家，我祝在时代定义下可能依旧在被审视的我们铮铮且昂扬，永远保持自己的温度。</p><hr><p>嘿，旅人，如果你正在经历夜不能寐的夜晚，可能你会觉得其他人都做好了决定，只有你举棋不定，别着急哇，或许是因为过去生长得过于匆匆，真我被深藏心底，我们的选择可能只是比其他人来得晚一点，每一个彻夜难眠的时刻都会加深我们对选择的思考和认知，这也是命运的馈赠，相信在恰当的时机你会做出不后悔的选择，希望我的文章对你有帮助，随心而动即可，那么，好梦。</p><hr><p>亲爱的面试官，您好！很高兴您能来看我的博客，很高兴这篇文章能给你带来我的视角，我的每一点成长都有被看见，更多详细的技术博客欢迎移步我的CSDN，相关项目请见GitHub，期待和有意思的人做有温度的事。</p><p>会做到吗？会的，一定会的！</p><hr><p>贴一点链接，感兴趣的uu可以mark一下，求一个star,求一个关注，欢迎互换友链哇，评论区留言即可🎊</p><p>CSDN：一手课程作业&amp;学习小记 创作质量95+ 来看看哇~ <a href="https://blog.csdn.net/Astrid_5211?spm=1000.2115.3001.5343">主页</a></p><p>小红书：段子手日常，实习日常，随缘更 <a href="https://www.xiaohongshu.com/user/profile/5e91c3a7000000000100234b">主页</a></p><p>牛客：攒面经、实习日常（经常更）<a href="https://www.nowcoder.com/users/394235056">主页</a></p><p>Github仓库： <a href="https://github.com/Alive0103">Alive0103 (Alive) (github.com)</a></p><p>备用服务器：www.alive0103.online 暂时挂掉，搞别的项目</p><p>有急事建议发邮箱喔 <a href="mailto:972477867@qq.com">972477867@qq.com</a></p><blockquote><p>我想，十年之后的她看了一定不会后悔，因为当下的决定我都觉得很值得。</p><p>致谢：每一位待我真心之人</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/03/10/%E9%9D%A2%E7%BB%8F/"/>
      <url>/2025/03/10/%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/03/04/Untitled/"/>
      <url>/2025/03/04/Untitled/</url>
      
        <content type="html"><![CDATA[<h3 id="一、项目背景与需求溯源"><strong>一、项目背景与需求溯源</strong></h3><p>项目目标是解决国产大飞机C919客服场景的<strong>数据孤岛</strong>问题：飞行数据分散在多个子系统（如发动机监控、航电日志），客户需跨系统人工拼接数据，<strong>决策延迟高达数小时</strong>。因此需求本质是通过统一平台实现：</p><ol><li><strong>数据融合</strong>：批量数据（历史飞行记录）与流数据（实时传感器）的归一化处理</li><li><strong>预测支持</strong>：基于数据聚合提供故障预测（如发动机过热风险预警）</li></ol><hr><h3 id="二、我的技术贡献与深度思考"><strong>二、我的技术贡献与深度思考</strong></h3><h4 id="1-异步处理架构设计"><strong>1. 异步处理架构设计</strong></h4><ul><li><strong>需求痛点</strong>：初期同步处理流数据时，<strong>单节点吞吐量仅200QPS</strong>，导致仪表盘数据刷新延迟超5秒</li><li><strong>技术方案</strong>：基于ThreadPoolExecutor实现<strong>动态扩容线程池</strong>，核心线程数与队列容量根据数据流速弹性调整</li><li><strong>思考延伸</strong>：<ul><li><strong>流量评估</strong>：通过历史数据分析航班高峰时段（如早8-9点）的流量峰值，设计线程数计算公式：<code>核心线程数 = (平均任务耗时 × QPS) / (1 - 目标CPU利用率)</code></li><li><strong>资源隔离</strong>：将CPU密集型任务（傅里叶变换计算振动频率）与IO密集型任务（数据落盘）分配至不同线程池，避免相互阻塞</li><li><strong>价值量化</strong>：吞吐量提升至1800QPS后，客户决策响应时间缩短至800ms，直接支持了某航司的<strong>实时备件调度系统</strong>对接</li></ul></li></ul><h5 id="线程池在项目中的核心功能">*<em>线程池在项目中的核心功能</em></h5><h6 id="1-功能定位"><strong>1. 功能定位</strong></h6><p>线程池在项目中承担<strong>异步解耦</strong>与<strong>资源管控</strong>的核心职责，具体解决两个问题：</p><ul><li><strong>实时流处理阻塞</strong>：原始同步处理模式下，单线程处理飞行传感器数据（如发动机温度采样）耗时长达50ms/条，导致数据积压</li><li><strong>批量任务资源争抢</strong>：夜间批处理任务（如历史数据清洗）与实时流任务竞争CPU，引发服务雪崩</li></ul><h6 id="2-实现细节"><strong>2. 实现细节</strong></h6><p>采用ThreadPoolExecutor构建<strong>双层级线程池</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实时流处理池（IO密集型）</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">streamPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">8</span>,  <span class="comment">// 基准核心线程数（按4核CPU超线程设计）</span></span><br><span class="line">    <span class="number">32</span>, <span class="comment">// 最大扩展线程数（考虑突发流量）</span></span><br><span class="line">    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(), <span class="comment">// 拒绝队列积压，强制快速失败</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">NamedThreadFactory</span>(<span class="string">&quot;stream-proc&quot;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批处理池（CPU密集型）</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">batchPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    Runtime.getRuntime().availableProcessors(), </span><br><span class="line">    Runtime.getRuntime().availableProcessors() * <span class="number">2</span>,</span><br><span class="line">    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">1000</span>), <span class="comment">// 允许适度堆积</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">RejectedExecutionHandler</span>() &#123; <span class="comment">// 自定义拒绝策略</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">            <span class="comment">// 记录丢失数据批次，触发补偿机制</span></span><br><span class="line">            Metrics.counter(<span class="string">&quot;batch.rejected&quot;</span>).increment(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实时流处理线程池（SynchronousQueue）</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    ..., </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">RejectedExecutionHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 实时数据紧急处理</span></span><br><span class="line">            <span class="keyword">if</span> (isCriticalData(r)) &#123;</span><br><span class="line">                emergencyQueue.offer(r);  <span class="comment">// 写入高优先级Kafka队列</span></span><br><span class="line">                Metrics.counter(<span class="string">&quot;realtime.reject.critical&quot;</span>).increment();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Metrics.counter(<span class="string">&quot;realtime.reject.normal&quot;</span>).increment();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 触发背压通知</span></span><br><span class="line">            notifyUpstreamThrottle(); <span class="comment">// 通过gRPC通知数据发送端降频</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批处理线程池（LinkedBlockingQueue）</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    ...,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">RejectedExecutionHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 记录批次元数据</span></span><br><span class="line">            <span class="type">BatchTask</span> <span class="variable">task</span> <span class="operator">=</span> (BatchTask) r;</span><br><span class="line">            writeToCompensationDB(task.getBatchId()); </span><br><span class="line">            <span class="comment">// 2. 触发补偿任务</span></span><br><span class="line">            CompensationScheduler.scheduleRetry(task);</span><br><span class="line">            <span class="comment">// 3. 监控告警</span></span><br><span class="line">            <span class="keyword">if</span> (rejectedCount.incrementAndGet() &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                sendWechatAlert(<span class="string">&quot;批处理任务堆积严重！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="3-业务价值转化"><strong>3. 业务价值转化</strong></h4><ul><li><strong>直接收益</strong>：==处理延迟从5s降至800ms==，使某航司的发动机异常检测时效提升3倍</li><li><strong>隐性收益</strong>：弹性线程池设计支撑了后续<strong>空客A320数据平台</strong>的快速复用（仅修改20%代码）</li></ul><h4 id="2-分布式锁防重机制"><strong>2. 分布式锁防重机制</strong></h4><ul><li><strong>问题场景</strong>：客户频繁点击&quot;数据导出&quot;按钮时，因网络抖动导致服务端收到重复请求，引发<strong>数据库事务锁竞争</strong></li><li><strong>方案演进</strong>：<ol><li>前端防抖：简单方案但无法防御恶意调用</li><li>数据库唯一索引：对高并发场景不友好</li><li><strong>最终方案</strong>：Redisson分布式锁 + 自定义注解@RequestDeduplicate</li></ol></li><li><strong>设计细节</strong>：<ul><li><strong>指纹生成</strong>：MD5(用户ID + 参数JSON + 时间戳/分钟) 实现<strong>粒度可控的幂等</strong></li><li><strong>锁超时</strong>：设置锁自动释放时间为业务最大耗时120%，避免死锁</li><li><strong>降级策略</strong>：Redis故障时切换至本地Guava Cache，保证基本可用性</li></ul></li><li><strong>验证效果</strong>：重复请求拦截率99.3%，数据库写负载下降40%</li></ul><h3 id="一、问题场景与需求本质"><strong>一、问题场景与需求本质</strong></h3><h4 id="1-业务痛点"><strong>1. 业务痛点</strong></h4><p>在C919数据平台中，客户频繁触发<strong>敏感操作</strong>（如飞行数据导出、预测模型重训练），导致：</p><ul><li><strong>数据库写冲突</strong>：多个相同请求同时更新任务状态，引发事务回滚</li><li><strong>资源浪费</strong>：某次故障中重复执行数据清洗任务，消耗额外62%的CPU资源</li><li><strong>数据污染</strong>：异步任务重复生成报表，导致客户下载到中间态数据</li></ul><h4 id="2-技术挑战"><strong>2. 技术挑战</strong></h4><ul><li><strong>分布式环境</strong>：服务部署在3个可用区，传统synchronized锁失效</li><li><strong>网络不确定性</strong>：移动端用户在弱网环境下可能连续发送相同请求</li><li><strong>锁粒度控制</strong>：需平衡安全性与性能，避免过度加锁影响吞吐量</li></ul><hr><h3 id="二、技术选型与架构设计"><strong>二、技术选型与架构设计</strong></h3><h4 id="1-方案对比矩阵"><strong>1. 方案对比矩阵</strong></h4><table><thead><tr><th style="text-align:left">方案</th><th style="text-align:left">实现复杂度</th><th style="text-align:left">性能</th><th style="text-align:left">可靠性</th><th style="text-align:left">适用场景</th></tr></thead><tbody><tr><td style="text-align:left">数据库行锁</td><td style="text-align:left">低</td><td style="text-align:left">差（约800QPS）</td><td style="text-align:left">依赖数据库</td><td style="text-align:left">低频强一致场景</td></tr><tr><td style="text-align:left">ZooKeeper顺序节点</td><td style="text-align:left">高</td><td style="text-align:left">中（2000QPS）</td><td style="text-align:left">最高</td><td style="text-align:left">金融级强一致</td></tr><tr><td style="text-align:left"><strong>Redis分布式锁</strong></td><td style="text-align:left">中</td><td style="text-align:left">高（10000+ QPS）</td><td style="text-align:left">需容错设计</td><td style="text-align:left">高并发最终一致</td></tr><tr><td style="text-align:left">ETCD租约</td><td style="text-align:left">高</td><td style="text-align:left">中高</td><td style="text-align:left">强一致性</td><td style="text-align:left">云原生环境</td></tr></tbody></table><p><strong>最终选择Redisson原因</strong>：</p><ul><li>内置看门狗机制（自动续期）</li><li>支持多种锁类型（可重入、公平锁等）</li><li>成熟的故障处理策略（主从切换时锁迁移）</li></ul><hr><h3 id="三、核心实现细节"><strong>三、核心实现细节</strong></h3><h4 id="1-锁指纹生成算法"><strong>1. 锁指纹生成算法</strong></h4><p><strong>设计考量</strong>：</p><ul><li><strong>用户级隔离</strong>：不同用户相同操作可并发</li><li><strong>参数指纹</strong>：MD5压缩长参数列表（如JSON体）</li><li><strong>时间分片</strong>：避免客户端时钟不同步问题</li></ul><h4 id="2-锁生命周期管理"><strong>2. 锁生命周期管理</strong></h4><p><strong>关键参数</strong>：</p><ul><li><strong>等待时间</strong>（300ms）：超过前端防抖时间（200ms），减少无效等待</li><li><strong>自动释放时间</strong>（30s）：根据历史监控数据，95%的任务在8s内完成</li><li><strong>锁重试策略</strong>：采用指数退避（Exponential Backoff）重试机制</li></ul><h4 id="3-容灾降级方案"><strong>3. 容灾降级方案</strong></h4><p><strong>多级降级策略</strong>：</p><ol><li><strong>一级降级</strong>（Redis Cluster宕机）：<ul><li>启用本地Guava Cache，基于「用户+IP」维度限流</li><li>写入死信队列（Kafka），待Redis恢复后重放</li></ul></li><li><strong>二级降级</strong>（全平台故障）：<ul><li>开启数据库乐观锁（version字段），牺牲部分性能保核心功能</li><li>前端展示&quot;数据可能存在延迟&quot;提示</li></ul></li></ol><hr><h3 id="四、稳定性保障体系"><strong>四、稳定性保障体系</strong></h3><h4 id="1-监控指标建设"><strong>1. 监控指标建设</strong></h4><ul><li><p><strong>锁竞争热力图</strong>：</p></li><li><p><strong>异常检测规则</strong>：</p><ul><li>相同锁Key每秒申请次数 &gt; 50 → 触发安全审计（防爆破攻击）</li><li>锁持有时间 &gt; 20s → 邮件告警（可能发生死锁）</li></ul></li></ul><h4 id="2-混沌测试案例"><strong>2. 混沌测试案例</strong></h4><ul><li><strong>模拟场景</strong>：<ol><li>强制释放持有中的锁（测试业务幂等性）</li><li>将Redis主节点延迟调高至2秒（测试锁漂移处理）</li><li>随机拒绝50%的解锁请求（验证最终一致性）</li></ol></li><li><strong>修复措施</strong>：<ul><li>添加锁令牌（Token）验证，防止误删其他线程的锁</li><li>引入锁持有者心跳检测（每5s更新timestamp）</li></ul></li></ul><h4 id="3-性能压测数据"><strong>3. 性能压测数据</strong></h4><p>使用JMeter模拟<strong>极端场景</strong>：</p><ul><li><strong>500并发重复提交</strong>：<ul><li>未加锁时：数据库出现63%的重复记录</li><li>加锁后：重复率降至0.03%（因网络超时导致极小概率失败）</li></ul></li><li><strong>资源消耗</strong>：<ul><li>Redis CPU增长：12% → 19%</li><li>接口平均耗时：从38ms → 53ms（增加部分主要为网络通信）</li></ul></li></ul><h4 id="3-数据转储任务调度"><strong>3. 数据转储任务调度</strong></h4><ul><li><strong>业务诉求</strong>：每日凌晨将TB级数据从MongoDB迁移至数仓，需保证<strong>跨数据中心传输的可靠性</strong></li><li><strong>技术选型对比</strong>：<ul><li>Quartz：缺乏分布式协调能力</li><li>ElasticJob：文档丰富度不足</li><li><strong>XXL-Job</strong>：选择因其<strong>分片广播机制</strong>和运维可视化</li></ul></li><li><strong>关键实现</strong>：<ul><li><strong>动态分片</strong>：根据MongoDB分片数自动创建对应任务实例</li><li><strong>断点续传</strong>：记录已迁移的ObjectID游标</li><li><strong>容灾方案</strong>：任务失败时触发企业微信机器人告警，并保留原始文件在临时存储区72小时</li></ul></li><li><strong>成效</strong>：数据迁移成功率从92%提升至99.6%，某次机房光纤中断后30分钟内完成数据补传</li></ul><hr><h3 id="三、系统性能力沉淀"><strong>三、系统性能力沉淀</strong></h3><ol><li><strong>可观测性建设</strong>：<ul><li>通过Micrometer指标监控线程池活跃度/队列堆积</li><li>关键任务链路接入SkyWalking，实现95分位耗时跟踪</li></ul></li><li><strong>标准化输出</strong>：<ul><li>将防重组件封装为Spring Boot Starter，被公司其他3个项目复用</li><li>编写《高并发任务调度最佳实践》内部文档</li></ul></li><li><strong>业务价值映射</strong>：<ul><li>数据分析时效性提升使某客户飞机排故时间缩短37%</li><li>平台成为商飞对外技术展示的标杆案例</li></ul></li></ol><hr><p>这个项目让我深刻体会到，优秀的开发不仅要实现功能，更要像产品经理一样思考业务本质，像架构师一样设计扩展性，像运维一样关注稳定性。这正是我向往腾讯技术氛围的原因——在这里能接触到海量用户场景，培养真正的系统工程能力。期待能将这些经验应用到贵司的云原生开发中！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>这场寒冬，比我想的更冷</title>
      <link href="/2025/01/09/%E8%BF%99%E5%9C%BA%E5%AF%92%E5%86%AC/"/>
      <url>/2025/01/09/%E8%BF%99%E5%9C%BA%E5%AF%92%E5%86%AC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>贴一点链接，感兴趣的uu可以mark一下，求一个star,求一个关注，欢迎互换友链哇，评论区留言即可🎊</p><p>CSDN：一手课程作业&amp;学习小记 创作质量95+ 来看看哇~ <a href="https://blog.csdn.net/Astrid_5211?spm=1000.2115.3001.5343">主页</a></p><p>小红书：段子手日常，实习日常，随缘更 <a href="https://www.xiaohongshu.com/user/profile/5e91c3a7000000000100234b">主页</a></p><p>牛客：攒面经、实习日常（经常更）<a href="https://www.nowcoder.com/users/394235056">主页</a></p><p>Github仓库：马上更马上更（别催了xdm） <a href="https://github.com/Alive0103">Alive0103 (Alive) (github.com)</a></p><p>备用服务器：www.alive0103.online 暂时挂掉，搞别的项目</p><p>有急事建议发邮箱喔 <a href="mailto:972477867@qq.com">972477867@qq.com</a></p></blockquote><p>如果不知道往哪走，向前迈出的每一步都是进步。</p><p>找了一周实习，记录一下面试的思考，如果当下的你比较迷茫，不妨投投简历，多面几次，不会也没关系，和面试官聊聊，他们的理解可能会是有效参考。</p><p>在我找实习前，仅仅站在一个大三学生的角度来说，后端可能是本科CS性价比最高的岗位了，进可大厂，退可央国企，尝试了大模型，头疼，遂润。用一学期学习准备了个项目，和之前的论文放一起整了个简历，开投！</p><p>就依次列举几个我印象比较深的公司叭，顺序为面试顺序。</p><h2 id="智乐活（线上）-BOSS">智乐活（线上） BOSS</h2><p>招人开发项目，公司挺大，笔试挂了，2小时全自动笔试，建议找点面筋，菜就多练。</p><h2 id="西安利宁通达-智联">西安利宁通达 智联</h2><p>开发维护公司网页业务（感觉业务规模大）</p><p>老板和西电学生经常合作，愿意培养0基础（不会Springboot的那种）的西电学生，2个月培训期，通过的话需要给他们公司实习连续8个月，建议大二的uu投一下。</p><p>面试-电话面</p><p>实习第一面，没准备任何，非常紧张，面试官声音很好听，彬彬有礼，技术水平非常高，个人认为是我本次所有面试官的MVP。</p><ol><li><p>Java基础</p></li><li><p>Vue的环境如何初始化</p></li><li><p>Vue组件了解多少</p></li><li><p>介绍一下Springboot</p></li><li><p>学习的方法论</p></li><li><p>在业务出现紧急情况会怎样？答：加班搞，搞不出来就向上汇报</p><p>面试官：（笑）其实不对，应该是和你的小伙伴沟通，后端重在沟通而不是一个人死磕</p></li><li><p>如果还是交付失败你会把原因归结在哪？A.你自己 B.你的同事 C.你的老板 D.客户</p><p>答：自己-&gt;同事-&gt;老板-&gt;客户</p><p>面试官：nonono，千万不要内耗，不要过多苛责自己，应该先从leader派发任务的地方开始找原因，要不然容易不开心hh。</p></li><li><p>算法题</p><p>有点忘了，似乎是 100除以7 取商还是余数，不能用除法</p></li><li><p>反问</p><p>（1）您认为三年工作经验的本科生和研究生在同等技术水平的情况下要谁？面试官：本科生，三年能和研究生一样很厉害。</p><p>（2）说明我的情况，想让他给点关于选择的建议。面试官：先找工作后考研，来得及。</p></li></ol><p>一个小时结束，他听得非常认真，每一个问题都给了解答和原因，并说明我应该提升哪方面，如果我大二我包去的哇，很好哭，他的建议真诚到我直接泪目~</p><h2 id="上海涵道空天-51JOB">上海涵道空天 51JOB</h2><p>公司氛围非常非常nice，HR非常专业，会提前打电话再三沟通确认，主动介绍业务和公司规模，了解我的情况，最后去的这个，欢迎蹲蹲我的<a href="https://www.nowcoder.com/users/394235056">实习日记</a></p><p>面试- 线下面</p><p>上午利宁通达下午就是涵道空天，速速复盘，太着急了忘带打好的简历了，在楼下打好拿上去（迷了会路。。。碰见一个好心人给我指路发现他就是涵道空天的hh），进门有hr小姐姐给拿水，问我冷不冷，说来的路上辛苦了，啊~太暖辣！</p><ol><li><p>自我介绍</p><p>哈哈，经过上午的拷打我已经知道面试要自我介绍辣，速速介绍一波，感觉比较苍白，和对着简历念差不多。。。要多练练。</p></li><li><p>问了项目里你遇到的问题</p><p>说了个锁，和json字段在和前端交互时的格式问题</p><p>锁那块比较尴尬，讲着讲着发现一个逻辑问题，感觉一凉，好在面试官及时给了更好的方案。唉，菜就多练。</p><p>前端交互答得一般，因为真的被这个BUG坑了很久（此处点名yupi）</p></li><li><p>开发遇到困难你会怎么做？</p><p>答：多沟通，先和小伙伴说明自己的困难点和情况，请求支援而不是一个人内耗。</p><p>面试官：(满意) 然后聊沟通的重要性</p></li><li><p>你对现有的主流语言有什么看法？</p><p>不太懂要考啥，就非常朴素地说了一下使用体验。（还是喜欢C++一点，可能是刷题刷多了叭）</p></li></ol><p>然后这个面试官离场，hr说还有二面，叫我等一下。QAQ 二面的面试官看起来巨资深。</p><ol><li><p>我对公司的了解</p><p>答了个公司搞材料的。。。（其实是航空航天）</p></li><li><p>问了我对实习有什么要求</p><p>答：希望能够有关于行业的收获同时提升能力，而非单纯做边缘化工作，当然，每个人都会从边缘化工作做起，我会尽力做好贵公司给我的每一个任务。</p><p>面了这么多场，还是唯一一个问我的要求和期望的</p></li><li><p>问了实习时间</p></li><li><p>反问</p><p>忘了我问的啥，好像和上一场是一样的问题，也可能没有反问，忘了忘了</p></li></ol><p>然后就有hr姐姐送到门口，下午就有oc，说是线上签，我想再等等。</p><p>然后拒了一次，感觉挺对不起HR的，唉。后来人家技术主管还给我打电话问我为啥没去，详聊一番，感觉可惜。</p><h2 id="北京宇星石-BOSS">北京宇星石 BOSS</h2><p>公司比较小，小而美，练手试试，主营国产仿真软件制作（类似MATLAB），语言有Java，C++QT，Python，老板人很好，面试官略显生疏。</p><p>面试- 电话面</p><ol><li><p>自我介绍</p></li><li><p>差不多就是那一套，忘了</p></li><li><p>忘了，似乎有算法题，判断环好像是，秒了</p></li><li><p>反问</p><p>（1）您认为三年工作经验的本科生和研究生在同等技术水平的情况下要谁？面试官：本科生，理由：经验多</p><p>（2）既然您是因为经验而要那个本科生，那现在您是否会倾向于比我有更多经验的双非？</p><p>面试官：（顿顿）不会，你有比他更优秀的学习能力和思维。</p><p>感觉不是我想要的答案，因为我问之前就知道他会答这个，但现在依然好奇是不是还有其他答案？</p></li></ol><p>面试官很满意，据老板说他在老板面前狠狠夸我hh。</p><p>二面- 老板电话面</p><p>因为他说会看经验，以为凉了，后接到电话约二面时间。害怕~</p><p>二面由于刚面完下一家的一面，太累了，其实不太想面了，但时间又到了，准备随缘答，老板迟到了半个小时，有点生气，本来准备接了电话就说不去了，然后爽挂，但老板一开口就心软了。</p><ol><li><p>问我职业规划，是否愿意从小公司做起</p><p>包的呀，总归要有个开始不是吗？但绝不会停留</p></li><li><p>介绍业务和我去了之后可以干什么（C++QT方向）</p><p>不对口，我准备拒了</p></li><li><p>他说你先别急，你拒也没事，介绍他的背景——前阿里员工，09毕业，经历了学长口中选择大于一切的时代，想和我聊聊</p><p>太掏心窝子了，小白真的非常感动，很中肯，超级实用，如果你需要建议/想深度了解一下行业的话他可以给你很大的启发。有点好哭，行业选择确实重要，大厂也未必一定是最优解，hh，或许未来的我会有所改观吧，风险偏好者还是想赌一把。</p><p>哦对，我说我觉得大模型太头疼了，比较难受，他真的很认真地安慰我不要内耗，分享了他的研究生生活。</p></li><li><p>反问</p><p>（1）实习生和正职除了技术能力方面在其他方面有什么显著区别？</p><p>答：处理问题的方式方法，正职的方法更加全局化</p><p>（2）你认为实习生最需要摆脱的学生思维是什么？</p><p>这个没答什么，泛泛而谈</p></li><li><p>还聊了别的，关于大学生活，关于生活，关于考研和术、道、命运，hh，他真的很能聊，他说一面的面试官真的超喜欢我！呜~太真心辣，喜欢喜欢</p></li></ol><p>因为这种软件开发用不了那么多人所以极度稳定（适合摆烂bushi），给我开了7K，北京，培训一个月C++QT，然后手把手教做，包食宿。真的爱才，我看出来了。</p><p>还是拒了，毕竟C++QT国企很少，鸡蛋不能放在一个篮子里。</p><h2 id="北京新质向阳-BOSS">北京新质向阳 BOSS</h2><p>哇！你竟然看到这里了！感谢观看！希望我的文章对你有帮助~</p><p>快跑啊快跑，唉，大学生有时候也挺无助的，想报J，[移步xhs吃瓜](<a href="https://www.xiaohongshu.com/explore/677f9bc000000000010012d2?app_platform=android&amp;ignoreEngage=true&amp;app_version=8.68.1&amp;share_from_user_hidden=true&amp;xsec_source=app_share&amp;type=normal&amp;xsec_token=CBsZzwFEkw2fTvW82ECFdK1NDOmlpQsV4lmZ_VuAk_w8o=&amp;author_share=1&amp;xhsshare=WeixinSession&amp;shareRedId=N0s7MUY4RUA2NzUyOTgwNjY0OTc2ODpL&amp;apptime=1736417518&amp;share_id=9b10c5cd4ea84fbcabf2f977728682d5">太幽默了 - 小红书 (xiaohongshu.com)</a>)</p><p>已经无力多说了，拉扯了很久，因为这家拒了涵道空天。后面我问了hr还能不能去，说能，好耶！遇见心软的神了~</p><blockquote><p>其实还有别的一些思考</p></blockquote><p>(1)关于女生，约1/3的面试官提到女生在后端的发展可能存在劣势，其中约1/2在看完我的简历后直接说来做前端可以吗？好叭，浅焦虑了一波，然后就听见自己的下意识反应：那咋了？严重怀疑歧视女性的人和歧视双非的人是同一拨好叭，明明人家都很优秀，贵公司招的是人又不是学位或者性别。。。</p><p>(2)关于HC，虽然没问他们关于当今行业的看法，但可以感受到其实有点悲观，技术与学历似乎很难兼得，工作量和培养成本的要求以及公司体量难以平衡。嗯，这个确实，有待考察，我也很好奇运作良好的公司咋平衡的。</p><p>(3)关于研究生，好吧，其实还在纠结，还不甘心，就是想试试，可能也会考，但也怕自己秋招时候后悔，可能会竹篮打水一场空吧，但又怎样，每一步我都有不后悔的理由。</p><p>(4)经常听学长学姐聊这些，但和面试官聊我感觉不太一样，后端的行情比我想得更冷一点，其实不缺优秀的技术，但缺少毒辣的眼光和有思维的头脑，希望我未来也能找到这种秘诀。</p><p>感谢观看，欢迎蹲蹲我的<a href="https://www.nowcoder.com/users/394235056">实习日记</a>，xhs也会不定期更新</p><p>就像小马过河，别人的简单可能终究不适合你，嘿，勇敢的人先享受世界，我们总要迈出这一步不是吗？</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于主题的潜在bug</title>
      <link href="/2025/01/09/anzhiyu/%E5%85%B3%E4%BA%8E%E4%B8%BB%E9%A2%98%E7%9A%84%E6%BD%9C%E5%9C%A8bug/"/>
      <url>/2025/01/09/anzhiyu/%E5%85%B3%E4%BA%8E%E4%B8%BB%E9%A2%98%E7%9A%84%E6%BD%9C%E5%9C%A8bug/</url>
      
        <content type="html"><![CDATA[<p>这个可真是太劲爆了，不知道是不是只有我一个人遇到了，原来用的Shokax主题可能因为我node的版本不太对，还有一个插件作者以放弃维护导致不兼容，主题传不上去。。。遂换主题，然后历经整整一个月，遇到各种配置的bug，换过wordpress，租了服务器，买了域名，发现不好用，主题也不是很貌美（自己改不了太多。。。）而后某天一行一行对代码终于找出这个主题的小问题，也是给还在用上了哈哈。写给新手，希望能有效解决，别轻易放弃这么美貌的主题~</p><blockquote><p>新增一条：记得清除浏览器缓存，否则看不到我的更新，辛苦了</p></blockquote><h1>github服务器样式渲染错误问题</h1><p>先是用了和安知鱼很像的另一个主题，蓝色鹿头的，发现传上去about页不能居中显示（本地测试正常），找不到解决方法，遂入坑安知鱼，如果你想用同款的其他作者的主题建议谨慎考虑。</p><p>某次本地测试没问题，上传后发现github上的css样式丢失，尝试各种方法无果，一点点改，问题在这里：</p><p><img src="https://pic.imgdb.cn/item/66bdbae0d9c307b7e942f8c3.png" alt="问题"></p><p class='p red'>这里的url不能改，随便改成自己的会导致css渲染不出来，保持原样即可，切记切记！！！</p><h1>本地测试样式丢失问题</h1><p>在初版配置过程中头部会出现配置了图片但显示出来是很多雪花小人，但<code>hexo d</code>上去没问题，后来随着解决样式渲错误问题一并消失。</p><p><img src="https://pic.imgdb.cn/item/66bdbae0d9c307b7e942f8e8.png" alt=""></p><p>绿框部分可能存在不显示图片或者显示的都是同一张图片（经测试大概20张图片就解决这个问题），左边那部分的雪花小人你把URL改成默认就行。</p><p>但这个本地的样式和传上去的不影响，不修复也行，不知道为啥。</p><p>另外弱弱吐槽一句，现在博客对音乐方面的API支持这么弱吗？找API要跨越各种客户端搞半天我真的谢……</p>]]></content>
      
      
      <categories>
          
          <category> anzhiyu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> anzhiyu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26实习避雷</title>
      <link href="/2025/01/09/jike/26%E5%AE%9E%E4%B9%A0%E9%81%BF%E9%9B%B7/"/>
      <url>/2025/01/09/jike/26%E5%AE%9E%E4%B9%A0%E9%81%BF%E9%9B%B7/</url>
      
        <content type="html"><![CDATA[<p>唉，哎哎，大学生真的挺无助的，距离此事已过三周（被期末考硬控了），为时已晚，但还是想吐槽一下，给大家一点提醒。</p><p>Timeline：</p><p>12.7<br>我开始投简历找实习，第一次找没啥经验，也不挑，中小厂都投，然后面试，这周面的5挂1，有一家（A）挺合适的，同时突然刷到这家（B）的业务，主营人工智能，hh，兴趣对口，遂发邮件介绍情况，收到邮件后邀面。</p><p>12.13</p><p>时间比较紧（之前面过的意向快过期了）就请HR排得紧一点，如果过了其实还挺心动的（后来仔细观察疑似外包+黑工）。一面线上，两道题，一道链表反转（不限语言），一道应用题Python/c++均可（文件写入读出/图片压缩），面试官看起来像实习生，没开摄像头（开了一下就关了，不知道啥意思）。</p><p>非常简单，不晓得第二题他想考察什么，这种库的应用不是会用就行吗？要是不经常用谁记啊，不如考点算法。。。</p><p>12.16<br>周一，A的HR催了，遂和B约二面，这家主要技术人员为一美国工作回来的前百度后端，没开摄像头，面试官很累很累，再打哈欠同时和同事闲聊，没听我说话，我说完了搁那问我你刚说啥。</p><p>问了最近在学啥，籍贯，高考成绩，平时咋学习的，会go吗？他们公司后端用go<br>我说学微原，数据库，他问了一个介绍一下冯诺依曼计算机。。。唉，牛刀小试<br>反问</p><ul><li><p>二面能过吗？答：我愿意给你这个机会</p></li><li><p>你对于认为正职和实习生除水平外的思维差异在哪？答：好好干</p></li></ul><p>但还是心动（好吧，是因为业务的规模），加了B的hr微信，回复巨慢，但说了先在北京实习到2月底，那么3月就能到西安了，时间合适，遂拒A，啊，最后还是去了A，hr姐姐巨温柔！！！然后hr说合同是到了那再签，有点疑惑，不能线上签吗？不懂</p><p>好，然后一番确认，我买了石家庄飞回家的机票和西安-&gt;北京的火车，过了几天准备买飞到西安/北京的机票，问hr具体几号，“年后应该可以”–&gt;“不是一休完假就去那边的”–&gt;“再确认一下”–&gt;“怕我太折腾”–&gt;“试图劝退”–&gt;“领导没说我不能保证”–&gt;“3~6月可以去，但不是3月”</p><p>哦对，期间发了邮件版offer，有署名无公章，不知道有没有效，搞笑的是入职日期是2024.1.10，乐，幽我一默</p><p>唉，挺无助的，第二天考试，实在没心思扯了，我自认为我已经拿出了我所有的诚意，如果没有西安的岗何必面呢？如果不能给出时间安排何必骗呢？玩文字游戏是吧，太抽象了，坦诚一点不好吗？</p><p>遂无奈退机票，扣了333，hh，刚好数模奖金发了333.33。好耶！净赚0.33！又是白打的一学期！！！</p><blockquote><p>给UU们点有用信息，这两天收到疑似offer的同学记得快跑，害怕极了。</p><ol><li>每天高强度面试很多人，大概率都过了，腾讯会议，面试时间严格控制在半小时</li><li>问你的个人信息，如籍贯，高考成绩，还不忘diss一番。。。</li><li>给你的建议比较PUA，套话，具体忘了，大概就是作为美国回来的大厂人建议你好好干</li><li>二面通过后可能会有邮件（个人邮箱发送）offer/也可能没有</li><li>boss上岗位虚标，我面的西安的岗，面完直接给我干北京去了<br>如果加了hr的微信，可以试试问这个hr关于公司规模和业务的问题，包不回的</li><li>企查查上公司网站没有，仅显示neginx</li><li>该公司boss上标的规模为20-99，业务介绍却非常宏大，个人猜测外包，忘问了</li><li>该公司企查查上有3~4家关联公司，注销3家，其中有一家被吊销执照且之前主营项目不为互联网</li></ol></blockquote><p>辜负真心的人要吞一万根针</p><p>明天开始实习啦，会多更更日记滴，关注我不迷路！去了A，是线下面的，呜呜呜，感觉整个公司的人都很好，被狠狠温暖到了。</p><p>另外欢迎看看我的主页来换友链哇~愿我的火炬为这寒冬送一点温暖。祝大家offer多多！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统配置安装MySQL</title>
      <link href="/2024/10/02/Linux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85MySQL/"/>
      <url>/2024/10/02/Linux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85MySQL/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Alive0103/NLP-NER">NER</a>顺利结项啦~刚好试试新租的服务器咋用，安个MySQL试试。</p><h1>服务器租赁</h1><p>选用的是腾讯云轻量级服务器（2核4G），Ubuntu系统，租的时候记得选离自己近的机器，传输速度会快一点。</p><p>然后就是登进去，会看见命令行，这就是我们主要操纵机器的地方，不少博客说配置SSH可以免登录，腾讯云这个直接登第一次之后可以自动保存密码，下次登就是免密的，所以配置不成功的UU这一步可以省了。</p><h1>MySQL安装</h1><p>纯小白，翻阅不少博客发现是需要下载软件然后上传的道服务器或者虚拟机，比较麻烦，幸运看见这篇<a href="https://www.cnblogs.com/huangjiabobk/p/18214866#:~:text=%E5%9C%A8Linux%E4%B8%AD%E9%85%8D%E7%BD%AE%E6%95%B0">博客</a>，亲测好用，两行代码搞定！</p><h2 id="安装MySQL">安装MySQL</h2><p>对于基于Debian的系统（如Ubuntu）:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install mysql-server</span><br></pre></td></tr></table></figure><p>对于基于Red Hat的系统（如CentOS）:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install mysql-server</span><br></pre></td></tr></table></figure><h2 id="安全配置">安全配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql_secure_installation</span><br></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/66fd2186f21886ccc0fe9e6f.jpg" alt=""></p><p>这里会让你选密码等级，我选的2（最高等级，和我登录服务器密码强度一致）。</p><h2 id="细节配置">细节配置</h2><p>然后会有一系列介绍，全选<code>y</code>也没问题，可以看我下面的解释慢慢选。</p><ol><li>匿名用户</li></ol><p><img src="https://pic.imgdb.cn/item/66fd21f9f21886ccc0ff0705.jpg" alt=""></p><p>默认情况下，MySQL 安装完成后会创建一个匿名用户，这个用户可以无需账户就能登录 MySQL。这通常用于测试或简化安装过程，但如果你打算将 MySQL 用于生产环境，则强烈建议你删除这个匿名用户，以确保安全性。</p><ol start="2"><li>禁止 root 用户的远程登录</li></ol><p><img src="https://pic.imgdb.cn/item/66fd21f8f21886ccc0ff06e3.jpg" alt=""></p><p>MySQL 的 <code>root</code> 用户被设置为只能从 <code>localhost</code>（本地）登录，这是一种安全措施，防止黑客通过网络尝试猜测 root 密码。如果允许 <code>root</code> 远程登录，系统将面临更大的安全风险，尤其是在生产环境中。因此，通常建议禁止 root 的远程登录，只允许其在服务器本地进行操作。</p><ol start="3"><li>默认的 <code>test</code> 数据库</li></ol><p><img src="https://pic.imgdb.cn/item/66fd228ef21886ccc0ff80e5.jpg" alt=""></p><p>MySQL 默认会创建一个名为 <code>test</code> 的数据库，任何用户都可以访问它。这个数据库主要用于测试目的，并不具备严格的访问控制。</p><ol start="4"><li>重新加载权限表</li></ol><p><img src="https://pic.imgdb.cn/item/66fd228ff21886ccc0ff80f7.jpg" alt=""></p><p>MySQL 的权限表（privilege tables）存储了所有用户的权限信息。进行用户管理、更改权限、删除匿名用户等操作后，需要重新加载这些表，才能使更改生效。这个过程不会中断 MySQL 服务，只是让你所做的更改立刻生效。</p><h2 id="启动MySQL服务">启动MySQL服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start mysql</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> mysql</span><br></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/66fd228ff21886ccc0ff810d.jpg" alt=""></p><p>如图，成功启动🌸</p><h1>基本使用</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">create database helloworld; <span class="comment">#创建数据库：create database 数据库名</span></span><br><span class="line">show databases;<span class="comment">#查看已存在的数据库，一般会默认存在些 </span></span><br><span class="line"></span><br><span class="line">use helloworld; <span class="comment">#使用表</span></span><br><span class="line"></span><br><span class="line">create table student( <span class="comment">#创建初始表格</span></span><br><span class="line">name varchar(32),</span><br><span class="line">age int,</span><br><span class="line">gender varchar(2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">show tables;<span class="comment">#查看创建好的表</span></span><br><span class="line"></span><br><span class="line">insert into student(name,age,gender) value(<span class="string">&#x27;张三&#x27;</span>,20,<span class="string">&#x27;男&#x27;</span>); <span class="comment">#插入数据到表格中：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * from student;<span class="comment">#查看表的内容</span></span><br></pre></td></tr></table></figure><p>建立数据库，本质就是创建一个文件，一顿操作下来如图，成功使用。</p><p><img src="https://pic.imgdb.cn/item/66fd228ef21886ccc0ff80cb.jpg" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Few-Shot论文</title>
      <link href="/2024/09/24/NER/%E8%AE%BA%E6%96%87%E5%88%9D%E7%A8%BF/"/>
      <url>/2024/09/24/NER/%E8%AE%BA%E6%96%87%E5%88%9D%E7%A8%BF/</url>
      
        <content type="html"><![CDATA[<h1>摘要</h1><p>随着深度学习技术的发展，命名实体识别（NER）任务中传统的持续学习与增量学习方法逐渐暴露其局限性。这些方法通常需要重新访问并训练所有类别的数据，导致计算资源消耗巨大，并且在引入新知识时，容易遗忘已学的旧知识，产生灾难性遗忘问题。类增量学习（CIL）作为一种新的方法，能够在模型接触新的实体类别时，不访问旧类别数据，依然保持对旧类别的识别能力，从而有效节省计算资源。然而，面对长序列任务时，现有类增量学习方法对旧类别的遗忘问题依旧是挑战。</p><p>在此背景下，本文提出了一种基于少样本条件下的类增量NER模型训练方法，旨在进一步缓解灾难性遗忘问题，增强模型对新旧类别的平衡能力。本文方法的核心思想是结合少样本学习理论与NER问题，综合利用知识蒸馏、伪标签生成、合成数据增强等多种技术手段，在少样本条件下提升模型的泛化能力。同时，为模拟人脑的学习机制，我们引入学习与回顾（L&amp;R）策略，定期回顾旧类别知识，以保持模型对新旧类别的认知平衡，确保模型在逐步引入新类别的过程中不会遗忘旧知识。</p><p>首先，在知识蒸馏过程中，通过构建新旧模型之间的知识传递，避免新类别知识覆盖旧类别知识。新模型通过学习旧模型的输出，使其在学习新类别时，保持对旧类别的识别能力。其次，针对少样本学习问题，本文采用伪标签生成和合成数据增强两种策略。伪标签生成通过利用已训练模型预测未标注数据中的实体类别，从而生成更多的训练数据，增强模型对新类别的泛化能力。合成数据增强则通过生成与新类别相关的未标注上下文，扩展了数据集，使模型在不需要访问旧类别数据的情况下，接触到更多的训练样本，进一步缓解数据不平衡和数据量不足的问题。最后，学习与回顾策略通过模拟人类的复习机制，在学习新类别的同时定期回顾旧类别的知识，强化模型对旧类别的记忆，有效防止灾难性遗忘问题的发生。</p><p>为了验证所提方法的有效性，本文在中国军事数据集上进行了实验测试。该数据集包含多个实体类别，实验中通过逐步引入新类别，对模型的增量学习能力进行评估。实验结果表明，本文提出的复合训练方法在缓解灾难性遗忘方面取得了显著的效果。与传统的知识蒸馏方法相比，不仅有效保持了对旧类别的识别能力，而且在少样本条件下显著提升了模型对新类别的泛化性能。此外，伪标签生成和合成数据增强策略的引入进一步扩展了训练数据集规模，提高了模型在数据稀缺情况下的适应性。学习与回顾策略则通过模拟人脑的学习机制，使得模型在长序列任务中表现出更好的稳定性与平衡性。实验数据中不同序列的F1分数进一步证明了该方法的优越性。</p><p>本文的主要贡献在于从多角度提出了一种面向少样本场景的类增量NER模型训练方法，综合利用知识蒸馏、伪标签生成、合成数据增强以及学习与回顾策略，全面缓解类增量NER中的灾难性遗忘、标签不完整、类别不平衡和少样本学习等问题。与传统方法相比，我们的方法在理论上丰富了类增量学习的研究，在实践中也展现出良好的适应性和泛化能力，能够在不断变化的动态任务环境中保持对新旧类别的平衡识别。该研究为未来的NER任务提供了新的思路，尤其在数据稀缺、类别动态变化的实际应用场景中，具有重要的应用价值和实践意义。</p><p><strong>关键词</strong>：命名实体识别，类增量学习，少样本学习，知识蒸馏，伪标签生成，学习与回顾</p><h1>1.发展现状</h1><h2 id="1-1类增量学习">1. 1类增量学习</h2><p>随着深度学习技术的飞速发展，传统的持续学习和增量学习方法逐渐暴露出其在实际应用中的局限性。尤其在命名实体识别（NER）任务中，模型需要能够适应不断变化的输入数据和新增的实体类别。持续学习通常依赖于在所有任务或类别上进行重新训练，这不仅计算资源消耗巨大，还可能导致模型在引入新知识时遗忘已学的旧知识，产生<strong>灾难性遗忘</strong>（Catastrophic Forgetting）。</p><p>为了解决这一问题，类增量学习（CIL）应运而生。类增量学习是逐步取代传统持续学习和增量学习的一种方法，尤其在NER任务中表现得尤为重要。其目标是使模型在接触新的实体类别时，能够在不访问旧类别数据的情况下，仍然保持对旧类别的识别能力。这种能力使得类增量学习能够在不断引入新类别或任务时，避免重新训练全模型，节省计算资源，并有效克服灾难性遗忘的问题。</p><h3 id="1-1-1-传统学习方式的比较">1.1.1 传统学习方式的比较</h3><ul><li><strong>持续学习（Continual Learning）</strong>：持续学习指的是模型逐渐学习多个任务而不丧失对先前任务的记忆。其核心挑战在于如何在添加新知识的同时，保持对旧任务性能的稳定。然而，持续学习难以有效解决灾难性遗忘，尤其在跨领域或跨类别任务中，模型的表现往往会显著下降。</li><li><strong>增量学习（Incremental Learning）</strong>：增量学习与持续学习相似，但强调在不断接触新数据时逐步学习和改进。这种学习方式特别适用于数据快速增长且不可重复使用的场景。然而，增量学习同样面临对旧类别的遗忘问题，特别是在任务序列较长时，模型会逐渐失去对早期任务的记忆。</li><li><strong>终身学习（Lifelong Learning）</strong>：终身学习的理念是希望模型在整个生命周期内能够积累知识并应用于未来任务。这种学习方式更关注长期的知识积累与迁移，但与持续学习和增量学习类似，灾难性遗忘仍然是核心难题。</li></ul><p>这些学习方式的共同挑战在于<strong>灾难性遗忘</strong>（Catastrophic Forgetting），即模型在学习新任务时会遗忘掉已经学习过的旧任务或类别。因此，类增量学习在此基础上提出了专门应对灾难性遗忘的方法，特别适合那些需要逐步引入新类别的任务，如命名实体识别（NER）。</p><h3 id="1-1-2-NER任务中的类增量学习">1.1.2 NER任务中的类增量学习</h3><p>命名实体识别任务是信息抽取中的重要任务之一。传统的NER模型通常假设所有实体类别在训练阶段都是已知的，然而在实际应用中，新的实体类别可能会随着时间的推移不断出现。例如，在军事领域、医疗领域等专门的领域中，不断出现新的实体类型，这要求NER模型具备在不访问旧数据的情况下学习新实体的能力。</p><p>类增量NER的出现正是为了解决这一需求。与传统NER不同，类增量NER需要模型能够有效学习新类别，同时尽可能保留对旧类别的记忆。在这种场景中，类增量学习不仅要求模型具有良好的泛化能力，还必须较好地解决灾难性遗忘问题。</p><h2 id="1-2-类增量学习中缓解灾难性遗忘的方法">1.2 类增量学习中缓解灾难性遗忘的方法</h2><p>在类增量学习中，灾难性遗忘是最主要的挑战之一。模型在学习新任务时，往往会逐渐遗忘掉之前学习过的任务，尤其在没有访问旧数据的情况下。这种现象在NER任务中尤为显著，因为实体类别的重叠和相似性使得模型容易在识别新实体时丧失对旧实体的区分能力。</p><p>为了解决这一问题，研究者提出了多种方法来缓解灾难性遗忘，主要包括以下几种方法：</p><ul><li><strong>知识蒸馏（Knowledge Distillation）</strong>：知识蒸馏通过让新模型在训练时学习旧模型的输出，从而保留旧模型对旧任务的知识。对于类增量NER任务，知识蒸馏可以在引入新实体类别时，确保模型不会遗忘之前学习过的类别。蒸馏的方法通常是在模型训练过程中引入额外的损失函数，使得新模型的输出与旧模型的输出尽可能接近，从而保持对旧类别的识别能力。</li><li><strong>合成数据增强（Synthetic Data Augmentation）</strong>：合成数据增强是一种通过生成新的数据样本来增强模型泛化能力的方法。通过生成未标注的上下文文本并将其加入训练数据，模型可以在不需要访问旧数据的情况下学习到新的类别。合成数据增强的优势在于可以通过生成的上下文重新构建数据集，从而实现数据的多样化和丰富化，缓解数据不平衡和数据量不足的问题。</li><li><strong>伪标签生成（Pseudo-labeling）</strong>：伪标签生成通过使用现有模型预测未标注数据中的实体类别，从而生成带有标签的数据进行训练。在类增量NER任务中，伪标签生成可以帮助模型扩展数据集，增强对新类别的学习能力。这一方法的核心思想是使用模型预测新的实体类别，产生“伪标签”，并将这些带有伪标签的数据加入训练集中。</li><li><strong>学习与回顾（Learn &amp; Review, L&amp;R）</strong>：L&amp;R方法通过让模型在学习新类别的同时，定期回顾旧类别，从而确保模型不会忘记旧任务。在类增量NER中，L&amp;R方法通过使用合成数据进行回顾训练，使得模型能够在新类别的学习过程中保持对旧类别的记忆。该方法被证明比单纯的知识蒸馏更加有效，尤其在数据不平衡的情况下，能够显著提高模型的性能。</li></ul><p>这些方法各有侧重，但其共同目标是通过各种技术手段缓解类增量学习中的灾难性遗忘问题，从而使模型在面对新任务时，仍然能够保留旧任务的知识。</p><h2 id="1-3-传统NER与类增量NER的对比">1.3 传统NER与类增量NER的对比</h2><p>传统NER模型在训练时，通常假设所有的实体类别在训练过程中都是已知的。模型一旦训练完成，便无法再扩展新类别，除非重新训练整个模型。然而，在实际应用中，特别是在动态变化的环境中，新的实体类别会不断出现，这对传统NER模型提出了极大的挑战。</p><ul><li><strong>传统NER的局限性</strong>：传统NER模型在处理新增实体类别时往往表现不佳，原因在于它们无法增量学习新类别。此外，传统NER在引入新类别时，需要访问之前的训练数据，这在许多实际场景中是不现实的（例如，隐私数据无法存储或共享）。</li><li><strong>类增量NER的优势</strong>：类增量NER模型能够在不访问旧数据的情况下引入新的实体类别，同时保持对旧类别的识别能力。它通过知识蒸馏、伪标签生成和合成数据增强等技术手段，确保模型能够逐步学习新的实体类别，同时减少灾难性遗忘问题。与传统NER相比，类增量NER更具适应性，尤其在需要频繁更新和扩展类别的任务中。</li><li><strong>灾难性遗忘问题的特异性</strong>：类增量NER中的灾难性遗忘问题比其他任务更加复杂，因为实体类别之间的相似性更高。新增类别往往与旧类别存在一定的重叠或相似之处，导致模型在学习新类别时容易遗忘旧类别。此外，实体类别的数量和多样性也给模型带来了更大的学习难度。</li></ul><p>可见，类增量NER模型相较于传统NER模型在动态、变化的任务环境下具有更强的适应能力，同时其面临的灾难性遗忘问题也更加复杂，这使得现有的解决方案仍有进一步优化的空间。</p><h1>2.存在的问题</h1><p>类增量命名实体识别（NER）是一项复杂的任务，面临着在不断引入新实体类别时的诸多独特挑战。随着新实体的持续出现，模型不仅需要灵活适应这些变化，还必须保持对已学类别的准确识别。以下将详细讨论该领域当前存在的主要问题，并探讨这些问题与其他自然语言处理（NLP）任务中类增量学习的差异。这些分析有助于更清晰地理解类增量NER所面临的特定需求与挑战。</p><h2 id="2-1-灾难性遗忘问题">2.1 <strong>灾难性遗忘问题</strong></h2><p>灾难性遗忘是类增量学习中最为典型和显著的问题，也是类增量NER必须重点解决的核心挑战。模型在学习新实体类别时，容易遗忘掉之前已经学过的类别，这是由于在增量学习过程中，模型权重会调整为适应新任务，而使旧任务的权重被覆盖。这种现象在NER任务中尤为明显，因为实体类别之间的边界较模糊，新类别可能与旧类别存在高度相似性或重叠。</p><p><strong>现有问题：</strong></p><ul><li>类增量NER中的灾难性遗忘不仅影响实体类别的识别准确性，还可能导致模型对未标注类别的错误预测。例如，模型在学习一个新的“炸弹”实体时，可能会误将之前学到的“导弹”实体标记为非实体。</li><li>灾难性遗忘不仅导致对旧类别的遗忘，还可能引发类别混淆问题。模型可能在新类别学习过程中，将相似的旧类别混淆，例如将“军舰”和“航天设备”错误地视为同一类别。</li><li>现有的方法（如知识蒸馏、数据增强等）在一定程度上缓解了灾难性遗忘，但它们仍然依赖于模型对数据分布的良好掌握，且在数据稀少的情况下（如少样本或零样本条件下），效果有限。</li></ul><p><strong>解决方案：</strong></p><ul><li><strong>多任务学习策略</strong>：通过并行学习多个任务或实体类别，以减少类别间的混淆和灾难性遗忘。</li><li><strong>增强型知识蒸馏</strong>：在类增量NER中，结合标签解释学习等方法，进一步优化知识蒸馏的效果，确保旧类别知识不会轻易丢失。</li><li><strong>动态模型更新机制</strong>：动态更新模型权重，赋予不同类别不同的重要性，从而减少对旧类别知识的遗忘。</li></ul><h2 id="2-2-标签不完整问题">2.2 <strong>标签不完整问题</strong></h2><p>传统的方法依赖于大量的标注数据，但在实际场景中，完整标注数据的获取成本高昂，尤其是随着类别的不断扩展，标注的难度和代价也随之增加。在类增量NER任务中，模型通常只能访问部分实体类别的数据，导致数据集存在标签不完整的情况。</p><p><strong>现有问题：</strong></p><ul><li>标签不完整导致模型在训练过程中对未标注的实体类别缺乏了解，进而影响对新实体的识别。在类增量场景下，模型可能会将未见过的实体标记为非实体，导致模型泛化能力下降。</li><li>标签不完整也加剧了类别间的不平衡问题。新加入的类别通常数据较少，而旧类别的数据更多，这种不均衡使得模型在训练时更容易倾向于识别旧类别，从而导致对新类别的识别能力不足。</li></ul><p><strong>解决方案：</strong></p><ul><li><strong>伪标签生成</strong>：通过在未标注的数据中生成伪标签，使模型能够在有限的标注数据基础上进一步扩展数据集，弥补标签不完整的缺陷。</li><li><strong>数据增强和合成数据</strong>：使用合成数据生成器生成更多样化的训练样本，帮助模型在标签不完整的情况下更好地捕捉新类别的特征。</li></ul><h2 id="2-3-类别不平衡和冲突问题">2.3 <strong>类别不平衡和冲突问题</strong></h2><p>随着新类别的加入，旧类别的数据量往往远多于新类别，模型采样不均衡，样本较少的新类更容易识别成旧类。类别冲突问题主要体现在不同类别之间可能存在重叠，且会引入多样化的实体类型，较为相近的语义会造成模型的混淆，不利于正确学习分类，导致模型在区分相似类别时出现困扰。</p><p><strong>现有问题：</strong></p><ul><li>类别不平衡容易导致模型偏向于预测频率较高的旧类别，而忽视新类别，特别是在新类别的数据非常少的情况下。模型会对大类别过拟合，而对小类别欠拟合。</li><li>类别冲突加剧了类别之间的混淆。例如，在军事领域，“导弹”和“炸弹”可能在文本中表现出相似的上下文，导致模型在识别时难以区分。</li><li>现有的NER模型通常假设类别之间是完全独立的，但在类增量学习中，类别之间往往有一定的关联性，模型需要具备区分相似类别的能力。</li></ul><p><strong>解决方案：</strong></p><ul><li><strong>数据重采样和权重调整</strong>：通过对少数类进行过采样，或者对不同类别分配不同的权重，以缓解类别不平衡问题。</li><li><strong>类间对比学习</strong>：采用对比学习方法，帮助模型更好地理解相似类别之间的区别，减少类别冲突带来的影响。</li></ul><h2 id="2-4-少样本学习问题">2.4 <strong>少样本学习问题</strong></h2><p>模型在引入新的实体类别时，通常只有极少的数据，甚至没有任何标注数据。这种数据极少的情况在类增量学习中非常常见，尤其是对于不断扩展的实体类别集合，标注成本高昂且数据获取难度大。</p><p><strong>现有问题：</strong></p><ul><li>少样本问题导致模型无法有效地学习新实体类别的特征，这对于识别那些在训练中从未见过或见过很少样本的新实体来说，尤其困难。</li><li>现有的NER方法通常需要大量标注数据进行训练，因此在少样本或零样本条件下，传统的监督学习方法表现不佳。</li><li>类增量NER在这种情况下必须依赖于迁移学习或其他数据扩展技术，但这些技术在新类别的泛化能力上仍有局限。</li></ul><p><strong>解决方案：</strong></p><ul><li><strong>基于迁移学习的少样本学习</strong>：通过迁移学习将旧类别的知识迁移到新类别上，从而实现少样本甚至零样本的NER任务。</li><li><strong>基于生成模型的合成数据</strong>：使用生成模型创建合成数据，尤其是针对少样本或零样本条件下的数据不足问题，增强模型的泛化能力。</li></ul><h2 id="2-5-过拟合问题">2.5 <strong>过拟合问题</strong></h2><p>在类增量NER任务中，过拟合问题常常由于数据不平衡、类别间相似性高等因素被进一步放大，模型在学习过程中可能会过度依赖特定的类别特征，导致在测试阶段的泛化能力下降。</p><p><strong>现有问题：</strong></p><ul><li>新类别数据量通常较少，而旧类别数据量较多，模型容易在旧类别上过拟合。特别是在类增量学习中，模型不断扩展类别，而每次新增的数据量非常有限，这使得模型容易学习到新类别的噪声特征，而忽略其一般化特征。</li><li>在标签不平衡或类别冲突较为明显的情况下，模型会更倾向于记住某些特定的类别特征，进而丧失对整体数据分布的把控。</li></ul><p><strong>解决方案：</strong></p><ul><li><p><strong>正则化技术</strong>：通过引入额外的正则化项来限制模型的复杂性，避免过拟合。L2正则化和dropout技术在一定程度上可以缓解此问题。</p></li><li><p><strong>早停法</strong>：通过观察模型在验证集上的性能，尽早停止训练，避免模型在训练数据上过拟合。</p></li></ul><p>综上，类增量NER面临的主要挑战包括灾难性遗忘、标签不完整、类别不平衡、类别冲突、少样本学习以及模型过拟合等。这些问题在与其他NLP任务的类增量学习相比时显得更加复杂且独特，必须针对这些问题提出专门的解决方案。通过结合现有的技术（如知识蒸馏、伪标签生成、合成数据增强等）以及创新的模型设计，有望有效应对这些挑战，并在类增量NER中取得更好的结果。</p><h1>3.理论背景</h1><h2 id="3-1-类增量NER背景与挑战">3.1 类增量NER背景与挑战</h2><p>随着信息提取任务在自然语言处理（NLP）中的重要性日益增加，命名实体识别（NER）任务作为信息抽取的核心任务之一，面临着越来越复杂的应用场景。在动态变化的环境中，如军事、医学或社交媒体等领域，新实体类别的不断涌现使得传统NER模型难以应对。传统的NER模型通常假设在训练阶段可以接触到所有实体类别的数据，而在部署后无法轻易适应新的类别，且会遗忘旧类别知识。这些限制在实际应用中显得尤为突出，特别是在标注数据有限的少样本条件下。</p><p>类增量学习通过逐步引入新类别的方式来克服这一局限，允许模型在学习新类别的同时保持对旧类别的认知。然而，类增量NER任务中最主要的挑战包括<strong>灾难性遗忘</strong>、<strong>标签不完整</strong>、<strong>类别不平衡</strong>和<strong>少样本/零样本学习问题</strong>。这些问题使得模型在逐步扩展新类别时，容易忘记旧类别或无法有效泛化新类别的特征。</p><h2 id="3-2-解决思路">3.2 解决思路</h2><p>本文旨在针对类增量NER中的上述挑战，提出一种基于少样本条件下的类增量NER模型训练方法。该方法通过结合知识蒸馏、伪标签生成、合成数据增强等技术手段，从各方面缓解灾难性遗忘问题，增强新类别的识别能力，特别是在少样本甚至零样本的情况下。具体解决方案如下：</p><ul><li><strong>灾难性遗忘</strong>：通过知识蒸馏，将旧类别知识转移到新模型中，确保在学习新类别时不丢失对旧类别的记忆。</li><li><strong>少样本学习</strong>：通过伪标签生成和合成数据增强，扩展少量的新类别样本，增加模型对新类别的泛化能力，特别是在数据稀缺或无法获取大量标注数据的场景中。</li><li><strong>标签不完整与类别不平衡</strong>：通过生成伪标签和合成数据，解决数据集中由于标签不完整或类别数据不平衡引发的偏差问题，使模型在面对不同类别时表现更加均衡。</li></ul><h2 id="3-3-理论框架">3.3 理论框架</h2><h3 id="3-3-1-少样本学习">3.3.1 少样本学习</h3><p>少样本学习（Few-shot Learning，FSL）是指在仅有极少数据样本的情况下，模型仍能够对新任务进行有效学习的能力。少样本学习的理论基础源于迁移学习和元学习，其目标是通过从已有任务中学习到的知识迁移或泛化到新的任务上，以减少对大量标注数据的需求。</p><p>在本文中，少样本学习的理论与类增量NER结合起来，主要目的是在引入新类别时，由于标注成本高、数据稀缺，模型能够通过少量样本或零样本数据学习到新实体类别的特征。同时，通过结合伪标签生成与数据增强的方法，扩展现有的训练数据，从而进一步提高模型在少样本条件下的泛化能力。</p><h3 id="3-3-2-知识蒸馏">3.3.2 知识蒸馏</h3><p>知识蒸馏（Knowledge Distillation）是一种将复杂模型（教师模型）的知识传递给更简单模型（学生模型）的方法。在类增量学习中，知识蒸馏的作用是通过将旧模型的知识传递到新模型，防止新模型在学习新类别时遗忘之前的类别知识。</p><p>在本文中，知识蒸馏被用于缓解类增量NER中的灾难性遗忘问题。通过对旧类别的知识进行蒸馏，使新模型能够在学习新类别时，仍然保持对旧类别的识别能力。这一过程通过引入额外的损失函数，强制新模型的输出与旧模型一致，从而减少旧类别的知识遗忘。特别是在少样本条件下，知识蒸馏不仅有助于保持旧类别的记忆，还能帮助模型更有效地利用新类别的有限数据。</p><p>针对<strong>灾难性遗忘问题</strong>，知识蒸馏是解决灾难性遗忘的核心方法之一，通过在模型训练时保留旧类别的知识，防止新类别学习时的知识覆盖；针对<strong>标签不完整问题</strong>，通过蒸馏旧类别的知识，模型在新数据缺少旧类别标签的情况下，也能维持对旧类别的较高识别能力。</p><h3 id="3-3-3-合成数据增强">3.3.3 合成数据增强</h3><p>合成数据增强（Synthetic Data Augmentation）是通过生成合成样本来扩展训练数据集的一种技术，通常用于应对数据稀缺和类别不平衡问题。合成数据增强通过训练生成模型（如LSTM或GPT）生成与原始数据分布类似的合成数据，并将其用于训练，以提高模型的泛化能力。</p><p>本文中合成数据增强主要用于少样本条件下的数据扩展和类别平衡。通过生成未标注的上下文或样本，模型可以在没有大量标注数据的情况下继续学习新类别的特征。这种方法不仅增加了新类别的样本数量，也使得模型对新类别的学习更加全面，进而减轻类别不平衡带来的影响。</p><p>针对<strong>类别不平衡问题</strong>，合成数据增强通过生成更多的新类别数据，弥补了数据不平衡的现象，使模型在训练时不会偏向旧类别；针对<strong>少样本学习问题</strong>，通过合成与新类别相关的上下文数据，模型可以在数据不足的情况下进行更充分的学习，提升对新类别的识别能力。</p><h3 id="3-3-4-标签解释学习">3.3.4 标签解释学习</h3><p>标签解释学习方法适用于解决少样本命名实体识别中的泛化问题。为了应对少样本NER面临的仅凭少量的标注数据，模型很难准确识别和分类新的命名实体这一挑战，该方法通过在模型训练过程中引入多样化的实体类型及其详细的自然语言描述，使模型能够更好地理解和泛化未见过的实体类型。</p><p>在训练阶段，模型学习和理解这些标签的语义，然后在少量示例的情况下，将所学知识应用于识别和分类新的实体类型，提升模型的跨域和跨语言泛化能力，使其能够在未见过的领域或语言环境中依然表现出色，有效应对少样本条件下的NER任务。</p><h3 id="3-3-5-伪标签生成">3.3.5 伪标签生成</h3><p>伪标签生成（Pseudo-labeling）是一种半监督学习方法，基本思路是利用现有模型预测未标注数据的标签，生成伪标签，并将这些带有伪标签的数据加入到训练集中，从而扩展数据集规模。</p><p>本文利用伪标签生成方法扩展少样本数据集，特别是在新实体类别数据稀缺的情况下。通过使用已训练模型预测未标注数据中的实体类别，将生成的伪标签与真实标注的数据混合使用，增强模型对新类别的泛化能力。这样可以有效缓解类增量NER中由于数据不足带来的问题。</p><p>针对<strong>少样本学习问题</strong>，伪标签生成通过在新类别上生成更多带伪标签的数据，扩大了数据集的规模，有效提高了模型在少样本条件下的学习能力；针对<strong>标签不完整问题</strong>，当新数据缺少部分实体类别的标注时，伪标签生成可以补全这些缺失的标签，从而提高模型的学习效果。</p><h3 id="3-3-6-学习与回顾（L-R）">3.3.6 学习与回顾（L&amp;R）</h3><p>通过模拟人类通过不断复习旧知识来加深记忆的机制，在每个增量学习阶段结束后，通过回顾旧类别的知识，帮助模型保持对旧类别的认知。在学习新类别数据之后，模型会在增强后的数据集上进行再次训练，以重新强化对旧类别的记忆。</p><p>学习与回顾（L&amp;R）策略不仅通过系统的复习和强化训练缓解了灾难性遗忘问题，还通过丰富的训练数据支持了少样本学习的有效性。这种结合使得模型在增量学习过程中更加灵活和稳健，能够在新旧类别之间实现良好的平衡。</p><h2 id="3-4-理论方法总结">3.4 理论方法总结</h2><p>本文提出了一种综合知识蒸馏、伪标签生成、合成数据增强和L&amp;R的类增量NER方法，重点解决类增量NER任务中的灾难性遗忘和少样本学习问题。</p><p>具体而言，模型在每个增量阶段的学习过程中，首先通过<strong>知识蒸馏</strong>保持对旧类别的认知，避免灾难性遗忘；然后使用<strong>伪标签生成</strong>来扩展少量的新类别数据，增加数据规模；最后，通过<strong>合成数据增强</strong>进一步增加数据集的多样性和数量，缓解类别不平衡及少样本问题。</p><h1>4. 研究方法</h1><p>通过结合<strong>人脑学习机制的类比</strong>，我们提出了一种基于<strong>少样本条件下的类增量NER方法</strong>。该方法的核心思想是从人类学习的过程汲取灵感，设计多种策略以缓解类增量学习中的<strong>灾难性遗忘</strong>、<strong>少样本学习</strong>、<strong>标签不完整</strong>及<strong>类别不平衡</strong>等问题。我们使用了<strong>知识蒸馏</strong>、<strong>伪标签生成</strong>、<strong>合成数据增强</strong>和**学习与回顾（L&amp;R）**策略，以确保模型在逐步引入新类别时，能够同时保留旧类别的知识，且在少样本条件下具备较好的泛化能力。</p><h2 id="4-1-人脑学习机制">4.1 <strong>人脑学习机制</strong></h2><p>人类学习新知识时通常依赖于复习旧知识、推理和联想，以及构建假设场景来提升记忆和理解能力。类比于此，我们的方法设计通过以下几个方面模拟了人脑学习的过程：</p><ul><li><strong>知识蒸馏</strong>：这一策略类似于人类在学习新知识时通过不断复习来巩固已学知识。通过知识蒸馏，我们将旧模型的知识传递给新模型，确保新模型在学习新类别的同时，不会遗忘旧类别。就像人类通过复习保持对旧知识的记忆一样，知识蒸馏使得模型在新旧类别的学习中达到平衡。</li><li><strong>伪标签生成</strong>：伪标签生成则类似于人类通过联想和推理在不完全信息的情况下进行推测。当人类面对不确定的情境时，往往通过联想和类比做出预测和判断。伪标签生成通过已训练模型预测未标注数据中的实体类别，扩展数据集，帮助模型在少样本或零样本条件下提升对新类别的识别能力。</li><li><strong>学习与回顾（L&amp;R）策略</strong>：L&amp;R策略模拟了人类通过反复回顾来提升记忆的过程。人类在学习新知识时，通常通过回顾之前学过的内容来增强记忆和理解。L&amp;R策略在训练过程中，通过回顾旧类别的知识，帮助模型保持对旧类别的认知，并确保新旧类别的平衡。</li></ul><p>本文提出了在<strong>少样本条件下的类增量NER方法</strong>，旨在解决类增量NER任务中的<strong>灾难性遗忘</strong>、<strong>少样本学习</strong>、<strong>标签不完整</strong>及<strong>类别不平衡</strong>等问题。我们的研究方法主要包括三个核心步骤：知识蒸馏（Knowledge Distillation）、伪标签生成（Pseudo-labeling）和合成数据增强（Synthetic Data Augmentation），并在这些方法的基础上结合**学习与回顾（Learn &amp; Review, L&amp;R）**框架，逐步构建类增量NER模型。</p><h2 id="4-2-框架设计">4.2 <strong>框架设计</strong></h2><p>为了验证我们所提出方法的有效性，本文使用了一个分步的增量学习框架。在每一阶段中，模型将逐步接触新的实体类别，并学习在少量标注数据或零样本情况下识别新类别。同时，在不访问旧类别数据的前提下，模型通过知识蒸馏、伪标签生成和合成数据增强技术，缓解对旧类别的遗忘。</p><p>核心思想是通过多步训练和逐步引入新类别，使模型具备类增量学习的能力，并能够在每次学习新类别时保持对旧类别的记忆能力，尤其在少样本条件下提升模型的泛化性能。</p><p>为了解决类增量NER任务中的核心问题，特别是灾难性遗忘和少样本学习，本研究设计了以下几种方法：</p><h3 id="4-2-1知识蒸馏">4.2.1<strong>知识蒸馏</strong></h3><p>知识蒸馏的核心作用是<strong>缓解灾难性遗忘</strong>。通过将旧模型对旧类别的知识蒸馏给新模型，使新模型能够在学习新类别的同时，保留对旧类别的记忆。蒸馏过程确保了新模型输出与旧模型在旧类别上的输出保持一致，从而避免了新知识覆盖旧知识的情况。通过这种方法，模型能够有效地在逐步引入新类别的过程中保留旧类别的识别能力。</p><p>训练过程中，旧模型的输出（即对旧类别的预测分布）被用作教师模型。新模型通过优化目标函数，使其在学习新类别的同时，保持输出与旧模型对旧类别的预测相一致。</p><p>损失函数包含两部分：一是用于学习新类别的标准交叉熵损失，二是用于保持旧类别知识的蒸馏损失，后者通过缩小新旧模型在旧类别上的预测差异来实现。</p><p>对于每一个新类别的学习，模型的总损失函数为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mo>=</mo><msub><mi>L</mi><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">w</mi></mrow></msub><mo>+</mo><mi>λ</mi><mo>⋅</mo><msub><mi>L</mi><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L=L_\mathrm{new}+\lambda\cdot L_\mathrm{distill}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight" style="margin-right:0.01389em;">new</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">distill</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_\mathrm{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight" style="margin-right:0.01389em;">new</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是针对新类别的标准交叉熵损失，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_\mathrm{distill}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">distill</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是针对旧类别知识的蒸馏损失，λ 是平衡这两者的系数。</p><p>通过知识蒸馏，模型可以有效保持旧模型对旧类别的识别能力，在学习新类的同时保留旧类的特性，可以很好地缓解由于安全性或存储问题使得数据对模型不可见导致的灾难性遗忘问题。</p><h3 id="4-2-2-合成数据增强">4.2.2 <strong>合成数据增强</strong></h3><p>合成数据增强通过生成与新类别相关的合成样本来解决<strong>类别不平衡和少样本学习问题</strong>。通过LSTM生成式模型生成与新类别相关的未标注上下文或样本，将这些合成数据添加到训练集中，使得模型能够接触到更多的新类别样本，从而平衡新旧类别的数据分布。这种方法类比于人类在理解新知识时，构建假设场景进行模拟学习，从而提升记忆和理解能力。</p><p>本文我们训练一个LSTM生成模型，旨在生成与新类别相关的未标注上下文或样本。通过训练LSTM模型，我们能够捕捉到数据集中的潜在模式，从而生成符合原始数据分布的合成文本。这些文本中包含与新类别相关的实体。而后将这些合成样本与真实标注数据和伪标签数据结合，形成增强后的训练集。最后使用包含合成数据的训练集，进一步训练当前模型，提高模型对新类别的适应能力。</p><p>首先，使用原始数据集进行LSTM模型的训练。通过大量的历史上下文数据，LSTM能够学习到不同实体类别的特征和相互关系。训练完成后，LSTM模型能够生成与新类别相关的文本。这些合成文本将包含新类别的实体，从而扩展模型的训练样本。</p><p>通过LSTM模型生成的未标注数据：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>D</mi><mtext>synthetic</mtext></msub><mo>=</mo><mo stretchy="false">{</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mtext>synthetic</mtext></msub><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">D_{\text{synthetic}}=\{(x_{\text{synthetic}})\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">synthetic</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">{(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">synthetic</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)}</span></span></span></span></span></p><p>在生成合成样本后，我们将这些合成数据与真实标注数据和伪标签数据结合，形成增强后的训练集：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>D</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><msub><mi>D</mi><mtext>labeled</mtext></msub><mo>∪</mo><msub><mi>D</mi><mtext>synthetic</mtext></msub></mrow><annotation encoding="application/x-tex">D^{\prime}=D_\text{labeled}\cup D_\text{synthetic}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8019em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">labeled</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">synthetic</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mtext>labeled</mtext></msub></mrow><annotation encoding="application/x-tex">D_\text{labeled}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">labeled</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是真实标注数据集,$ D_\text{synthetic}$是生成的文本数据。</p><p>针对类别不平衡问题，合成数据增强通过生成更多的新类别样本，有效缓解了类别不平衡的问题。新类别的合成样本数量显著增加，使得模型在训练时不至于过于偏向于旧类别，确保每个类别都能得到足够的关注，这种平衡的训练数据分布促使模型能够更好地学习新类别的特征，提升对各类别的识别能力。</p><p>针对少样本学习问题，合成数据的生成为新类别提供了额外的样本支持。即使在标注数据稀缺的情况下，生成的合成样本依然能够帮助模型学习到新类别的有效特征。通过构建与新类别相关的上下文数据，模型能够在数据不足的情况下进行更充分的学习，提升对新类别的识别能力。这一过程类似于人类在理解新知识时，通过构建假设场景进行模拟学习，从而增强记忆和理解能力。</p><h3 id="4-2-3-标签解释学习">4.2.3 标签解释学习</h3><p>少样本命名实体识别通过学习样本中被标注的实体来训练模型，标签解释学习在于充分利用每个实体的标签信息，把传统模型应用的标签（如“PER”）进行解释扩充，通过学习和解释实体类型的自然语言描述（即标签的描述信息），在只有少量标注数据的情况下提高NER模型的泛化能力和性能。</p><p>首先，模型通过学习现有实体类型的自然语言描述来掌握如何识别和分类文本中的命名实体。具体来说，模型在一个NER标注数据集上进行训练，该数据集中包括了一组实体类型及其对应的描述。例如，“PER”标签可能对应描述为“person entity”，“船”标签可能对应描述为“水面上移动的交通工具”。模型通过这些描述来建立标签与其含义之间的关联，从而学会识别和分类这些实体类型。</p><p>然后，将模型应用于新的、未见过的实体类型。通过提供新的实体类型描述和少量标注示例，模型能够在少样本条件下执行NER任务。在此阶段，模型可以利用先前学到的标签解释知识，将新的实体类型描述映射到相应的NER任务中。这一过程允许模型在未见过的领域或实体类型上快速适应并进行命名实体识别。</p><p>通过增加标签解释学习阶段中实体类型的多样性和描述的详细程度，能够显著提升模型在少样本条件下的NER性能，尤其是在未见过的领域和跨语言环境中。通过这种数据驱动的启发式优化，模型在少样本NER任务中的表现得到了显著改善。</p><h3 id="4-2-4-伪标签生成">4.2.4 <strong>伪标签生成</strong></h3><p>伪标签生成通过预测未标注数据中的实体类别并为其生成伪标签，扩大数据集规模。模型会使用前一阶段训练好的模型来预测新类别数据的伪标签，并将这些伪标签数据与少量标注数据混合，作为当前阶段的训练集。这种方法特别适用于少样本或零样本的场景，类似于人类通过联想和推理进行推测，伪标签生成为模型提供了额外的数据资源，扩展了训练集规模。</p><p>针对新类别的少量标注数据，首先使用前一阶段的模型$ M_{k-1}$预测未标注数据中的潜在实体，并生成伪标签。给定输入数据 x，模型预测的伪标签 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>y</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span> 表示为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>D</mi><mrow><mi mathvariant="normal">p</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">o</mi></mrow></msub><mo>=</mo><mo stretchy="false">{</mo><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mover accent="true"><mi>y</mi><mo>^</mo></mover><mo stretchy="false">)</mo><mo>∣</mo><mover accent="true"><mi>y</mi><mo>^</mo></mover><mo>=</mo><msub><mi>M</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">D_{\mathrm{pseudo}}=\{(x,\hat{y})\mid\hat{y}=M_{k-1}(x)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">pseudo</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)}</span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mtext>pseudo</mtext></msub></mrow><annotation encoding="application/x-tex">D_\text{pseudo}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">pseudo</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>是伪标签数据，包含了未标注样本及其对应的伪标签。</p><p>而后将伪标签数据与真实标注数据结合，形成增强版的训练集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>D</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup></mrow><annotation encoding="application/x-tex">D^{\prime\prime}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′′</span></span></span></span></span></span></span></span></span></span></span></span>。训练模型时，使用伪标签扩展数据集，结合标注数据集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mtext>labeled</mtext></msub></mrow><annotation encoding="application/x-tex">D_\text{labeled}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">labeled</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>升模型对新类别的识别能力。构建增强后的数据集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>D</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup></mrow><annotation encoding="application/x-tex">D^{\prime\prime}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′′</span></span></span></span></span></span></span></span></span></span></span></span>:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>D</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo>=</mo><msub><mi>D</mi><mtext>labeled</mtext></msub><mo>∪</mo><msub><mi>D</mi><mtext>pseudo</mtext></msub></mrow><annotation encoding="application/x-tex">D^{\prime\prime}=D_{\text{labeled}}\cup D_{\text{pseudo}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8019em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">labeled</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">pseudo</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>使用增强后数据集训练新的模型 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">M_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，使得模型能够接触到新类别的多种表示方式。</p><p>在训练过程中，损失函数应同时考虑真实标注数据和伪标签数据的贡献。损失函数为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mo>=</mo><msub><mi>L</mi><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">d</mi></mrow></msub><mo>+</mo><mi>α</mi><msub><mi>L</mi><mrow><mi mathvariant="normal">p</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">o</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L=L_{\mathrm{labeled}}+\alpha L_{\mathrm{pseudo}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">labeled</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">pseudo</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_{\mathrm{labeled}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">labeled</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是针对真实标注数据的损失，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mrow><mi mathvariant="normal">p</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">o</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_{\mathrm{pseudo}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">pseudo</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>是针对伪标签数据的损失,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>为超参数，确保模型不仅从标注数据中学习，还能从生成的伪标签中获取有价值的信息。</p><p>伪标签生成通过生成额外的伪标注数据，极大扩展了可供训练的数据集，帮助模型在数据稀缺的情况下学习新类别的特征。这种方法使得即使在少量标注样本的情况下，模型也能获得更多的训练数据，提升对新类别的识别能力。同时有效填补了数据集中未标注部分，确保模型在学习新类别时能够更全面地学习到不同的特征。这种填补使得模型可以在有限的标注数据下，更好地捕捉新类别的多样性。</p><h3 id="4-2-5-学习与回顾">4.2.5 <strong>学习与回顾</strong></h3><p>L&amp;R策略通过模仿人类的复习过程，基于<strong>回顾旧知识</strong>的增量学习策略。在每一阶段的学习过程中，模型不仅学习新类别的数据，通过定期回顾旧类别的数据或知识进行“复习”。这种策略通过在回顾阶段使用合成数据和伪标签数据，帮助模型保持对旧类别的记忆，确保模型在引入新类别时仍然能够正确识别旧类别。在本文中，L&amp;R策略与知识蒸馏、伪标签生成和合成数据增强相结合，提升了模型对新类别和旧类别的适应能力。</p><p>模型训练可以分为两个阶段：</p><p>1.<strong>学习阶段</strong>：模型首先在当前阶段的新类别数据上进行训练，并通过知识蒸馏学习旧类别的知识。训练目标是使模型尽可能准确地学习新类别，并通过引入<strong>蒸馏损失函数</strong>来保持对旧类别的记忆。</p><p>学习阶段的损失函数为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>L</mi><mrow><mi mathvariant="normal">t</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi></mrow></msub><mo>=</mo><msub><mi>L</mi><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">w</mi></mrow></msub><mo>+</mo><mi>λ</mi><mo>⋅</mo><msub><mi>L</mi><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_\mathrm{total}=L_\mathrm{new}+\lambda\cdot L_\mathrm{distill}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">total</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight" style="margin-right:0.01389em;">new</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">distill</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_\mathrm{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight" style="margin-right:0.01389em;">new</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示新类别的交叉熵损失，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_\mathrm{distill}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">distill</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示旧模型（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">M_{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>）与当前模型（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">M_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）之间的蒸馏损失，λ是平衡新知识学习与旧知识保留的权重。</p><p>2.<strong>回顾阶段</strong>：在学习完新类别后，L&amp;R策略通过合成数据增强和伪标签生成，构建一个更为丰富的训练集，帮助模型复习旧类别的知识。</p><p>增强的数据集包括两部分：合成数据和伪标签数据。通过LSTM生成模型生成的未标注上下文合成数据，使得模型在接触到新类别的同时，也能重新接触到旧类别的上下文信息。同时使用现有模型预测的未标注数据，生成带有伪标签的旧类别数据，扩大旧类别数据集规模。</p><p>回顾阶段的损失函数为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>L</mi><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">w</mi></mrow></msub><mo>=</mo><msub><mi>L</mi><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">d</mi></mrow></msub><mo>+</mo><mi>α</mi><mo>⋅</mo><msub><mi>L</mi><mtext>distill-old</mtext></msub></mrow><annotation encoding="application/x-tex">L_{\mathrm{review}}=L_{\mathrm{augmented}}+\alpha\cdot L_{\text{distill-old}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3175em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight" style="margin-right:0.01389em;">review</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">augmented</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">distill-old</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mtext>augmented</mtext></msub></mrow><annotation encoding="application/x-tex">L_{\text{augmented}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">augmented</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>在增强数据集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>D</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup></mrow><annotation encoding="application/x-tex">D^{\prime\prime}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′′</span></span></span></span></span></span></span></span></span></span></span></span>上计算的损失，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mtext>distill-old</mtext></msub></mrow><annotation encoding="application/x-tex">L_{\text{distill-old}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">distill-old</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是基于旧类别的蒸馏损失，α是权衡回顾损失和蒸馏损失的超参数。</p><p>通过回顾旧知识，模拟人类的学习行为，不仅依赖于知识蒸馏，还通过直接复习旧类别的数据，主动学习强化对旧类别的记忆，并减少新类别学习过程中旧知识的丢失。</p><h2 id="4-3-创新点">4.3 <strong>创新点</strong></h2><p>本文的方法设计通过模拟人脑的学习机制，主要从两方面解决类增量NER中的主要问题，设计思路和创新点包括：</p><ol><li><strong>从不同角度缓解灾难性遗忘</strong>：</li></ol><ul><li><strong>知识蒸馏</strong>通过传递旧类别的知识，有效防止新知识覆盖旧知识，确保模型在学习新类别时，不会遗忘旧类别。</li><li><strong>L&amp;R策略</strong>通过复习旧类别知识，进一步强化模型对旧类别的记忆，避免模型在增量学习过程中丧失对旧类别的识别能力。</li></ul><ol start="2"><li><strong>提升少样本学习的泛化能力</strong>：</li></ol><ul><li><strong>伪标签生成</strong>通过在少样本条件下生成伪标注数据，扩展了新类别的数据集，帮助模型在标注数据不足的情况下，提升对新类别的学习效果。</li><li><strong>合成数据增强</strong>则通过生成更多的合成样本，有效缓解了类别不平衡和少样本问题，使模型能够接触到更多的训练数据，提升对新类别的泛化能力。</li></ul><p>本文的<strong>创新点</strong>在于通过结合多种策略，模拟人类的学习与记忆机制，提出了一种适用于少样本场景下的类增量NER解决方案，有效缓解了类增量NER中的灾难性遗忘和少样本问题。相比于传统方法，我们的综合训练方法在少样本和零样本条件下表现更为优越，不仅从理论上提升了模型对新旧类别的平衡能力，在实践中也展现出较强的适应性，能够在数据稀缺的情况下保持对新类别的良好学习效果，解决了实际应用中常见的数据稀缺和标签不完整的问题，具有重要的实践价值。</p><h1>5.实验设计</h1><h2 id="5-1实验设置">5.1实验设置</h2><p>遵循之前 NER 类增量学习的工作 （Monaikul et al.， 2021），为了适应中国的情况，我们选择中国军事数据集作为我们的实验数据集。此数据集包含 6 个实体类，我们随机选择 5 个实体类的顺序来执行实验。表 1 显示了每个步骤使用的实体类。</p><h2 id="5-2-方法比较">5.2 方法比较</h2><p>我们使用基于知识的蒸馏方法作为基线。此方法通过从前一个模型![img](file:///C:/WINDOWS/TEMP/msohtmlclip1/01/clip_image002.png)中提取当前模型   来训练当前模型     ，其中包含新的实体   。此外，我们还实现了数据扩充，这是一种使用合成数据来丰富数据集的方法。基于此，我们使用学习和复习方法来训练模型。我们还采用伪标记方法，在包含这些合成标签的数据集上训练我们的模型。</p><table><thead><tr><th>Sequence</th></tr></thead><tbody><tr><td>S1:    1 -&gt; 2 -&gt; 3  -&gt; 4 -&gt; 5 -&gt; 6  <br />S2:    2 -&gt; 4 -&gt; 6  -&gt; 1 -&gt; 3 -&gt; 5  <br />S3:    6 -&gt; 2 -&gt; 1  -&gt; 5 -&gt; 4 -&gt; 3  <br />S4:    3 -&gt; 6 -&gt; 5  -&gt; 2 -&gt; 4 -&gt; 1 <br />S5:    5 -&gt; 6 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> NER </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NER </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年国赛B题——基于成本效益分析的生产决策模型</title>
      <link href="/2024/09/12/shumo/24%E5%9B%BD%E8%B5%9B/"/>
      <url>/2024/09/12/shumo/24%E5%9B%BD%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p>24年国赛B题</p><p>这道题看起来比较简单实际上不太好做，难点在于决策模型的构建，这里给大家一点参考。</p><p>牵扯到概率论与数理统计以及排列组合，时间复杂度较高，会难以模拟，若简化问题会导致结果不够精确，有舍有得，要把握好度。感谢靠谱的队友~</p><p><img src="https://pic.imgdb.cn/item/66e30c91d9c307b7e96961e3.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30c91d9c307b7e969621b.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30c94d9c307b7e96966e7.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30c94d9c307b7e969670e.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30c94d9c307b7e96966c9.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30d1fd9c307b7e96a2dab.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30d1fd9c307b7e96a2de3.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30d20d9c307b7e96a2e2c.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30d20d9c307b7e96a2e72.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30d1fd9c307b7e96a2d7f.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30d7bd9c307b7e96aa55d.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30d7bd9c307b7e96aa585.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30d7cd9c307b7e96aa756.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30d7cd9c307b7e96aa77e.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30d7ad9c307b7e96aa454.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30dbed9c307b7e96b039d.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30dbed9c307b7e96b03c7.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30dbed9c307b7e96b0404.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30dbed9c307b7e96b0429.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30dbdd9c307b7e96b037c.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30deed9c307b7e96b4a56.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30deed9c307b7e96b4a9e.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30defd9c307b7e96b4ac9.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30defd9c307b7e96b4b01.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30deed9c307b7e96b4a32.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30e11d9c307b7e96b7520.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30e11d9c307b7e96b7550.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30e11d9c307b7e96b7577.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30e11d9c307b7e96b759d.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30e10d9c307b7e96b74c8.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30e36d9c307b7e96baaeb.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30e36d9c307b7e96bab14.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30e36d9c307b7e96bab3c.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30e37d9c307b7e96bab5c.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/66e30e36d9c307b7e96baac0.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数模 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图论</title>
      <link href="/2024/08/16/shuju/%E5%9B%BE%E8%AE%BA/"/>
      <url>/2024/08/16/shuju/%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>稠密图用邻接矩阵存，稀疏图用邻接表存</p><h1>DFS</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建边</span></span><br><span class="line"><span class="comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几个要素：图中的值，各数组下标，边的编号</p><p><code>h[i]</code>:i是图中的值a，h[i]是这个值在e[i]中的下标i</p><p><code>e[i]</code>:i是数组下标，e[i]是图中的值b，由此实现了a-&gt;b</p><p><code>ne[i]</code>:i是数组下标,ne[i]是e[i]对应的下一个数组下标</p><p>嗯……要好好理解</p><h1>BFS</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用：</p><ul><li><p>拓扑排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])</span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://www.acwing.com/problem/content/847/">ACWing845. 八数码</a></p><p>有状态转移思想应用（妙啊）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(string start)</span></span>&#123;</span><br><span class="line">    string end = <span class="string">&quot;12345678x&quot;</span>;<span class="comment">//定义目标状态</span></span><br><span class="line">    queue&lt;string&gt; q;</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; d;<span class="comment">//O(1)</span></span><br><span class="line">    </span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    d[start] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> dis = d[t];</span><br><span class="line">        <span class="keyword">if</span>(t == end) <span class="keyword">return</span> dis;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> k = t.<span class="built_in">find</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> x = k / <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> y = k % <span class="number">3</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a = x + dx[i],b = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(a &gt;= <span class="number">0</span> &amp;&amp; a&lt;<span class="number">3</span> &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(t[k],t[a*<span class="number">3</span> + b]);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(!d.<span class="built_in">count</span>(t))&#123;</span><br><span class="line">                    d[t] = dis + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">swap</span>(t[k],t[a*<span class="number">3</span> + b]);<span class="comment">//还原状态</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1>朴素dijkstra算法</h1><ol><li><p>初始化距离</p><p>dis[1] = 0，dis[i] = +∞</p></li><li><p>找到当前已经确定最短距离的点，s:当前已经确定最短距离的点</p><p>for(i:1~n)</p><p>t:不在s中的，距离最近的点</p><p>t-&gt;s</p><p>更新距离</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijsktra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;=n;j++)&#123;<span class="comment">//找到这一轮距离最近的点</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))&#123;</span><br><span class="line">                t = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;<span class="comment">//更新这个点和其他所有点的距离</span></span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j],dist[t] + g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt;= <span class="number">10010</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>堆优化</h1><ol><li><p>初始化距离</p><p>dis[1] = 0，dis[i] = +∞</p></li><li><p>找到当前已经确定最短距离的点，s:当前已经确定最短距离的点</p><p>t:不在s中的，距离最近的点</p><p>t-&gt;s（m条边）</p><p>更新距离（堆更新一次是O(logn)）</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    ne[idx] = h[a];<span class="comment">//存的是h[a]之前的数的idx,这样可以访问到所有a-&gt;x的边</span></span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;<span class="comment">//默认的是按照pair的第一个元素进行排序</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);<span class="comment">// 可以简写成 q.emplace(x, y)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ver = t.second,distance = t.first;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])&#123;<span class="comment">//找到和ver相连的边的最小的那一条</span></span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[ver] + w[i])&#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt;= <span class="number">1000000010</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Bellman-Flord</h1><ol><li><p>建结构体a,b,w</p></li><li><p>for n次（迭代k次：从1号点经过不超过k条边到每个点的最短路的距离，若一次迭代没有点更新可直接结束）</p><p>​for 所有边a,b,w</p><p>​更新距离(松弛)</p></li></ol><blockquote><p>一定满足<code>dis[b] &lt;= dis[a] + w</code></p><p>如果有负权回路——一圈长度和小于0，就不一定有结果；若第n次还在迭代的话就有负环（一般用SPFA找）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(last, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = edges[j];</span><br><span class="line">            dist[e.b] = <span class="built_in">min</span>(dist[e.b], last[e.a] + e.c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>串联：由于这个算法的特性决定，每次更新得到的必然是在多考虑 1 条边之后能得到的全局的最短路。</p><p>而串联指的是一次更新之后考虑了不止一条边：由于使用了松弛，某节点的当前最短路依赖于其所有入度的节点的最短路；</p><p>假如在代码中使用dist[e.b]=min(dist[e.b],dist[e.a] + e.c);，我们无法保证dist[e.a]是否也在本次循环中被更新，如果被更新了，并且dist[e.b] &gt; dist[e.a] + e.c，那么会造成当前节点在事实上**“即考虑了一条从某个节点指向a的边，也考虑了a-&gt;b”，共两条边。**</p><p>而使用dist[e.b]=min(dist[e.b],last[e.a] + e.c);，可以保证a在dist更新后不影响对b的判定，因为后者使用last数组，保存着上一次循环中的dist的值。</p><h1>SPFA</h1><p>要求没有负环</p><p>第一个点入队</p><p>while queue不空</p><p>​t &lt;- q.front;q.pop();</p><p>​更新t的所有出边（t-&gt;b）</p><p>​queue&lt;-b;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    <span class="comment">//队列里都是由起点更新到的点，不存在bellman-ford算法中未更新的点同样被边更新的情况。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;<span class="comment">//曾经加入过队列的点出队后，会再次被加入队列继续更新与它联通的点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                <span class="comment">//前面假如出现了可以把二这个点变小的值，那就更新，但不用加入队列</span></span><br><span class="line">                <span class="comment">//因为队列里已经有二这个点了，他肯定会遍历到，然后去更新与他相邻的节点之间的距离，</span></span><br><span class="line">                <span class="comment">//这样就提高了效率，而被淘汰的点之后又会被加入队列是因为此时他的最短距离又被更新了，</span></span><br><span class="line">                <span class="comment">//那么自然和他相连的节点距离也会更新，所以需要把他重新加入队列之中</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断负环">判断负环</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], w[M], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];<span class="comment">//dist严格意义说不是用来存最短距离的。所以dist中元素初始值并不是那么重要。我们就拿dist中元素全部初始化为0来举例分析一下，如果图中全部是正权重，那么if就压根不会执行。cnt也不会更新。如果图中全是负权重，但没有负环，其实就跟求最短路比较类似了，但dist存的也不完全是源点1到各个点的最短距离，这里有这么两种情况(比如1-&gt;2,1-&gt;3,2-&gt;3,这时dist中元素就代表了源点1到各点的最短距离，因为如果这样，2,3开始不入队迟早也会入队，这样就退化成了，只开始入队1，其他点不入队的情况，算的是1到各点的最短距离。另外一种是可能存在1-&gt;3,2-&gt;3,1到不了2，这样此时dist[3]，就代表了1,2分别为起点到3的最短距离。如果存在连通分支的情况其实就是前面两个情况的结合。)第一种情况很显然就跟单源最短路一样，不存在负环的前提下最短路径的长度也就是n-1，一旦大于等于n就说明有负环。第二种情况可以把例如3这个点分别看成以1为源点，以2为源点求最短路。此时cnt代表的就是两个求最短路的过程中dist的更新次数。如果有n个点，1-&gt;n,但到不了2,2-&gt;n，但1可以到其他所有点，这样就变成以1为源点和以2为源点最短路，以1的角度看就是n-1个点的最短路，在这个最短路中cnt最多达到n-2，同样2-&gt;n最短路中cnt最多是1，相加也最对是n-1。类似的分析，如果1到不了很多点，可以看成多个最短路，在每个最短路中看cnt最大值，综合所有cnt更新会发现cnt最大也就是n-1(在没有负回路的前提下)有不同联通分支分析与第二种情况分析类似。</span></span><br><span class="line"><span class="comment">//如果既有负权重，又有正权重，对于dist全初始为0的情况来说，正权重其实就起不到作用，这里可以认为正权重的边不存在。把正权重的边删掉后，就又变成了全部是负权重的情况。回到了上面的分析。综上，如果回路中不存在负回路，那么cnt最多也就是n-1，只有存在负权重，cnt才会大于等于n</span></span><br><span class="line"><span class="comment">//所以结合上述分析，我们可以知道cnt[j]各个起源点到j点的最短长度的和</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;<span class="comment">//这里是因为如果和正常的spfa一样的话，只能判断从源点1可以到达所有的点的路径中有没有负环。但如果源点有到不了的点，比如不在一个联通分支，这样就会有点不会入队，这样就没法判断这个点到其他点的路径中是否存在负环，即也无法判断图中是否有负环，所以开始让所有点都入队</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Floyd</h1><p>for(k =1;k&lt;=n;k++)</p><p>​for(i =1;i&lt;=n;i++)</p><p>​for(j =1;j&lt;=n;j++)</p><p>​d[i,j] = min(d[i,j],d[i,k] + d[k,j]);</p><p>d[i,j]存的就是最短路长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>拓扑排序</h1><p><strong>找到图中入度为 0 的节点，以及仅由入度为 0 节点所指向的节点</strong>。</p><p>LC802</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">eventualSafeNodes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 反图，邻接表存储</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">new_graph</span>(n);</span><br><span class="line">        <span class="comment">// 节点入度</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Indeg</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x : graph[i]) &#123;</span><br><span class="line">                new_graph[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 原数组记录的节点出度，在反图中就是入度</span></span><br><span class="line">            Indeg[i] = graph[i].<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓扑排序</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先将入度为 0 的点存入队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!Indeg[i]) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 每次弹出队头元素</span></span><br><span class="line">            <span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x : new_graph[cur]) &#123;</span><br><span class="line">                <span class="comment">// 将以其为起点的有向边删除，更新终点入度</span></span><br><span class="line">                Indeg[x]--;</span><br><span class="line">                <span class="keyword">if</span>(!Indeg[x]) q.<span class="built_in">push</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终入度（原图中出度）为 0 的所有点均为安全点</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!Indeg[i]) ret.push_back;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>最短路问题</h1><p><img src="https://pic.imgdb.cn/item/67000da9d29ded1a8c22d14c.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现横向联邦学习</title>
      <link href="/2024/08/15/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/08/15/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>实现横向联邦学习</h1><p>横向联邦学习的服务端的主要功能是将被选择的客户端上传的本地模型进行模型聚合。</p><p>首先定义一个服务端类Server，类中的主要函数包括以下几个。</p><ul><li><p>定义构造函数。</p><p>在构造函数中，服务端的工作包括：</p><p>第一，将配置信息拷贝到服务端中；</p><p>第二，按照配置中的模型信息获取模型，使用torchvision 的models模块内置的ResNet-18模型。</p></li><li><p>定义模型聚合函数。</p><p>服务端的主要功能是进行模型的聚合，通过接收客户端上传的模型，使用聚合函数更新全局模型。采用经典的FedAvg 算法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">model_aggregate</span>(<span class="params">self, weight_accumulator</span>):</span><br><span class="line"><span class="keyword">for</span> name, data <span class="keyword">in</span> self.global_model.state_dict().items():</span><br><span class="line">update_per_layer = weight_accumulator[name] * self.conf[<span class="string">&quot;lambda&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> data.<span class="built_in">type</span>() != update_per_layer.<span class="built_in">type</span>():</span><br><span class="line">data.add_(update_per_layer.to(torch.int64))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">data.add_(update_per_layer)</span><br></pre></td></tr></table></figure></li><li><p>定义模型评估函数。</p><p>评估当前的全局模型性能。</p></li></ul><h2 id="客户端">客户端</h2><p>横向联邦学习的客户端主要功能是接收服务端的下发指令和全局模型，利用本地数据进行局部模型训练。定义客户端类Client，类中的主要函数包括以下两种。</p><ul><li><p>定义构造函数。</p><p>在客户端构造函数中，客户端的主要工作包括</p><p>1.将配置信息拷贝到客户端中；</p><p>2.按照配置中的模型信息获取模型，通常由服务端将模型参数传递给客户端，客户端将该全局模型覆盖掉本地模型；</p><p>3.配置本地训练数据，通过torchvision 的datasets 模块获取cifar10 数据集后按客户端ID切分，不同的客户端拥有不同的子数据集，相互之间没有交集。</p></li><li><p>定义模型本地训练函数。</p><p>这是一个图像分类的任务，使用交叉熵作为本地模型的损失函数，利用梯度下降来求解并更新参数值，实现细节如下面代码块所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">local_train</span>(<span class="params">self, model</span>):</span><br><span class="line"><span class="keyword">for</span> name, param <span class="keyword">in</span> model.state_dict().items():</span><br><span class="line">self.local_model.state_dict()[name].copy_(param.clone())</span><br><span class="line">optimizer = torch.optim.SGD(self.local_model.parameters(), lr=self.conf[<span class="string">&#x27;lr&#x27;</span>],</span><br><span class="line">momentum=self.conf[<span class="string">&#x27;momentum&#x27;</span>])</span><br><span class="line">self.local_model.train()</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(self.conf[<span class="string">&quot;local_epochs&quot;</span>]):</span><br><span class="line"><span class="keyword">for</span> batch_id, batch <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.train_loader):</span><br><span class="line">data, target = batch</span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">data = data.cuda()</span><br><span class="line">target = target.cuda()</span><br><span class="line">optimizer.zero_grad()</span><br><span class="line">output = self.local_model(data)</span><br><span class="line">loss = torch.nn.functional.cross_entropy(output, target)</span><br><span class="line">loss.backward()</span><br><span class="line">optimizer.step()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Epoch %d done.&quot;</span> % e)</span><br><span class="line">        </span><br><span class="line">diff = <span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> name, data <span class="keyword">in</span> self.local_model.state_dict().items():</span><br><span class="line">diff[name] = (data - model.state_dict()[name])</span><br><span class="line"><span class="keyword">return</span> diff</span><br></pre></td></tr></table></figure></li></ul><h2 id="整合">整合</h2><p>当配置文件、服务端类和客户端类都定义完毕，我们将这些信息组合起来。</p><p>首先，读取配置文件信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(args.conf, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">conf = json.load(f)</span><br></pre></td></tr></table></figure><p>分别定义一个服务端对象和多个客户端对象，用来模拟横向联邦训练场景。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">train_datasets, eval_datasets = datasets.get_dataset(<span class="string">&quot;./data/&quot;</span>, conf[<span class="string">&quot;type&quot;</span>])</span><br><span class="line">server = Server(conf, eval_datasets)</span><br><span class="line">clients = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(conf[<span class="string">&quot;no_models&quot;</span>]):</span><br><span class="line">clients.append(Client(conf, server.global_model, train_datasets, c))</span><br></pre></td></tr></table></figure><p>每一轮的迭代，服务端会从当前的客户端集合中随机挑选一部分参与本轮迭代训练，被选中的客户端调用本地训练接口local_train进行本地训练，最后服务端调用模型聚合函数model_aggregate来更新全局模型。</p><h2 id="配置信息">配置信息</h2><ul><li>model_name：模型名称</li><li>no_models：客户端数量</li><li>type：数据集信息</li><li>global_epochs：全局迭代次数，即服务端与客户端的通信迭代次数</li><li>local_epochs：本地模型训练迭代次数</li><li>k：每一轮迭代时，服务端会从所有客户端中挑选k个客户端参与训练。</li><li>batch_size：本地训练每一轮的样本数</li><li>lr，momentum，lambda：本地训练的超参数设置</li></ul><h2 id="联邦学习与中心化训练的效果对比">联邦学习与中心化训练的效果对比</h2><p><img src="https://pic.imgdb.cn/item/66bdc36ad9c307b7e949ed6b.jpg" alt="联邦学习与中心化训练的效果对比"></p><ul><li>联邦训练配置：一共10台客户端设备（no_models=10），每一轮任意挑选其中的5台参与训练（k=5）， 每一次本地训练迭代次数为3次（local_epochs=3），全局迭代次数为20次（global_epochs=20）。</li><li>集中式训练配置：我们不需要单独编写集中式训练代码，只需要修改联邦学习配置既可使其等价于集中式训练。具体来说，我们将客户端设备no_models和每一轮挑选的参与训练设备数k都设为1即可。这样只有1台设备参与的联邦训练等价于集中式训练。其余参数配置信息与联邦学习训练一致。图中我们将局部迭代次数分别设置了1，2，3来进行比较。</li></ul><h2 id="3-7-联邦学习在模型推断上的效果对比">3.7 联邦学习在模型推断上的效果对比</h2><p>单点训练只的是在某一个客户端下，利用本地的数据进行模型训练的结果。</p><p><img src="https://pic.imgdb.cn/item/66bdc36bd9c307b7e949eed2.jpg" alt="模型推断上的效果对比"></p><p>我们看到单点训练的模型效果（蓝色条）明显要低于联邦训练 的效果（绿色条和红色条），这也说明了仅仅通过单个客户端的数据，不能够 很好的学习到数据的全局分布特性，模型的泛化能力较差。</p><p>此外，对于每一轮 参与联邦训练的客户端数目（k 值）不同，其性能也会有一定的差别，k 值越大，每一轮参与训练的客户端数目越多，其性能也会越好，但每一轮的完成时间也会相对较长。</p><p>运行原作者代码结果如下：</p><p><img src="https://pic.imgdb.cn/item/66bdc36ad9c307b7e949eddd.jpg" alt="运行结果"></p><p>尝试增大local_epochs,lr,batch_size,单独增加batch_size训练速度会有所提升，发现总体速率和原始保持一致，效果有明显提升：</p><p><img src="https://pic.imgdb.cn/item/66bdc36ad9c307b7e949edb4.jpg" alt="调整后效果"></p><h2 id="参考文献及代码">参考文献及代码</h2><p>1.<a href="https://github.com/FederatedAI/Practicing-Federated-Learning/tree/main/chapter03_Python_image_classification">用Python从零实现横向联邦图像分类</a></p><p>2.<a href="chrome-extension://efaidnbmnnnibpcajpcglclefindmkaj/https://proceedings.mlr.press/v54/mcmahan17a/mcmahan17a.pdf">Communication-Efficient Learning of Deep Networks from Decentralized Data</a></p><p>3.<a href="https://github.com/shaoxiongji/federated-learning">Communication-Efficient Learning of Deep Networks from Decentralized Data(代码)</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java核心技术卷Ⅰ</title>
      <link href="/2024/08/01/JAVA/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0/"/>
      <url>/2024/08/01/JAVA/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0/</url>
      
        <content type="html"><![CDATA[<h1>对象与类</h1><h2 id="面向对象程序设计概述">面向对象程序设计概述</h2><p>创建实例：类构建对象的过程</p><p>实例字段：对象中的数据；实例字段的值的集合称为状态</p><p>方法：操作数据的过程</p><h3 id="行为、状态、标识">行为、状态、标识</h3><p><img src="https://pic.imgdb.cn/item/66c2dbcdd9c307b7e99ffa0e.png" alt=""></p><h3 id="类之间的关系">类之间的关系</h3><ul><li>依赖</li><li>聚合</li><li>继承</li></ul><h2 id="使用预定义类">使用预定义类</h2><h3 id="对象与对象变量">对象与对象变量</h3><p>使用构造器（constructor）构造新实例，构造器的名字应该与类名相同。</p><blockquote><p>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。</p></blockquote><p>局部变量不会自动地初始化为null，而必须通过调用new或将它们设置为null进初始化。</p><h3 id="更改器方法与访问器方法">更改器方法与访问器方法</h3><p>只访问对象而不修改对象的方法有时称为访问器方法（accessor method）例如，LocalDate.getYear和GregorianCalendar.get。</p><p>GregorianCalendar.add方法是一个更改器方法（mutator method）。调用这个方法后，someDay对象的状态会改变。</p><h2 id="自定义类">自定义类</h2><h3 id="Employee类">Employee类</h3><p>文件名必须与public类的名字相匹配。在一个源文件中，只能有一个公有类，但可以有任意数目的非公有类。</p><p>类通常包含类类型的实例字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure><h3 id="构造器">构造器</h3><p>构造器与类同名，总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String n, <span class="type">double</span> s, <span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span><br><span class="line">   &#123;</span><br><span class="line">      name = n;</span><br><span class="line">      salary = s;</span><br><span class="line">      hireDay = LocalDate.of(year, month, day);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">staff[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Carl Cracker&quot;</span>, <span class="number">75000</span>, <span class="number">1987</span>, <span class="number">12</span>, <span class="number">15</span>);<span class="comment">//正确</span></span><br><span class="line">james.Employee(<span class="string">&quot;Carl Cracker&quot;</span>, <span class="number">75000</span>, <span class="number">1987</span>, <span class="number">12</span>, <span class="number">15</span>);<span class="comment">//错误</span></span><br></pre></td></tr></table></figure><ul><li>构造器与类同名</li><li>每个类可以有一个以上的构造器</li><li>构造器可以有0个、1个或多个参数</li><li>构造器没有返回值</li><li>构造器总是伴随着new操作一起调用</li><li>所有的Java对象都是在堆中构造的</li><li>不要在构造器中定义与实例域重名的局部变量。这些变量只能在构造器内部访问。这些变量屏蔽了同名的实例域。</li></ul><p><strong>var关键字声明局部变量：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">harry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Carl Cracker&quot;</span>, <span class="number">75000</span>, <span class="number">1987</span>, <span class="number">12</span>, <span class="number">15</span>);</span><br></pre></td></tr></table></figure><p>只能用于方法中的局部变量，参数和字段的类型必须声明。</p><p><strong>使用null引用：</strong></p><p>null值应用一个方法，产生NullPointException异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">rightNow</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> rightNow.toString();<span class="comment">//NullPointException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决中断情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String n,<span class="type">double</span> s,<span class="type">int</span> year,<span class="type">int</span> monh,<span class="type">int</span> day)</span>&#123;</span><br><span class="line">    name = Object.requireNonNulElse(n,<span class="string">&quot;unknown&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="隐式参数与显式参数">隐式参数与显式参数</h3><p>第一个参数称为隐式（implicit）参数，是出现在方法名前的Employee类对象。第二个参数位于方法名后面括号中的数值，这是一个显式（explicit）参数。在每一个方法中，关键字this表示隐式参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">raiseSalary</span><span class="params">(<span class="type">double</span> byPercent)</span>&#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">raise</span> <span class="operator">=</span> <span class="built_in">this</span>.salary * byPercent/<span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.salary += raise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装的优点">封装的优点</h3><p>需要获得或设置实例域的值。因此，应该提供下面三项内容：</p><ul><li><p>一个私有的数据域</p></li><li><p>一个公有的域访问器方法</p></li><li><p>一个公有的域更改器方法。</p></li></ul><blockquote><p>不要编写返回引用可变对象的访问器方法</p><p>如果需要返回一个可变数据域的拷贝，就应该使用clone</p></blockquote><h3 id="基于类的访问权限">基于类的访问权限</h3><p>方法可以访问所属类的私有特性（feature），而不仅限于访问隐式参数的私有特性。</p><h3 id="final实例字段">final实例字段</h3><p>可以将实例字段定义为final。构建对象时必须初始化这样的字段。必须确保在每一个构造器执行之后，这个字段的值被设置，并且在后面的操作中，不能够再对它进行修改。</p><p>但对于可变的类，使用final修饰符可能会造成混乱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StringBulider evaluations;</span><br></pre></td></tr></table></figure><p>final关键字只是表示存储在evaluations变量中的对象引用不会再指示其他StringBuilder对象。不过这个对象可以更改。</p><h2 id="静态字段和静态方法">静态字段和静态方法</h2><h3 id="静态字段">静态字段</h3><p>如果将字段定义为static，这个字段不出现在每个类的对象中，每个静态字段只有一个副本，静态字段属于类，但不属于单个对象。</p><p>可以用来构造静态常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="keyword">class</span> <span class="title class_">Math</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.1415926</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态方法">静态方法</h3><p>静态方法是一种不能向对象实施操作的方法。没有this参数，不能访问实例字段。</p><p>可用类名.静态方法名/对象.静态方法名调用。</p><h3 id="工厂方法">工厂方法</h3><p>继承子类</p><h3 id="main方法">main方法</h3><p>静态方法，不对任何对象进行操作</p><h2 id="方法参数">方法参数</h2><p>一个方法可以修改<strong>传递引用</strong>所对应的变量值，而不能修改传递<strong>值调用</strong>所对应的变量值。</p><p>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。</p><p><img src="https://pic.imgdb.cn/item/66c42efbd9c307b7e9412403.png" alt="按值调用"></p><p>对于对象来说可行：<br><img src="https://pic.imgdb.cn/item/66c42f77d9c307b7e941840f.png" alt="对象"></p><p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul><h2 id="对象构造">对象构造</h2><h3 id="重载">重载</h3><p>如果多个方法（比如，StringBuilder构造器方法）有相同的名字、不同的参数，便产生了重载。</p><blockquote><p>Java允许重载任何方法，而不只是构造器方法。因此，要完整地描述一个方法，需要指出方法名以及参数类型。这叫做方法的签名（signature）。</p><p>不能有两个名字相同、参数类型也相同却返回不同类型值的方法。</p></blockquote><h3 id="默认字段初始化">默认字段初始化</h3><p>必须明确地初始化方法中的局部变量。但是，如果没有初始化类中的字段，将会被自动初始化为默认值（0、false或null）。</p><h3 id="无参数构造">无参数构造</h3><p>一个类时没有编写构造器，那么系统就会提供一个无参数构造器。如果类中提供了至少一个构造器，但是没有提供无参数的构造器，则在构造对象时如果没有提供参数就会被视为不合法。</p><h3 id="参数名技巧">参数名技巧</h3><p>参数变量会遮蔽同名的实例字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String aName,<span class="type">double</span> aSalary)</span>&#123;</span><br><span class="line">    name = aName;</span><br><span class="line">    salary = aSalary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name,<span class="type">double</span> salary)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.salary = salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用另一个构造器">调用另一个构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">double</span> s)</span>&#123;</span><br><span class="line"><span class="comment">//调用Employee(String name,double salary)</span></span><br><span class="line">    <span class="built_in">this</span>(<span class="string">&quot;Employee #&quot;</span> + nextId,s);</span><br><span class="line">    nextId++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化块">初始化块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// set nextId to a random number between 0 and 9999</span></span><br><span class="line">      nextId = generator.nextInt(<span class="number">10000</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="对象析构">对象析构</h3><p>由于Java有自动的垃圾回收器，不需要人工回收内存，所以Java不支持析构器。</p><ul><li>一旦用完就关闭，close方法</li><li>等到虚拟机退出再关闭，Euntime.addShutdownHook</li></ul><h2 id="记录">记录</h2><p>是特殊的类，状态不可改变，公共可读。</p><p>组件：一个记录的实例字段。</p><ul><li>toString</li><li>equals</li><li>hashCode</li></ul><p>不能为记录增加实例字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Piont</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> r;<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记录的实例字段自动为final字段（可变），可自己设置不可变类型。</p><p>标准构造器：自动定义地设置所有实例字段的构造器。</p><p>自定义构造器：第一句必须调用另一个构造器，最终会调用标准构造器。</p><p>不能在简洁构造器主体中读取或修改实例字段。</p><h2 id="包">包</h2><h3 id="类的导入">类的导入</h3><p>类可以使用所属包中的所有类和其他包的公共类。</p><p>访问其他包的公共类：</p><ul><li>完全限定类名</li><li>import java.time*(只能导入一个包)</li></ul><h3 id="在包中增加类">在包中增加类</h3><p>要想将一个类放入包中，就必须将包的名字放在源文件的开头，包中定义类的代码之前。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.horstmann.corejava;</span><br></pre></td></tr></table></figure><p>如果没有在源文件中放置package语句，这个源文件中的类就被放置在一个无名包中。无名包是一个没有名字的包。</p><p>子目录：com\horstmann\corejava</p><blockquote><p>编译器处理文件（不检查目录结构），解释器加载类</p></blockquote><h3 id="包访问">包访问</h3><p>如果没有指定public或private，这个部分（类、方法或变量）可以被同一个包中的所有方法访问。</p><h3 id="文档注释">文档注释</h3><p>javadoc——HTML文档，<code>/**...*/</code>在标记之后紧跟着自由格式文本（free-form text）。标记由@开始，如@author或@param。自由格式文本的第一句应该是一个概要性的句子。javadoc实用程序自动地将这些句子抽取出来形成概要页。</p><blockquote><p>要键入等宽代码，需使用{@code …}而不是&lt;code&gt;…&lt;/code&gt;</p><p>果文档中有到其他文件的链接，例如，图像文件（用户界面的组件的图表或图像等），就应该将这些文件放到子目录doc-files中。javadoc实用程序将从源目录拷贝这些目录及其中的文件到文档目录中。在链接中需要使用doc-files目录，例如：&lt;img src=“doc-files/uml.png”alt=“UML diagram”&gt;。</p></blockquote><ul><li><p>类注释 类注释必须放在import语句之后，类定义之前。</p></li><li><p>方法注释 每一个方法注释必须放在所描述的方法之前。</p><ul><li><p>@param变量描述</p><p>这个标记将对当前方法的“param”（参数）部分添加一个条目。这个描述可以占据多行，并可以使用HTML标记。一个方法的所有@param标记必须放在一起。</p></li><li><p>@return描述</p><p>这个标记将对当前方法添加“return”（返回）部分。这个描述可以跨越多行，并可以使用HTML标记。</p></li><li><p>@throws类描述</p><p>这个标记将添加一个注释，用于表示这个方法有可能抛出异常。</p></li></ul></li><li><p>字段注释 只需要对公有字段（通常指的是静态常量）的注释</p></li><li><p>通用注释</p><ul><li><p>@author姓名</p></li><li><p>@version文本</p></li><li><p>@since文本</p></li><li><p>@see引用</p><p>建立一个链接到com.horstmann.corejava.Employee类的raiseSalary(double)方法的超链接。</p><p>@see标记后面有一个&lt;字符，就需要指定一个超链接。</p></li><li><p>@deprecated文本</p></li></ul></li><li><p>包注释</p><ul><li>提供一个以package.html命名的HTML文件。在标记&lt;body&gt;…&lt;/body&gt;之间的所有文本都会被抽取出来。</li><li>提供一个以package-info.java命名的Java文件。这个文件必须包含一个初始的以/*<em>和</em>/界定的Javadoc注释，跟随在一个包语句之后。它不应该包含更多的代码或注释。</li></ul></li><li><p>注释提取</p><ul><li><p>切换到包含想要生成文档的源文件目录。</p></li><li><pre><code class="language-java">javadoc -d docDirectory nameOfPackage//包javadoc -d docDirectory nameOfPackagenameOfPackage...//多个包的文档    javadoc -d docDirectory *java//文件在默认包<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 类设计技巧</span><br><span class="line"></span><br><span class="line">  - 一定要保证数据私有</span><br><span class="line">  - 一定要对数据初始化</span><br><span class="line">  - 不要在类中使用过多的基本类型</span><br><span class="line">  - 不是所有的字段都需要独立的字段访问器和字段更改器</span><br><span class="line">  - 将职责过多的类进行分解</span><br><span class="line">  - 类名和方法名要能够体现它们的职责</span><br><span class="line">  - 优先使用不可变的类</span><br><span class="line"></span><br><span class="line"># 继承</span><br><span class="line"></span><br><span class="line">## 类、超类和子类</span><br><span class="line"></span><br><span class="line">“is-a”关系是继承的特征</span><br><span class="line"></span><br><span class="line">### 定义子类</span><br><span class="line"></span><br><span class="line">所有继承都是公共继承</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Manger extends Employee&#123;</span><br><span class="line">    added methods and fields</span><br><span class="line">&#125;//Employee超类，基类，父类</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><blockquote><p>声明为私有的类成员不会被这个类的子类继承，因为子类不能直接访问私有字段。但子类创建的对象有这些字段。</p></blockquote><h3 id="覆盖方法">覆盖方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">baseSalary</span> <span class="operator">=</span> <span class="built_in">super</span>.getSalary();</span><br><span class="line">    <span class="keyword">return</span> baseSalary + bonus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>super不是对象的引用，是指示编译器调用超类方法的特殊关键字。继承不会删除任何字段或方法。</p></blockquote><h3 id="子类构造器">子类构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String name, <span class="type">double</span> salary, <span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">super</span>(name, salary, year, month, day);</span><br><span class="line">    <span class="comment">//调用Employee类的name, salary, year, month, day参数的构造器</span></span><br><span class="line">    bonus = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器。</p><ul><li>this<ul><li>引用隐式参数</li><li>调用该类其他的构造器</li></ul></li><li>super<ul><li>调用超类的方法</li><li>调用超类的构造器</li></ul></li></ul><h3 id="继承层次结构">继承层次结构</h3><p><img src="https://pic.imgdb.cn/item/66c848f9d9c307b7e93f49a6.png" alt="层次结构"></p><p>由一个公共超类派生出来的所有类的集合被称为继承层次（inheritance hierarchy)，继承层次中，从某个特定的类到其祖先的路径被称为该类的继承链（inheritance chain）。</p><blockquote><p>Java不支持多继承。</p></blockquote><h3 id="多态">多态</h3><p>“is-a”规则的另一种表述法是置换法则。可以将一个子类的对象赋给超类变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> inheritance;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program demonstrates inheritance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.21 2004-02-21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Cay Horstmann</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ManagerTest</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">var</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;Carl Cracker&quot;</span>, <span class="number">80000</span>, <span class="number">1987</span>, <span class="number">12</span>, <span class="number">15</span>);</span><br><span class="line">      boss.setBonus(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">var</span> <span class="variable">staff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">      staff[<span class="number">0</span>] = boss;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boss.setBonus(<span class="number">5000</span>) <span class="comment">//对</span></span><br><span class="line">staff[<span class="number">0</span>].setBonus(<span class="number">5000</span>) <span class="comment">//错</span></span><br><span class="line"><span class="type">Manager</span> <span class="variable">m</span> <span class="operator">=</span> staff[i] <span class="comment">//不能将超类的引用赋值给类变量</span></span><br></pre></td></tr></table></figure><p>staff[0]的声明类型是Employee</p><h3 id="理解方法调用">理解方法调用</h3><ol><li>编译器查看对象的声明类型和方法名。</li><li>查看调用方法时提供的参数类型。如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法，这个过程被称为<strong>重载解析</strong>。</li><li>如果是private方法、static方法、final方法（有关final修饰符的含义将在下一节讲述）或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式称为<strong>静态绑定</strong>（static binding）。与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现<strong>动态绑定</strong>。</li><li>当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。假设x的实际类型是D，它是C类的子类。如果D类定义了方法f(String)，就直接调用它；否则，将在D类的超类中寻找f(String)，以此类推。</li></ol><p>虚拟机预先为每个类创建了一个方法表（method table），</p><blockquote><p>在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是，如果超类方法是public，子类方法一定要声明为public。</p></blockquote><h3 id="阻止继承：final类和方法">阻止继承：final类和方法</h3><p>不允许扩展的类被称为final类，使用final修饰符，final类中的所有方法自动地成为final方法。</p><p>如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程为称为<strong>内联</strong>（inlining）。</p><blockquote><p>枚举和记录总是final,它们不允许扩展。</p></blockquote><h3 id="强制类型转换✨">强制类型转换✨</h3><p>如果试图在继承链上进行向下的类型转换，并且“谎报”有关对象包含的内容，会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Manager</span> <span class="variable">boss</span> <span class="operator">=</span> (Manager) staff[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>在进行类型转换之前，先查看一下是否能够成功地转换。这个过程简单地使用instanceof操作符就可以实现。如果这个类型转换不可能成功，编译器就不会进行这个转换。</p><p><img src="https://pic.imgdb.cn/item/66c8a73bd9c307b7e9d9714a.png" alt="instanceof"></p><ul><li>只能在继承层次内进行类型转换。</li><li>在将超类转换成子类之前，应该使用instanceof进行检查。</li></ul><h3 id="instanceof模式匹配✨">instanceof模式匹配✨</h3><p>Java16:直接在测试中声明子变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (staff[i] <span class="keyword">instanceof</span> Manager boss)&#123;</span><br><span class="line">boss.setBonus(<span class="number">5000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>staff[i]是Manager类的实体，boss变为staff[i]；否则，不会设置boss，生成false值。</p><p>引入一个变量时，可以立即在同一个表达式中使用这个变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Employee e;</span><br><span class="line"><span class="keyword">if</span> (e <span class="keyword">instanceof</span> Manager m &amp;&amp; m.getBonus() &gt; <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有&amp;&amp;左边true才计算右边，若计算右边，则m必为一个Manager实例</span></span><br></pre></td></tr></table></figure><p>instanceof模式定义的局部变量会遮蔽字段。</p><h3 id="受保护访问">受保护访问</h3><p>希望超类中的某些方法允许被子类访问，或允许子类的方法访问超类的某个字段。为此，需要将这些方法或域声明为<strong>protected</strong>。受保护的字段只能由同一个包的类访问</p><p>🎀Java用于控制可见性的4个访问修饰符</p><ul><li>仅对本类可见——private</li><li>对所有类可见——public</li><li>对本包和所有子类可见——protected</li><li>对本包可见——默认（很遗憾），不需要修饰符</li></ul><h2 id="Object：所有类的超类">Object：所有类的超类</h2><p>可以使用Object类型的变量引用任何类型的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Harry Hacker&quot;</span>,<span class="number">35000</span>);</span><br></pre></td></tr></table></figure><p>Object类型的变量只能用于作为各种值的泛型容器。要想对其中的内容进行具体的操作，还需要清楚对象的原始类型，并进行相应的类型转换。</p><p>只有基本类型（primitive types）不是对象，例如，数值、字符和布尔类型的值都不是对象。<strong>所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类。</strong></p><h3 id="equals方法">equals方法</h3><p>只有在两个对象属于同一个类时，才有可能相等。</p><p>在子类中定义equals方法时，首先调用超类的equals。如果检测失败，对象就不可能相等。如果超类中的字段都相等，就需要比较子类中的实例字段。</p><h3 id="相等测试与继承">相等测试与继承</h3><p>如果发现类不匹配，equals方法就返回false。但是，许多程序员却喜欢使用instanceof进行检测：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(otherObject <span class="keyword">instanceof</span> Employee)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>特性:</p><ol><li>自反性：对于任何非空引用x, x.equals(x)应该返回true。</li><li>对称性：对于任何引用x和y，当且仅当y.equals(x)返回true,x.equals(y)也应该返回true。</li><li>传递性：对于任何引用x、y和z，如果x.equals(y)返回true,y.equals(z)返回true, x.equals(z)也应该返回true。</li><li>一致性：如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果。</li><li>对于任意非空引用x, x.equals(null)应该返回false。</li></ol><p>注意：</p><ul><li>如果子类能够拥有自己的相等概念，则对称性需求将强制采用getClass进行检测。</li><li>如果由超类决定相等的概念，那么就可以使用instanceof进行检测，这样可以在不同子类的对象之间进行相等的比较。</li></ul><h3 id="hashCode方法">hashCode方法</h3><p>要考虑这个散列码是基于数值还是地址计算的</p><h3 id="toString方法">toString方法</h3><p>最好给每个类都搞一个toString方法。</p><p>Object类定义了toString方法，用来打印输出对象所属的类名和散列码。</p><h2 id="泛型数组列表">泛型数组列表</h2><p>在运行时确定数组大小——ArrayList，一个采用<strong>类型参数</strong>（type parameter）的泛型类（generic class）。</p><h3 id="声明数组列表">声明数组列表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> <span class="title class_">ArryList</span>&lt;Employee&gt;(<span class="number">100</span>);<span class="comment">//初始容量100</span></span><br><span class="line">    </span><br><span class="line"><span class="type">var</span> <span class="variable">staff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArryList</span>&lt;Employee&gt;();</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> <span class="title class_">ArryList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><blockquote><p>分配数组列表 != 分配数组元素</p></blockquote><p>确定数组大小不再变化后可使用trimToSize方法，需移动内存块。</p><h3 id="访问数组元素">访问数组元素</h3><p>只有i小于或等于数组列表的大小时，才能够调用list.set(i, x)，要得到一个数组列表的元素，可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> staff.get(i); </span><br><span class="line"><span class="comment">//只有i小于或等于数组列表的大小时，才能够调用list.set(i, x)。</span></span><br><span class="line"></span><br><span class="line"><span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> (Employee) staff.get(i); </span><br><span class="line"><span class="comment">//get方法的调用者必须对返回值进行类型转换</span></span><br></pre></td></tr></table></figure><p>更为保险的方法是想创建一个数组列表，而后将其转换为数组元素（toArray方法）。</p><h3 id="类型化与原始数组列表的兼容性">类型化与原始数组列表的兼容性</h3><p>鉴于兼容性的考虑，编译器在对类型转换进行检查之后，如果没有发现违反规则的现象，就将所有的类型化数组列表转换成原始ArrayList对象。在程序运行时，所有的数组列表都是一样的，即没有虚拟机中的类型参数。因此，类型转换（ArrayList）和（ArrayList<Employee>）将执行相同的运行时检查。</p><p>只要在与遗留的代码进行交叉操作时，研究一下编译器的警告性提示，并确保这些警告不会造成太严重的后果就行了。</p><h3 id="对象包装器与自动装箱">对象包装器与自动装箱</h3><p>对象包装器类是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。</p><p>对象包装器类还是final，因此不能定义它们的子类。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">List</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">3</span>);<span class="comment">//自动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> list.get(i);<span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure><blockquote><p>绝对不要依赖包装器对象的同一性。不要用<code>==</code>比较包装器对象（这是依据存储位置进行比较），可以用equals()比较，也不要将包装器对象作为锁。</p></blockquote><p>装箱和拆箱是编译器的工作，不是虚拟机。</p><p>Integer对象是不可变的，在方法内部对这个拷贝所做的任何修改都不会影响到原始变量。这就是所谓的“<strong>按值传递</strong>”。</p><h2 id="参数个数可变的方法">参数个数可变的方法</h2><p>可以将已经存在且最后一个参数是数组的方法重新定义为可变参数的方法，而不会破坏任何已经存在的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String...args)</span></span><br></pre></td></tr></table></figure><h2 id="抽象类">抽象类</h2><p>包含一个或多个抽象方法的类本身必须被声明为抽象的，抽象方法相当于子类中实现的具体方法的占位符。</p><blockquote><p>抽象类不能实例化，仍可以创建一个抽象类的对象变量，但只能引用非抽象子类的对象。</p><p>编译器只允许调用在类中声明的方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> acstract <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span> acstract String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举类">枚举类</h2><p>枚举的构造器总是私有的，所有枚举类型都是抽象类Enum的子类，</p><ul><li>ordinal方法返回enum声明中枚举常量的位置，位置从0开始计数。</li><li>每个枚举类型都有一个静态的values方法，它将返回一个包含全部枚举值的数组。</li><li>toString，这个方法能够返回枚举常量名。</li></ul><h2 id="密封类">密封类</h2><p>acstract sealsd声明为密封类，控制哪些类可以继承它。</p><p>一个密封类允许的子类必须是可访问的，不能是嵌套在另一个类中的私有类，也不能是位于另一个包中的包可见的类。</p><blockquote><p>记录和枚举可以实现接口但不能扩展类</p></blockquote><h2 id="反射（待补充）">反射（待补充）</h2><p>能够分析类能力的程序称为<strong>反射</strong>。</p><h1>接口、lambda表达式和内部类</h1><p>接口（interface）技术，这种技术主要用来描述类具有什么功能，而并不给出每个功能的具体实现。</p><p>使用lambda表达式，可以用一种精巧而简洁的方式表示使用回调或变量行为的代码。</p><p>内部类（inner class）机制，内部类定义在另外一个类的内部，其中的方法可以访问包含它们的外部类的字段。内部类技术主要用于设计具有相互协作关系的类集合。</p><p>代理是一种非常专业的构造工具，它可以用来构建系统级的工具。</p><h2 id="接口">接口</h2><h3 id="接口概念">接口概念</h3><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p><p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p><p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><h3 id="接口与类相似点">接口与类相似点</h3><ul><li>一个接口可以有多个方法。</li><li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li><li>接口的字节码文件保存在 .class 结尾的文件中。</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li></ul><h3 id="接口与类的区别">接口与类的区别</h3><ul><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。</li><li>接口不能包含成员变量，除了 static 和 final 变量。</li><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多继承。</li></ul><h3 id="接口特性">接口特性</h3><ul><li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li></ul><h3 id="抽象类和接口的区别">抽象类和接口的区别</h3><ul><li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</li><li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><h3 id="接口的声明">接口的声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名称 [extends 其他的接口名] &#123;</span><br><span class="line">    <span class="comment">// 声明变量</span></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Interface关键字用来声明一个接口。</p><ul><li>接口是隐式抽象的，当声明一个接口的时候，不必使用<strong>abstract</strong>关键字。</li><li>接口中每一个方法也是隐式抽象的，声明时同样不需要<strong>abstract</strong>关键字。</li><li>接口中的方法都是公有的。</li></ul><h3 id="接口的实现">接口的实现</h3><p>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。</p><p>类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。</p><p>实现一个接口的语法:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...</span><br></pre></td></tr></table></figure><p>EG:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件名 : MammalInt.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MammalInt</span> <span class="keyword">implements</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Mammal eats&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">travel</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Mammal travels&quot;</span>);</span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">noOfLegs</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">      <span class="type">MammalInt</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MammalInt</span>();</span><br><span class="line">      m.eat();</span><br><span class="line">      m.travel();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写接口中声明的方法时，需要注意以下规则：</p><ul><li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</li><li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li><li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</li></ul><p>在实现接口的时候，也要注意一些规则：</p><ul><li>一个类可以同时实现多个接口。</li><li>一个类只能继承一个类，但是能实现多个接口。</li><li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li></ul><h3 id="接口的继承">接口的继承</h3><p>一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。</p><p>下面的Sports接口被Hockey和Football接口继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名: Sports.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Sports</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHomeTeam</span><span class="params">(String name)</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVisitingTeam</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 文件名: Football.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Football</span> <span class="keyword">extends</span> <span class="title class_">Sports</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">homeTeamScored</span><span class="params">(<span class="type">int</span> points)</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitingTeamScored</span><span class="params">(<span class="type">int</span> points)</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">endOfQuarter</span><span class="params">(<span class="type">int</span> quarter)</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 文件名: Hockey.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hockey</span> <span class="keyword">extends</span> <span class="title class_">Sports</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">homeGoalScored</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitingGoalScored</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">endOfPeriod</span><span class="params">(<span class="type">int</span> period)</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">overtimePeriod</span><span class="params">(<span class="type">int</span> ot)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hockey接口自己声明了四个方法，从Sports接口继承了两个方法，这样，实现Hockey接口的类需要实现六个方法。</p><p>相似的，实现Football接口的类需要实现五个方法，其中两个来自于Sports接口。</p><h3 id="接口的多继承">接口的多继承</h3><p>在Java中，类的多继承是不合法，但接口允许多继承。</p><p>在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hockey</span> <span class="keyword">extends</span> <span class="title class_">Sports</span>, Event</span><br></pre></td></tr></table></figure><p>与类不同的是，接口允许多继承，而 Sports及 Event 可以定义或是继承相同的方法。</p><h3 id="标记接口">标记接口</h3><p>最常用的继承接口是没有包含任何方法的接口。</p><p>标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。</p><p>标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p><p>例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EventListener</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p><ul><li><p>建立一个公共的父接口：</p><p>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p></li><li><p>向一个类添加数据类型：</p><p>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记</title>
      <link href="/2024/08/01/JAVA/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/08/01/JAVA/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>变量</h1><h2 id="Java数据类型">Java数据类型</h2><p><img src="https://pic.imgdb.cn/item/66a4cc76d9c307b7e99c6ebc.png" alt="数据类型"></p><ul><li>整数类型<ul><li>byte——1字节</li><li>short——2字节</li><li>int——4字节（默认）</li><li>long——8字节</li></ul></li><li>浮点类型<ul><li>float——4字节</li><li>double——8字节（默认）</li></ul></li></ul><blockquote><p>浮点数使用陷阱<br>2.7和8.1/3比较，8.1/3的结果接近2.7而非2.7，精度问题</p><span class='p red'>运算结果是小数要注意</span> 应以两个数的差的绝对值在某精度范围内判断</blockquote><h2 id="Java-API-文档">Java API 文档</h2><p>API (Application Programming Interface,应用程序编程接口)是Java提供的基本编程接口(Gava提供的类还有相关的方法)。</p><blockquote><p>中文在线文档：<a href="https://www.matools.com">https://www.matools.com</a></p></blockquote><p>类的组织形式</p><p><img src="https://pic.imgdb.cn/item/66a4d18fd9c307b7e9a240ce.png" alt="类的组织形式"></p><ul><li><p>字符类型(char)</p><p>在java中，char的本质是一个整数，在输出时，是unicode码对应的字符，可参与运算。</p></li><li><p>布尔类型——1字节</p></li></ul><h2 id="基本数据类型转换">基本数据类型转换</h2><h3 id="自动类型转换">自动类型转换</h3><p>当java程序在进行赋值或者运算时，精度小的类型自动转换为<code>精度最大</code>的数据类型。</p><p><img src="https://pic.imgdb.cn/item/66a4d63bd9c307b7e9a776f1.png" alt="自动类型转换"></p><blockquote><p>精度大-&gt;精度小会报错</p><p>byte和char不自动转换</p><p>byte,char,short可以转换为int计算，一运算就成int</p><p>布尔不参与转换</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">d1</span> <span class="operator">=</span> n1 + <span class="number">1.1</span>;<span class="comment">//错 结果类型是 double</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> n1 + <span class="number">1.1</span>;<span class="comment">//对 结果类型是 double</span></span><br><span class="line"> d1 = n1 + <span class="number">1.1F</span>;<span class="comment">//对 结果类型是 float</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> n ;<span class="comment">//错,变量间的赋值先判断类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">a3</span> <span class="operator">=</span> a1 + a2;<span class="comment">//错 一运算就成int</span></span><br></pre></td></tr></table></figure><h3 id="强制类型转换">强制类型转换</h3><p>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符 ( )，但可能造成精度降低或溢出。</p><p><img src="https://pic.imgdb.cn/item/66a4db66d9c307b7e9aaf28f.png" alt="强制类型转换"></p><h3 id="基本数据类型和-String类型转换">基本数据类型和 String类型转换</h3><p>基本类型转String类型：将基本类型的值+“”</p><p>String类型转基本数据类型：通过基本类型的包装类调用parseXX:方法</p><blockquote><p>要确保String类型能够转成有效的数据</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1.1F</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">4.5</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> n1 + <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(s5);</span><br><span class="line"><span class="type">double</span> <span class="variable">num2</span> <span class="operator">=</span> Double.parseDouble(s5);</span><br><span class="line"><span class="type">float</span> <span class="variable">num3</span> <span class="operator">=</span> Float.parseFloat(s5);</span><br><span class="line"><span class="type">long</span> <span class="variable">num4</span> <span class="operator">=</span> Long.parseLong(s5);</span><br><span class="line"><span class="type">byte</span> <span class="variable">num5</span> <span class="operator">=</span> Byte.parseByte(s5);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>);</span><br><span class="line"><span class="type">short</span> <span class="variable">num6</span> <span class="operator">=</span> Short.parseShort(s5);</span><br></pre></td></tr></table></figure><h1>运算符</h1><h2 id="算术运算符">算术运算符</h2><p>对于除号/，它的整数除和小数除是有区别的：整数之间做除法时，只保留整数部分而舍弃小数部分。例如：intx=10/3,结果是3。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">3</span>  <span class="comment">//3</span></span><br><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">3</span>  <span class="comment">//3.33</span></span><br></pre></td></tr></table></figure><p>%的本质： <code>a%b = a-a/b*b</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10 % -3 = 1</span><br><span class="line">-10 % 3 = -1</span><br><span class="line">-10 % -3 = -1</span><br></pre></td></tr></table></figure><p>i=i++:结果i=1</p><blockquote><p>使用临时变量：(1)temp=i:(2)i=i+1;(3)i=temp</p></blockquote><p>i=++i:结果i=2</p><h2 id="关系运算符">关系运算符</h2><p>都是boolean型</p><h2 id="逻辑运算符">逻辑运算符</h2><ul><li>逻辑与&amp;，逻辑或|，逻辑异或^</li><li>短路与&amp;&amp;，短路或||，取反!</li></ul><p><img src="https://pic.imgdb.cn/item/66a63a0cd9c307b7e9dcc0f3.png" alt="逻辑运算符"></p><blockquote><p>&amp;&amp;和&amp;使用区别(||和|同理)</p><p>&amp;&amp;短路与：如果第一个条件为false,则第二个条件不会判断，最终结果为false,效率高</p><p>&amp;逻辑与：不管第一个条件是否为false,第二个条件都要判断，效率低</p></blockquote><h2 id="赋值运算符">赋值运算符</h2><p>只有单目运算符、赋值运算符是从右向左运算，会进行类型转换。</p><h2 id="三元运算符">三元运算符</h2><blockquote><p>条件表达式 ? 表达式 1:表达式 2</p></blockquote><p>如果条件表达式为rue,运算后的结果是表达式1，如果条件表达式为false,运算后的结果是表达式2。</p><p>表达式 1 和表达式 2 要为可以赋给接收变量的类型(或可以自动转换)。</p><h2 id="标识符">标识符</h2><p>Java对各种变量、方法和类等命名时使用的字符序列称为标识符。</p><p>🎀命名规则</p><ol><li><p>由26个英文字母大小写，0-9，或$组成</p></li><li><p>数字不可以开头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int3ab=<span class="number">1</span>;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li><li><p>不可以使用关键字和保留字，但能包含关键字和保留字。</p></li><li><p>Java中严格区分大小写，长度无限制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> totalNum=<span class="number">10</span>;intn=<span class="number">90</span>;</span><br></pre></td></tr></table></figure></li><li><p>标识符不能包含空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a b=<span class="number">90</span>;</span><br></pre></td></tr></table></figure></li></ol><p>包名：多单词组成时所有字母都小写：aaa.bbb.ccc //比如 com.hsp.crm</p><p>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰] 比如： TankShotGame</p><p>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz [小 驼峰， 简称 驼峰法] 比如：tankShotGame</p><p>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ 比如 ：定义一个所得税率 TAX_RATE</p><h2 id="关键字">关键字</h2><p>被 Java 语言赋予了特殊含义，用做专门用途的字符串（单词），所有字母都为小写。</p><h2 id="保留字">保留字</h2><p>现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留 字 byValue、cast、future、 generic、 inner、 operator、 outer、 rest、 var 、 goto 、const</p><h2 id="键盘输入语句">键盘输入语句</h2><p>以使用键盘输入语句来获取。Input.java , 需要一个 扫描器(对象), 就是 Scanner</p><p>🎀步骤：</p><ul><li>导入该类的所在包, java.util.</li><li>创建该类对象（声明变量）</li><li>调用里面的功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="comment">//表示把 java.util 下的 Scanner 类导入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Input</span> &#123;</span><br><span class="line">    <span class="comment">//编写一个 main 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//演示接受用户的输入</span></span><br><span class="line">    <span class="comment">//步骤</span></span><br><span class="line">    <span class="comment">//Scanner 类 表示 简单文本扫描器，在 java.util 包</span></span><br><span class="line">    <span class="comment">//1. 引入/导入 Scanner 类所在的包</span></span><br><span class="line">    <span class="comment">//2. 创建 Scanner 对象 , new 创建一个对象,体会</span></span><br><span class="line">    <span class="comment">// myScanner 就是 Scanner 类的对象</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">myScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="comment">//3. 接收用户输入了， 使用 相关的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入名字&quot;</span>);</span><br><span class="line">    <span class="comment">//当程序执行到 next 方法时，会等待用户输入~~~</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> myScanner.next(); <span class="comment">//接收用户输入字符串</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入年龄&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> myScanner.nextInt(); <span class="comment">//接收用户输入 int</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入薪水&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">sal</span> <span class="operator">=</span> myScanner.nextDouble(); <span class="comment">//接收用户输入 double</span></span><br><span class="line">        System.out.println(<span class="string">&quot;人的信息如下:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;名字=&quot;</span> + name</span><br><span class="line">                + <span class="string">&quot; 年龄=&quot;</span> + age + <span class="string">&quot; 薪水=&quot;</span> + sal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进制">进制</h2><p>Java没有无符号数，计算机运算时都是以补码形式运算</p><h2 id="位运算符">位运算符</h2><p>按位与<code>&amp;</code>、按位或<code>|</code>，按位异或<code>^</code>，按位取反<code>~</code>，算数右移<code>&gt;&gt;</code>，算数左移<code>&lt;&lt;</code>，逻辑右移<code>&gt;&gt;&gt;</code>（低位溢出，高位补 0），没有逻辑左移。</p><h1>程序控制结构</h1><ul><li>顺序控制 前向引用</li><li>分支控制 if-else</li><li>switch 分支结构</li><li>for</li><li>while</li></ul><h1>数组、排序和查找</h1><h2 id="数组">数组</h2><p>数组属引用类型，数组型数据是对象(object)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态初始化</span></span><br><span class="line"><span class="type">int</span> a[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> b[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure><p>数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。</p><p>数组创建后，如果没有赋值，有默认值 <code>int 0</code>，<code>short 0</code>, <code>byte 0</code>, <code>long 0</code>, <code>float 0.0</code>,<code>double 0.0</code>，<code>char \u0000</code>，<code>boolean false</code>，<code>String null</code></p><h2 id="赋值机制">赋值机制</h2><p>基本数据类型赋值方式为值拷贝</p><p>数组赋值方式为引用传递，赋的值是地址，赋值方式为引用传达</p><p>若需要拷贝后的数组地址独立，则需要new</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1 = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;; </span><br><span class="line"><span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span> [arr1.length]</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr1.length;i++)&#123;</span><br><span class="line">arr2[i] = arr1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维数组">二维数组</h2><h3 id="动态初始化">动态初始化</h3><p><img src="https://pic.imgdb.cn/item/66aa5b52d9c307b7e96f50ea.png" alt="二维数组"></p><blockquote><p>也可以这样创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][]</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//给每个一维数组开空间 new</span></span><br><span class="line"><span class="comment">//如果没有给一维数组 new ,那么 arr[i]就是 null</span></span><br><span class="line"><span class="comment">//遍历一维数组，并给一维数组的每个元素赋值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">    arr[i][j] = i + <span class="number">1</span>;<span class="comment">//赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="静态初始化">静态初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = &#123;&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;, &#123;<span class="number">8</span>,<span class="number">8</span>,<span class="number">9</span>&#125;, &#123;<span class="number">100</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><h1>面向对象编程</h1><h2 id="类与对象">类与对象</h2><p>类是抽象的，概念的，代表一类事物,比如人类,猫类…, 即它是数据类型</p><p>对象是具体的，实际的，代表一个具体事物, 即是实例</p><p>类是对象的模板，对象是类的一个个体，对应一个实例</p><p><img src="https://pic.imgdb.cn/item/66af0a8bd9c307b7e9124ad3.png" alt="类与对象"></p><p>属性的定义语法同变量，示例：访问修饰符 属性类型 属性名;</p><p>访问修饰符： 控制属性的访问范围 有四种访问修饰符 public, proctected, 默认, private ,</p><p>属性的定义类型可以为任意类型，包含基本类型或引用类型</p><p>属性如果不赋值，有默认值，规则和数组一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="number">0</span></span><br><span class="line"><span class="type">short</span> <span class="number">0</span></span><br><span class="line"><span class="type">byte</span> <span class="number">0</span></span><br><span class="line"><span class="type">long</span> <span class="number">0</span></span><br><span class="line"><span class="type">float</span> <span class="number">0.0</span></span><br><span class="line"><span class="type">double</span> <span class="number">0.0</span></span><br><span class="line"><span class="type">char</span> \u0000</span><br><span class="line"><span class="type">boolean</span> <span class="literal">false</span></span><br><span class="line">String nul</span><br></pre></td></tr></table></figure><ul><li>内存分配机制</li></ul><p>栈： 一般存放基本数据类型(局部变量)</p><p>堆： 存放对象(Cat cat , 数组等)</p><p>方法区：常量池(常量，比如字符串)， 类加载信息</p><h2 id="成员方法">成员方法</h2><p>调用机制</p><p><img src="https://pic.imgdb.cn/item/66af10bfd9c307b7e920090d.png" alt="方法调用机制"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 返回数据类型 方法名（形参列表..） &#123;//方法体</span><br><span class="line">    语句；</span><br><span class="line">    return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>方法不能嵌套定义</p><p>跨类中的方法A类调用B类方法：需要通过对象名调用。比如对象名，方法名（参数)</p><p>跨类的方法调用和方法的访问修饰符相关</p></blockquote><h3 id="传参机制">传参机制</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go基础语法（实战）</title>
      <link href="/2024/08/01/JAVA/%E9%9D%92%E8%AE%AD%E8%90%A5/%E5%AE%9E%E6%88%98/Go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AE%9E%E6%88%98/"/>
      <url>/2024/08/01/JAVA/%E9%9D%92%E8%AE%AD%E8%90%A5/%E5%AE%9E%E6%88%98/Go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i-blog.csdnimg.cn/direct/67372fb6ec6f4e4ca7c9ebdf25218970.jpeg#pic_center" alt="原理"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节青训营后端笔记——Go基础语法</title>
      <link href="/2024/08/01/JAVA/%E9%9D%92%E8%AE%AD%E8%90%A5/%E7%AC%94%E8%AE%B0/Go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/08/01/JAVA/%E9%9D%92%E8%AE%AD%E8%90%A5/%E7%AC%94%E8%AE%B0/Go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>变量</h1><p>FMT包。这个包主要是用来往屏幕输入输出字符串、格式化字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;initial&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b, c <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e <span class="type">float64</span></span><br><span class="line"></span><br><span class="line">f := <span class="type">float32</span>(e)</span><br><span class="line"></span><br><span class="line">g := a + <span class="string">&quot;foo&quot;</span></span><br><span class="line">fmt.Println(a, b, c, d, e, f) <span class="comment">// initial 1 2 true 0 0</span></span><br><span class="line">fmt.Println(g)                <span class="comment">// initialapple</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s <span class="type">string</span> = <span class="string">&quot;constant&quot;</span></span><br><span class="line"><span class="keyword">const</span> h = <span class="number">500000000</span></span><br><span class="line"><span class="keyword">const</span> i = <span class="number">3e20</span> / h</span><br><span class="line">fmt.Println(s, h, i, math.Sin(h), math.Sin(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go语言是一门强类型语言，每一个变量都有它自己的变量类型。</p><ul><li>字符串是内置类型，可以直接通过加号拼接，也能够直接用等于号去比较两个字符串。</li><li>大部分运算符的使用和优先级都和C或者C++类似。</li></ul><h2 id="变量的声明">变量的声明</h2><p>一种是通过var name string=&quot;这种方式来声明变量，声明变量的时候，一般会自动去推导变量的类型。<br>另一种声明变量的方式是：使用变量冒号：=等于值。</p><h2 id="常量">常量</h2><p>把var改成cost,go语言里面的常量没有确定的类型，会根据使用的上下文来自动确定类型。</p><h1>if-else</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="number">7</span>%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;7 is even&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;7 is odd&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="number">8</span>%<span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;8 is divisible by 4&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num := <span class="number">9</span>; num &lt; <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(num, <span class="string">&quot;is negative&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> num &lt; <span class="number">10</span> &#123;</span><br><span class="line">fmt.Println(num, <span class="string">&quot;has 1 digit&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(num, <span class="string">&quot;has multiple digits&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法和C或者C++类似。</p><ul><li>if后面没有括号。如果括号的话，那么在保存的时候你的编辑器会自动把你去掉。</li><li>if后面必须接大括号，不能像C或者C++一样，直接把f里面的语句同一行。</li></ul><h1>switch</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">a := <span class="number">2</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;one&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;two&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;three&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>, <span class="number">5</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;four or five&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;other&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t := time.Now()</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;It&#x27;s before noon&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;It&#x27;s after noon&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的在switch后面的变量名，并不要括号。在c++里面，switch case如果不不显示加break的话会然后会继续往下跑完所有的case,在go语言里面的话是不需要加break的。</p><p>相比C或者C++,go语言里面的switch功能更强大。<strong>可以使用任意的变量类型</strong>，甚至可以用来取代任意的if else语句。可以在switch后面不加任何的变量，然后在case里面写条件分支。这样代码比用多个if else代码逻辑会更为清晰。</p><h1>循环</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;loop&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">7</span>; j &lt; <span class="number">9</span>; j++ &#123;</span><br><span class="line">fmt.Println(j)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="number">5</span>; n++ &#123;</span><br><span class="line"><span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">3</span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">i = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go里面没有while循环、do while循环，只有唯一的一种for循环，可以用break或者continue来跳出或者继续循环。</p><h1>数组</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(<span class="string">&quot;get:&quot;</span>, a[<span class="number">2</span>])</span><br><span class="line">fmt.Println(<span class="string">&quot;len:&quot;</span>, <span class="built_in">len</span>(a))</span><br><span class="line"></span><br><span class="line">b := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> twoD [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">twoD[i][j] = i + j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;2d: &quot;</span>, twoD)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在真实业务代码里面，很少直接使用数组，用的更多的是切片。</p><h1>slice</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">3</span>)</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&quot;a&quot;</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line">s[<span class="number">2</span>] = <span class="string">&quot;c&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;get:&quot;</span>, s[<span class="number">2</span>])   <span class="comment">// c</span></span><br><span class="line">fmt.Println(<span class="string">&quot;len:&quot;</span>, <span class="built_in">len</span>(s)) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">&quot;d&quot;</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>)</span><br><span class="line">fmt.Println(s) <span class="comment">// [a b c d e f]</span></span><br><span class="line"></span><br><span class="line">c := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(s))</span><br><span class="line"><span class="built_in">copy</span>(c, s)</span><br><span class="line">fmt.Println(c) <span class="comment">// [a b c d e f]</span></span><br><span class="line"></span><br><span class="line">fmt.Println(s[<span class="number">2</span>:<span class="number">5</span>]) <span class="comment">// [c d e]</span></span><br><span class="line">fmt.Println(s[:<span class="number">5</span>])  <span class="comment">// [a b c d e]</span></span><br><span class="line">fmt.Println(s[<span class="number">2</span>:])  <span class="comment">// [c d e f]</span></span><br><span class="line"></span><br><span class="line">good := []<span class="type">string</span>&#123;<span class="string">&quot;g&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;</span><br><span class="line">fmt.Println(good) <span class="comment">// [g o o d]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片不同于数组可以任意更改长度，可以用mak来创建一个切片，可以像数组一样去取值，使用append来追加元素。</p><blockquote><p>注意append的用法，必须把append的结果赋值为原数组。</p></blockquote><p>因为sice的原理实际上是它有一个它存储了一个长度和一个容量，加一个指向一个数组的指针，在你执行append<br>操作的时候，如果容量不够的话，会扩容并且返回新的sice。</p><p>slice此初始化的时候也可以指定长度。sice拥有像python一样的切片操作，不过不同于python,这里不支持负数索引。</p><h1>map</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">m[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span></span><br><span class="line">m[<span class="string">&quot;two&quot;</span>] = <span class="number">2</span></span><br><span class="line">fmt.Println(m)           <span class="comment">// map[one:1 two:2]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(m))      <span class="comment">// 2</span></span><br><span class="line">fmt.Println(m[<span class="string">&quot;one&quot;</span>])    <span class="comment">// 1</span></span><br><span class="line">fmt.Println(m[<span class="string">&quot;unknow&quot;</span>]) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">r, ok := m[<span class="string">&quot;unknow&quot;</span>]</span><br><span class="line">fmt.Println(r, ok) <span class="comment">// 0 false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;one&quot;</span>)</span><br><span class="line"></span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> m3 = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(m2, m3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用make来创建一个空map,需要两个类型，第一个是key类型，这里是string；另一个是value的类型，是int。</p><p>可以从里面去存储或者取出键值对。可以用delete从里面删除键值对。</p><p>golang的map是完全无序的，遍历的时候不会按照字母顺序，也不会按照插入顺序输出，而是随机顺序。</p><h1>range</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">sum += num</span><br><span class="line"><span class="keyword">if</span> num == <span class="number">2</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;index:&quot;</span>, i, <span class="string">&quot;num:&quot;</span>, num) <span class="comment">// index: 0 num: 2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum) <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;b&quot;</span>: <span class="string">&quot;B&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">fmt.Println(k, v) <span class="comment">// b 8; a A</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> m &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;key&quot;</span>, k) <span class="comment">// key a; key b</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个slice或者一个map的话，可以用range来快速遍历。</p><p>range遍历的时候，对于数组会返回两个值，第一个是索引，第二个是对应位置的值。如果不需要索引可以用下划线来忽略。</p><h1>函数</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add2</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exists</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, k <span class="type">string</span>)</span></span> (v <span class="type">string</span>, ok <span class="type">bool</span>) &#123;</span><br><span class="line">v, ok = m[k]</span><br><span class="line"><span class="keyword">return</span> v, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">res := add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">fmt.Println(res) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">v, ok := exists(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;A&quot;</span>&#125;, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">fmt.Println(v, ok) <span class="comment">// A True</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现两个变量相加的函数。变量类型是后置的。</p><p>Golg里面的函数原生支持返回多个值。在实际的业务逻辑代码里面几乎所有的函数都返回两个值，第一个是真正<br>的返回结果，第二个值是一个错误信息。</p><h1>指针</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add2</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">n += <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add2ptr</span><span class="params">(n *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">*n += <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">n := <span class="number">5</span></span><br><span class="line">add2(n)</span><br><span class="line">fmt.Println(n) <span class="comment">// 5</span></span><br><span class="line">add2ptr(&amp;n)</span><br><span class="line">fmt.Println(n) <span class="comment">// 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针的一个主要用途就是对于传入参数进行修改。</p><p>这个函数试图把一个变量+2。但是单纯像上面这种写法其实是无效的。为了类型匹配，调用的时候会加一个&amp;符号，进行地址传递而非值传递。</p><h1>结构体</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name     <span class="type">string</span></span><br><span class="line">password <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span></span> checkPassword(password <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> u.password == password</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span></span> resetPassword(password <span class="type">string</span>) &#123;</span><br><span class="line">u.password = password</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := user&#123;name: <span class="string">&quot;wang&quot;</span>, password: <span class="string">&quot;1024&quot;</span>&#125;</span><br><span class="line">a.resetPassword(<span class="string">&quot;2048&quot;</span>)</span><br><span class="line">fmt.Println(a.checkPassword(<span class="string">&quot;2048&quot;</span>)) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体是带类型的字段的集合。这里user结构包含了两个字段，name和password。可以用结构体的名称去初始化一个结构体变量，构造的时候需要传入每个字段的初始值。也可以用键值对的方式去指定初始值，这样可以只对一部分字段进行初始化。结构体也能支持指针。</p><p>可以为结构体去定义一些方法。会有一点类似其他语言里面的类成员函数。比如上面例子的checkPassword的实现，从一个普通函数，改成了结构体方法。这样用户可以像a.checkPassword(“Xx”)去调用。具体的代码修改，就是把第一个参数，加上括号，写到函数名称前面。</p><p>在实现结构体的方法的时候也有两种写法，一种是带指针，一种是不带指针。性质同地址传递和值传递。</p><h1>错误处理</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name     <span class="type">string</span></span><br><span class="line">password <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findUser</span><span class="params">(users []user, name <span class="type">string</span>)</span></span> (v *user, err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> _, u := <span class="keyword">range</span> users &#123;</span><br><span class="line"><span class="keyword">if</span> u.name == name &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;u, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;not found&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">u, err := findUser([]user&#123;&#123;<span class="string">&quot;wang&quot;</span>, <span class="string">&quot;1024&quot;</span>&#125;&#125;, <span class="string">&quot;wang&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(u.name) <span class="comment">// wang</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> u, err := findUser([]user&#123;&#123;<span class="string">&quot;wang&quot;</span>, <span class="string">&quot;1024&quot;</span>&#125;&#125;, <span class="string">&quot;li&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err) <span class="comment">// not found</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(u.name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>符合语言习惯的做法就是使用一个单独的返回值来传递错误信息。能够很清晰地知道哪个函数返回了错误，并且能用简单的if-else来处理错误。</p><p>在函数里面，可以在那个函数的返回值类型里面，后面加一个err,就代表这个函数可能会返回错误。</p><p>在函数实现的时候，return需要同时return两个值，如果出现错误，可以return nil和一个error。没有就返回原本的结果和nil。</p><h1>字符串</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="string">&quot;hello&quot;</span></span><br><span class="line">fmt.Println(strings.Contains(a, <span class="string">&quot;ll&quot;</span>))                <span class="comment">// true</span></span><br><span class="line">fmt.Println(strings.Count(a, <span class="string">&quot;l&quot;</span>))                    <span class="comment">// 2</span></span><br><span class="line">fmt.Println(strings.HasPrefix(a, <span class="string">&quot;he&quot;</span>))               <span class="comment">// true</span></span><br><span class="line">fmt.Println(strings.HasSuffix(a, <span class="string">&quot;llo&quot;</span>))              <span class="comment">// true</span></span><br><span class="line">fmt.Println(strings.Index(a, <span class="string">&quot;ll&quot;</span>))                   <span class="comment">// 2</span></span><br><span class="line">fmt.Println(strings.Join([]<span class="type">string</span>&#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>&#125;, <span class="string">&quot;-&quot;</span>)) <span class="comment">// he-llo</span></span><br><span class="line">fmt.Println(strings.Repeat(a, <span class="number">2</span>))                     <span class="comment">// hellohello</span></span><br><span class="line">fmt.Println(strings.Replace(a, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="number">-1</span>))         <span class="comment">// hEllo</span></span><br><span class="line">fmt.Println(strings.Split(<span class="string">&quot;a-b-c&quot;</span>, <span class="string">&quot;-&quot;</span>))              <span class="comment">// [a b c]</span></span><br><span class="line">fmt.Println(strings.ToLower(a))                       <span class="comment">// hello</span></span><br><span class="line">fmt.Println(strings.ToUpper(a))                       <span class="comment">// HELLO</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(a))                                   <span class="comment">// 5</span></span><br><span class="line">b := <span class="string">&quot;你好&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(b)) <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>contains判断一个字符串里面是否有包含另一个字符串，count字符串计数，index查找某个字符串的位置。join连接多个字符串repeat重复多个字符串replace替换字符串。</p><h2 id="字符串格式化">字符串格式化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">x, y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">n := <span class="number">123</span></span><br><span class="line">p := point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(s, n) <span class="comment">// hello 123</span></span><br><span class="line">fmt.Println(p)    <span class="comment">// &#123;1 2&#125;</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;s=%v\n&quot;</span>, s)  <span class="comment">// s=hello</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;n=%v\n&quot;</span>, n)  <span class="comment">// n=123</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p=%v\n&quot;</span>, p)  <span class="comment">// p=&#123;1 2&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p=%+v\n&quot;</span>, p) <span class="comment">// p=&#123;x:1 y:2&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p=%#v\n&quot;</span>, p) <span class="comment">// p=main.point&#123;x:1, y:2&#125;</span></span><br><span class="line"></span><br><span class="line">f := <span class="number">3.141592653</span></span><br><span class="line">fmt.Println(f)          <span class="comment">// 3.141592653</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, f) <span class="comment">// 3.14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ptf这个类似于C语言里面的pitf函数。可以用%v来打印任意类型的变量，而不需要区分数字字符串。<br>也可以用%+V打印详细结果，%#V则更详细。</p><h1>JSON</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> userInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">Name  <span class="type">string</span></span><br><span class="line">Age   <span class="type">int</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">Hobby []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := userInfo&#123;Name: <span class="string">&quot;wang&quot;</span>, Age: <span class="number">18</span>, Hobby: []<span class="type">string</span>&#123;<span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;TypeScript&quot;</span>&#125;&#125;</span><br><span class="line">buf, err := json.Marshal(a)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(buf)         <span class="comment">// [123 34 78 97...]</span></span><br><span class="line">fmt.Println(<span class="type">string</span>(buf)) <span class="comment">// &#123;&quot;Name&quot;:&quot;wang&quot;,&quot;age&quot;:18,&quot;Hobby&quot;:[&quot;Golang&quot;,&quot;TypeScript&quot;]&#125;</span></span><br><span class="line"></span><br><span class="line">buf, err = json.MarshalIndent(a, <span class="string">&quot;&quot;</span>, <span class="string">&quot;\t&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="type">string</span>(buf))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b userInfo</span><br><span class="line">err = json.Unmarshal(buf, &amp;b)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, b) <span class="comment">// main.userInfo&#123;Name:&quot;wang&quot;, Age:18, Hobby:[]string&#123;&quot;Golang&quot;, &quot;TypeScript&quot;&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个已有的结构体只要保证每个字段的第一个字母是大写，也就是是公开字段。那么这个结构体就能用JSON.marshaler序列化，变成一个JSON的字符串。序列化之后的字符串也能够用JSON.unmarshaler去反序列化到一个空的变量里面。</p><p>这样默认序列化出来的字符串的话，它的风格是大写字母开头，而不是下划线。可以在后面用json tag等语法来去修改输出JSON结果里面的字段名。</p><h1>时间</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now) <span class="comment">// 2022-03-27 18:04:59.433297 +0800 CST m=+0.000087933</span></span><br><span class="line">t := time.Date(<span class="number">2022</span>, <span class="number">3</span>, <span class="number">27</span>, <span class="number">1</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">0</span>, time.UTC)</span><br><span class="line">t2 := time.Date(<span class="number">2022</span>, <span class="number">3</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">30</span>, <span class="number">36</span>, <span class="number">0</span>, time.UTC)</span><br><span class="line">fmt.Println(t)                                                  <span class="comment">// 2022-03-27 01:25:36 +0000 UTC</span></span><br><span class="line">fmt.Println(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute()) <span class="comment">// 2022 March 27 1 25</span></span><br><span class="line">fmt.Println(t.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))                    <span class="comment">// 2022-03-27 01:25:36</span></span><br><span class="line">diff := t2.Sub(t)</span><br><span class="line">fmt.Println(diff)                           <span class="comment">// 1h5m0s</span></span><br><span class="line">fmt.Println(diff.Minutes(), diff.Seconds()) <span class="comment">// 65 3900</span></span><br><span class="line">t3, err := time.Parse(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="string">&quot;2022-03-27 01:25:36&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(t3 == t)    <span class="comment">// true</span></span><br><span class="line">fmt.Println(now.Unix()) <span class="comment">// 1648738080</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最常用的就是time.now0来获取当前时间，也可以用time.date去构造一个带时区的时间，上面有很多方法来获取这个时间点的年月日小时分钟秒，也能用点Sub去对两个时间进行减法，得到一个时间段。时间段又可以去得到它有多少小时，多少分钟、多少秒。</p><p>在和某些系统交互的时候，我们经常会用到时间戳，可以用.UNX来获取时间戳。<code>time.format time.parse</code></p><h1>数字解析</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, _ := strconv.ParseFloat(<span class="string">&quot;1.234&quot;</span>, <span class="number">64</span>)</span><br><span class="line">fmt.Println(f) <span class="comment">// 1.234</span></span><br><span class="line"></span><br><span class="line">n, _ := strconv.ParseInt(<span class="string">&quot;111&quot;</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">fmt.Println(n) <span class="comment">// 111</span></span><br><span class="line"></span><br><span class="line">n, _ = strconv.ParseInt(<span class="string">&quot;0x1000&quot;</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">fmt.Println(n) <span class="comment">// 4096</span></span><br><span class="line"></span><br><span class="line">n2, _ := strconv.Atoi(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">fmt.Println(n2) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">n2, err := strconv.Atoi(<span class="string">&quot;AAA&quot;</span>)</span><br><span class="line">fmt.Println(n2, err) <span class="comment">// 0 strconv.Atoi: parsing &quot;AAA&quot;: invalid syntax</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串和数字类型之间的转换都在STR conv这个包下，是string convert这两个单词的缩写。</p><p>可以用<code>parselnt</code>或者<code>parseFloat</code>来解析一个字符串、<code>parseint</code>参数。</p><p>可以用<code>Atoi</code>把一个十进制字符串转成数字。可以用<code>itoA</code>把数字转成字符串。如果输入不合法，那么这些函数都会返回error。</p><h1>进程信息</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// go run example/20-env/main.go a b c d</span></span><br><span class="line">fmt.Println(os.Args)           <span class="comment">// [/var/folders/8p/n34xxfnx38dg8bv_x8l62t_m0000gn/T/go-build3406981276/b001/exe/main a b c d]</span></span><br><span class="line">fmt.Println(os.Getenv(<span class="string">&quot;PATH&quot;</span>)) <span class="comment">// /usr/local/go/bin...</span></span><br><span class="line">fmt.Println(os.Setenv(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>))</span><br><span class="line"></span><br><span class="line">buf, err := exec.Command(<span class="string">&quot;grep&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;/etc/hosts&quot;</span>).CombinedOutput()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="type">string</span>(buf)) <span class="comment">// 127.0.0.1       localhost</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>os.rgv</code>来得到程序执行的时候的指定的命令行参数。</p><p>比如编译的一个二进制文件，command。后面接<code>abcd</code>来启动，输出就是<code>os.argv</code>会是一个长度为5的slice，第一个成员代表二进制自身的名字。</p><p>可以用<code>so.getenv</code>来读取环境变量<code>exec</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB基本使用</title>
      <link href="/2024/07/14/shumo/%E3%80%8AMATLAB%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/07/14/shumo/%E3%80%8AMATLAB%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>向量</h1><h2 id="基础运算">基础运算</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">50</span>; <span class="comment">%冒号法：0-50相信间隔值组成的向量x,间隔值为0.1</span></span><br><span class="line">x=[<span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span>]<span class="comment">%行向量</span></span><br><span class="line">x=[<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>]<span class="comment">%列向量</span></span><br><span class="line">x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">6</span>)<span class="comment">%linspace(first_value,last_value,number)平均取值</span></span><br><span class="line">x=<span class="built_in">logspace</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>)<span class="comment">%logspace(first_value,last_value,number)从10^first_value-10^last_value,包含number个</span></span><br><span class="line"><span class="comment">%向量元素引用</span></span><br><span class="line">x(n)<span class="comment">%x中第x个元素</span></span><br><span class="line">x(n1:n2)<span class="comment">%x中n1-n2的元素</span></span><br><span class="line">.* <span class="comment">%点积运算</span></span><br><span class="line"><span class="built_in">cross</span>()<span class="comment">%叉积运算cross(a,b)a,b必为长为3的向量</span></span><br><span class="line">poly2sym(p)<span class="comment">%多项式构造</span></span><br><span class="line">conv(p1,p2)<span class="comment">%卷积运算，乘法运算</span></span><br><span class="line">[k,r]=deconv(p1,p2)<span class="comment">%除法运算,k-商,r-余数</span></span><br><span class="line">poly(root)<span class="comment">%求以root为解的多项式系数</span></span><br><span class="line">polyder(p)<span class="comment">%求p的导数的系数</span></span><br></pre></td></tr></table></figure><h2 id="特殊变量">特殊变量</h2><h3 id="单元型变量">单元型变量</h3><h4 id="赋值语句定义">赋值语句定义</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A=[<span class="number">1</span> <span class="number">2</span>;<span class="number">3</span> <span class="number">4</span>];</span><br><span class="line">B=<span class="number">3</span>+<span class="number">2</span>*<span class="built_in">i</span>;</span><br><span class="line">C=<span class="string">&#x27;efg&#x27;</span>;</span><br><span class="line">D=<span class="number">2</span>;</span><br><span class="line">E=&#123;A,B;C,D&#125;</span><br></pre></td></tr></table></figure><h4 id="对单元语句逐个赋值——cell">对单元语句逐个赋值——cell()</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">E=cell(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">E&#123;<span class="number">1</span>,<span class="number">1</span>&#125;=[<span class="number">1</span>:<span class="number">4</span>];</span><br><span class="line">E&#123;<span class="number">1</span>,<span class="number">2</span>&#125;=<span class="number">3</span>+<span class="number">2</span>*<span class="built_in">i</span>;</span><br><span class="line">E&#123;<span class="number">1</span>,<span class="number">3</span>&#125;=<span class="number">2</span>;</span><br><span class="line">E</span><br><span class="line">E&#123;<span class="number">1</span>&#125;</span><br><span class="line">E(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>cell(size(A)):生成与A相同形式的单元型置空矩阵</p></blockquote><h4 id="引用">引用</h4><ul><li>大括号显示单元具体的值</li><li>小括号显示单元压缩值</li></ul><h4 id="常用函数">常用函数</h4><p>1.celldisp()显示内容</p><p>2.cedllplot()用图形显示</p><h3 id="结构型变量">结构型变量</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mn=struct(<span class="string">&#x27;color&#x27;</span>,&#123;<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;black&#x27;</span>&#125;,<span class="string">&#x27;number&#x27;</span>,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)</span><br><span class="line">mn(<span class="number">1</span>)</span><br><span class="line">mn(<span class="number">2</span>) </span><br><span class="line">mn(<span class="number">2</span>).color</span><br></pre></td></tr></table></figure><h1>矩阵运算</h1><h2 id="矩阵生成">矩阵生成</h2><h3 id="利用M文件创建">利用M文件创建</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% sample.m</span></span><br><span class="line"><span class="comment">% 创建一个M文件，用以输入大规模矩阵</span></span><br><span class="line">gmatrix=[<span class="number">378</span> <span class="number">89</span> <span class="number">90</span>  <span class="number">83</span> <span class="number">382</span> <span class="number">92</span> <span class="number">29</span>;</span><br><span class="line"><span class="number">3829</span> <span class="number">32</span> <span class="number">9283</span> <span class="number">2938</span> <span class="number">378</span> <span class="number">839</span> <span class="number">29</span>;</span><br><span class="line"><span class="number">388</span> <span class="number">389</span> <span class="number">200</span> <span class="number">923</span> <span class="number">920</span> <span class="number">92</span> <span class="number">7478</span>;</span><br><span class="line"><span class="number">3829</span> <span class="number">892</span> <span class="number">66</span> <span class="number">89</span> <span class="number">90</span> <span class="number">56</span> <span class="number">8980</span>;</span><br><span class="line"><span class="number">7827</span> <span class="number">67</span> <span class="number">890</span> <span class="number">6557</span> <span class="number">45</span>  <span class="number">123</span> <span class="number">35</span>]</span><br></pre></td></tr></table></figure><h3 id="利用文本文件创建">利用文本文件创建</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load goods.txt</span><br><span class="line">goods</span><br></pre></td></tr></table></figure><h3 id="创建特殊矩阵">创建特殊矩阵</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">zeros</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">ones</span>(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">ones</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">rand</span>(<span class="number">3</span>)<span class="comment">%3*3随机数矩阵，值在(0,1)之间</span></span><br><span class="line"><span class="built_in">rand</span>(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">magic</span>(<span class="number">3</span>)<span class="comment">%3阶魔方矩阵</span></span><br><span class="line"><span class="built_in">hilb</span>(<span class="number">3</span>)<span class="comment">%3阶Hilbert矩阵</span></span><br><span class="line"><span class="built_in">invhilb</span>(<span class="number">3</span>)<span class="comment">%3阶Hilbert矩阵的逆</span></span><br></pre></td></tr></table></figure><h3 id="矩阵元素的运算">矩阵元素的运算</h3><h4 id="元素的修改">元素的修改</h4><ul><li>D=[A,B C],A- 原矩阵，B C-包含要扩充的元素，D-扩充后的矩阵</li><li>A=(m,),A的m行</li></ul><h4 id="矩阵的变维">矩阵的变维</h4><p>reshape(X,m,n)——将已知矩阵变成m行n列的矩阵</p><p>:法</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A=<span class="number">1</span>:<span class="number">12</span></span><br><span class="line">B=<span class="built_in">reshape</span>(A,<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line">C=<span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">4</span>); </span><br><span class="line">C(:)=A(:)</span><br></pre></td></tr></table></figure><h4 id="矩阵的变向">矩阵的变向</h4><ul><li>rot90(A):A逆时针旋转90°</li><li>rot90(A,k):A逆时针旋转90°*k</li><li>fliplr(X):X左右翻转</li><li>flipud(X):X上下翻转</li><li>flipdim(X,dim):dim=1——行翻转；dim=2——列翻转</li></ul><h4 id="矩阵的提取">矩阵的提取</h4><h2 id="矩阵数学运算">矩阵数学运算</h2><h3 id="加减法">加减法</h3><h3 id="乘法">乘法</h3><ul><li>叉乘：一行乘一列</li><li>点乘：相同位置的进行乘法运算</li></ul><h3 id="除法">除法</h3><ul><li>左除 B.\A：B的相应位置除A的相应位置</li><li>右除 B/A:A的相应位置除B的相应位置</li></ul><h2 id="基本运算">基本运算</h2><ul><li>幂函数 A.^2</li><li>逆 inv(X)</li><li>逆条件数 rcond(A)</li><li>逆的更新 updateinv(A)</li><li>2-范数 norm(A)</li><li>2-范数估计值 normest(A)</li><li>行列式 det(A)</li></ul><h2 id="矩阵分解">矩阵分解</h2><h3 id="楚列斯基分解-正定矩阵">楚列斯基分解(正定矩阵)</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">A=[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>;<span class="number">1</span> <span class="number">3</span> <span class="number">6</span> <span class="number">10</span>;<span class="number">1</span> <span class="number">4</span> <span class="number">10</span> <span class="number">20</span>];<span class="comment">%创建正定矩阵A</span></span><br><span class="line">R=chol(A)<span class="comment">%求正定矩阵A的楚列斯基分解因子</span></span><br><span class="line"></span><br><span class="line">R =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">3</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span></span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">4</span></span><br><span class="line">     <span class="number">1</span>     <span class="number">3</span>     <span class="number">6</span>    <span class="number">10</span></span><br><span class="line">     <span class="number">1</span>     <span class="number">4</span>    <span class="number">10</span>    <span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="LU分解-三角分解">LU分解(三角分解)</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">A=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>;<span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span>;<span class="number">7</span> <span class="number">8</span> <span class="number">5</span> <span class="number">6</span>];</span><br><span class="line">[L,U]=lu(A)<span class="comment">%返回下三角矩阵L，上三角矩阵U</span></span><br><span class="line"></span><br><span class="line">L =</span><br><span class="line"></span><br><span class="line">    <span class="number">0.1429</span>    <span class="number">1.0000</span>         <span class="number">0</span>         <span class="number">0</span></span><br><span class="line">    <span class="number">0.7143</span>    <span class="number">0.3333</span>    <span class="number">1.0000</span>         <span class="number">0</span></span><br><span class="line">    <span class="number">0.2857</span>    <span class="number">0.8333</span>    <span class="number">0.2500</span>    <span class="number">1.0000</span></span><br><span class="line">    <span class="number">1.0000</span>         <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">U =</span><br><span class="line"></span><br><span class="line">    <span class="number">7.0000</span>    <span class="number">8.0000</span>    <span class="number">5.0000</span>    <span class="number">6.0000</span></span><br><span class="line">         <span class="number">0</span>    <span class="number">0.8571</span>    <span class="number">2.2857</span>    <span class="number">3.1429</span></span><br><span class="line">         <span class="number">0</span>         <span class="number">0</span>    <span class="number">2.6667</span>    <span class="number">2.6667</span></span><br><span class="line">         <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>   <span class="number">-4.0000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">L =</span><br><span class="line"></span><br><span class="line">    <span class="number">1.0000</span>         <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span></span><br><span class="line">    <span class="number">0.1429</span>    <span class="number">1.0000</span>         <span class="number">0</span>         <span class="number">0</span></span><br><span class="line">    <span class="number">0.7143</span>    <span class="number">0.3333</span>    <span class="number">1.0000</span>         <span class="number">0</span></span><br><span class="line">    <span class="number">0.2857</span>    <span class="number">0.8333</span>    <span class="number">0.2500</span>    <span class="number">1.0000</span></span><br><span class="line"></span><br><span class="line">[L,U,P]=lu(A)<span class="comment">%返回下三角矩阵L，上三角矩阵U，置换矩阵P，PA=LU</span></span><br><span class="line">U =</span><br><span class="line"></span><br><span class="line">    <span class="number">7.0000</span>    <span class="number">8.0000</span>    <span class="number">5.0000</span>    <span class="number">6.0000</span></span><br><span class="line">         <span class="number">0</span>    <span class="number">0.8571</span>    <span class="number">2.2857</span>    <span class="number">3.1429</span></span><br><span class="line">         <span class="number">0</span>         <span class="number">0</span>    <span class="number">2.6667</span>    <span class="number">2.6667</span></span><br><span class="line">         <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>   <span class="number">-4.0000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">P =</span><br><span class="line"></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="LDM-T和-LDL-T分解"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mi>L</mi><mi>D</mi><mi>M</mi></mrow><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">{LDM}^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9146em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9146em;"><span style="top:-3.1362em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mi>L</mi><mi>D</mi><mi>L</mi></mrow><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">{LDL}^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9146em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">L</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9146em;"><span style="top:-3.1362em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>分解</h3><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mi>L</mi><mi>D</mi><mi>M</mi></mrow><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">{LDM}^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9146em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9146em;"><span style="top:-3.1362em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>分解</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[L,D,M]</span>=<span class="title">ldm</span><span class="params">(A)</span></span></span><br><span class="line"><span class="comment">%此函数用来求解矩阵A的LDM&#x27;分解</span></span><br><span class="line"><span class="comment">%其中L，M均为单位下三角矩阵，D为对角矩阵</span></span><br><span class="line">[m,n]=<span class="built_in">size</span>(A);</span><br><span class="line"><span class="keyword">if</span> m~=n</span><br><span class="line">    error(<span class="string">&#x27;输入矩阵不是方阵，请正确输入矩阵!&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">D(<span class="number">1</span>,<span class="number">1</span>)=A(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    L(<span class="built_in">i</span>,<span class="built_in">i</span>)=<span class="number">1</span>;</span><br><span class="line">    M(<span class="built_in">i</span>,<span class="built_in">i</span>)=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">L(<span class="number">2</span>:n,<span class="number">1</span>)=A(<span class="number">2</span>:n,<span class="number">1</span>)/D(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">M(<span class="number">2</span>:n,<span class="number">1</span>)=A(<span class="number">1</span>,<span class="number">2</span>:n)&#x27;/D(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">2</span>:n</span><br><span class="line">    v(<span class="number">1</span>)=A(<span class="number">1</span>,<span class="built_in">j</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">2</span>:<span class="built_in">j</span></span><br><span class="line">        v(<span class="built_in">i</span>)=A(<span class="built_in">i</span>,<span class="built_in">j</span>)-L(<span class="built_in">i</span>,<span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span>)*v(<span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span>)&#x27;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">j</span><span class="number">-1</span></span><br><span class="line">        M(<span class="built_in">j</span>,<span class="built_in">i</span>)=v(<span class="built_in">i</span>)/D(<span class="built_in">i</span>,<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    D(<span class="built_in">j</span>,<span class="built_in">j</span>)=v(<span class="built_in">j</span>);</span><br><span class="line">    L(<span class="built_in">j</span>+<span class="number">1</span>:n,<span class="built_in">j</span>)=(A(<span class="built_in">j</span>+<span class="number">1</span>:n,<span class="built_in">j</span>)-L(<span class="built_in">j</span>+<span class="number">1</span>:n,<span class="number">1</span>:<span class="built_in">j</span><span class="number">-1</span>)*v(<span class="number">1</span>:<span class="built_in">j</span><span class="number">-1</span>)&#x27;)/v(<span class="built_in">j</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>;<span class="number">4</span> <span class="number">6</span> <span class="number">10</span> <span class="number">2</span>;<span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">3</span>];</span><br><span class="line">[L,D,M]=ldm(A)</span><br><span class="line">L*D*M&#x27;</span><br></pre></td></tr></table></figure><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mi>L</mi><mi>D</mi><mi>L</mi></mrow><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">{LDL}^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9146em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">L</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9146em;"><span style="top:-3.1362em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>分解</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[L,D]</span>=<span class="title">ldlt</span><span class="params">(A)</span></span></span><br><span class="line"><span class="comment">%此函数用来求解实对称矩阵A的LDL&#x27;分解</span></span><br><span class="line"><span class="comment">%其中L为单位下三角矩阵，D为对角矩阵</span></span><br><span class="line"></span><br><span class="line">[m,n]=<span class="built_in">size</span>(A);</span><br><span class="line"><span class="keyword">if</span> m~=n | ~<span class="built_in">isequal</span>(A,A&#x27;)</span><br><span class="line">    error(<span class="string">&#x27;请正确输入矩阵!&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">D(<span class="number">1</span>,<span class="number">1</span>)=A(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    L(<span class="built_in">i</span>,<span class="built_in">i</span>)=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">L(<span class="number">2</span>:n,<span class="number">1</span>)=A(<span class="number">2</span>:n,<span class="number">1</span>)/D(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">2</span>:n</span><br><span class="line">    v(<span class="number">1</span>)=A(<span class="number">1</span>,<span class="built_in">j</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">j</span><span class="number">-1</span></span><br><span class="line">        v(<span class="built_in">i</span>)=L(<span class="built_in">j</span>,<span class="built_in">i</span>)*D(<span class="built_in">i</span>,<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    v(<span class="built_in">j</span>)=A(<span class="built_in">j</span>,<span class="built_in">j</span>)-L(<span class="built_in">j</span>,<span class="number">1</span>:<span class="built_in">j</span><span class="number">-1</span>)*v(<span class="number">1</span>:<span class="built_in">j</span><span class="number">-1</span>)&#x27;;</span><br><span class="line">    D(<span class="built_in">j</span>,<span class="built_in">j</span>)=v(<span class="built_in">j</span>);</span><br><span class="line">    L(<span class="built_in">j</span>+<span class="number">1</span>:n,<span class="built_in">j</span>)=(A(<span class="built_in">j</span>+<span class="number">1</span>:n,<span class="built_in">j</span>)-L(<span class="built_in">j</span>+<span class="number">1</span>:n,<span class="number">1</span>:<span class="built_in">j</span><span class="number">-1</span>)*v(<span class="number">1</span>:<span class="built_in">j</span><span class="number">-1</span>)&#x27;)/v(<span class="built_in">j</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>;<span class="number">2</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span>;<span class="number">3</span> <span class="number">7</span> <span class="number">6</span> <span class="number">9</span>;<span class="number">4</span> <span class="number">8</span> <span class="number">9</span> <span class="number">1</span>];</span><br><span class="line">[L,D]=ldlt(A)</span><br><span class="line">L*D*L&#x27;</span><br></pre></td></tr></table></figure><h3 id="QR分解-正交三角形分解">QR分解(正交三角形分解)</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">A=<span class="built_in">rand</span>(<span class="number">4</span>)</span><br><span class="line">[Q,R] =qr(A)</span><br><span class="line">A =</span><br><span class="line">    <span class="number">0.4218</span>    <span class="number">0.6557</span>    <span class="number">0.6787</span>    <span class="number">0.6555</span></span><br><span class="line">    <span class="number">0.9157</span>    <span class="number">0.0357</span>    <span class="number">0.7577</span>    <span class="number">0.1712</span></span><br><span class="line">    <span class="number">0.7922</span>    <span class="number">0.8491</span>    <span class="number">0.7431</span>    <span class="number">0.7060</span></span><br><span class="line">    <span class="number">0.9595</span>    <span class="number">0.9340</span>    <span class="number">0.3922</span>    <span class="number">0.0318</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Q =</span><br><span class="line">   <span class="number">-0.2634</span>    <span class="number">0.4305</span>    <span class="number">0.6535</span>    <span class="number">0.5641</span></span><br><span class="line">   <span class="number">-0.5718</span>   <span class="number">-0.7879</span>    <span class="number">0.2092</span>    <span class="number">0.0919</span></span><br><span class="line">   <span class="number">-0.4947</span>    <span class="number">0.3338</span>    <span class="number">0.2413</span>   <span class="number">-0.7653</span></span><br><span class="line">   <span class="number">-0.5991</span>    <span class="number">0.2871</span>   <span class="number">-0.6862</span>    <span class="number">0.2962</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R =</span><br><span class="line">   <span class="number">-1.6015</span>   <span class="number">-1.1728</span>   <span class="number">-1.2146</span>   <span class="number">-0.6389</span></span><br><span class="line">         <span class="number">0</span>    <span class="number">0.8058</span>    <span class="number">0.0559</span>    <span class="number">0.3921</span></span><br><span class="line">         <span class="number">0</span>         <span class="number">0</span>    <span class="number">0.5123</span>    <span class="number">0.6127</span></span><br><span class="line">         <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>   <span class="number">-0.1454</span></span><br></pre></td></tr></table></figure><p>qrdelete &amp; qrinsert</p><h3 id="SVD分解">SVD分解</h3><p>[U,S,V]=svd(A)</p><p>m*m矩阵U，对角矩阵S，n*n矩阵V</p><h3 id="舒尔分解">舒尔分解</h3><h3 id="海森伯格分解">海森伯格分解</h3><h1>二维绘图</h1><h2 id="plot">plot</h2><ul><li>plot(x,y)</li><li>subplot(m,n,p) m*n个视图区域，当前为第p个(按行排列)</li><li>tiledlayout(m,n)+nexttile</li><li>tiledlayout(2,2) 布局为2*2的区域</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">10</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y1=<span class="built_in">sin</span>(x);</span><br><span class="line">y2=<span class="built_in">cos</span>(x);</span><br><span class="line">y3=x;</span><br><span class="line">y4=x.^<span class="number">2</span>;<span class="comment">%输入以x为自变量的4个函数表达式</span></span><br><span class="line"><span class="built_in">hold</span> on<span class="comment">%在此画布上进行绘制</span></span><br><span class="line"><span class="built_in">plot</span>(x,y1,<span class="string">&#x27;r*&#x27;</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y2,<span class="string">&#x27;kp&#x27;</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y3,<span class="string">&#x27;bd&#x27;</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y4,<span class="string">&#x27;m--&#x27;</span>)</span><br><span class="line"><span class="built_in">hold</span> off</span><br></pre></td></tr></table></figure><ul><li>fplot 一元函数图像</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="built_in">linspace</span>(<span class="number">0.01</span>,<span class="number">0.02</span>,<span class="number">50</span>);</span><br><span class="line">y=<span class="built_in">sin</span>(<span class="number">1.</span>/x);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>),<span class="built_in">plot</span>(x,y)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>),fplot(@(x)<span class="built_in">sin</span>(<span class="number">1.</span>/x),[<span class="number">0.01</span>,<span class="number">0.02</span>])</span><br><span class="line"><span class="comment">%(x)sin(1./x)是定义的匿名函数。</span></span><br></pre></td></tr></table></figure><h2 id="不同坐标系下的绘图命令">不同坐标系下的绘图命令</h2><h3 id="极坐标系——polarplot">极坐标系——polarplot</h3><ul><li>polarplot(thera,rho) thera——弧度，rho——半径</li><li>polarplot(thera,rho,LineSpace)  LineSpace——样式</li><li>pol2cart(t,r) 极坐标下的数据点换到直角坐标系下</li></ul><h3 id="半对数坐标系——semilogx-semilogy">半对数坐标系——semilogx/semilogy</h3><h3 id="双对数坐标系——loglog">双对数坐标系——loglog</h3><h3 id="双y轴坐标——yyaxis">双y轴坐标——yyaxis</h3><ul><li>yyaxis left</li><li>yyaxis right</li></ul><h2 id="图形窗口">图形窗口</h2><ul><li>finger——创建图形窗口</li><li>set(n)——返回图像属性名称和所有属性值</li><li>get(n)——返回图像属性名称和当前属性值</li></ul><h1>图形标注</h1><h2 id="属性设置">属性设置</h2><h3 id="坐标系与坐标轴">坐标系与坐标轴</h3><p>axis(xmin,xmax,ymin,ymax,zmin,zmax)——设置坐标系</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t=<span class="number">0</span>:<span class="number">2</span>*<span class="built_in">pi</span>/<span class="number">99</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">x=<span class="number">1.15</span>*<span class="built_in">cos</span>(t);y=<span class="number">3.25</span>*<span class="built_in">sin</span>(t);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>),<span class="built_in">plot</span>(x,y),axis normal,grid on,</span><br><span class="line">title(<span class="string">&#x27;Normal and Grid on&#x27;</span>)<span class="comment">%grid on显示分割线</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>),<span class="built_in">plot</span>(x,y),axis equal,grid on,title(<span class="string">&#x27;Equal&#x27;</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>),<span class="built_in">plot</span>(x,y),axis square,grid on,title(<span class="string">&#x27;Square&#x27;</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),<span class="built_in">plot</span>(x,y),axis image,box off,title(<span class="string">&#x27;Image and Box off&#x27;</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>),<span class="built_in">plot</span>(x,y),axis image fill,box off</span><br><span class="line">title(<span class="string">&#x27;Image and Fill&#x27;</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>),<span class="built_in">plot</span>(x,y),axis tight,box off,title(<span class="string">&#x27;Tight&#x27;</span>)</span><br></pre></td></tr></table></figure><p>fill(X,Y,C) X,Y——创建的图形，C——颜色</p><p>title——标题</p><p>x/ylabel——轴注释</p><p>text(x,y,string)——在图中(x,y)位置显示string</p><p>gtext——鼠标在任意位置进行标注</p><p>legend——添加图例</p><h2 id="特殊图形">特殊图形</h2><h3 id="统计图形">统计图形</h3><ul><li>条形图<ul><li>二维：bar——竖直条形图；barh——水平条形图</li><li>三维：bar3——竖直条形图；bar3h——水平条形图</li></ul></li><li>面积图：area(Y)</li><li>饼图：pie/pie3</li><li>柱状图<ul><li>直角坐标系：histogram</li><li>极坐标系：ploarhistogram</li></ul></li></ul><h3 id="离散数据图形">离散数据图形</h3><ul><li>误差棒图：errorbar(y,err)</li><li>火柴杆图：stem(Y)</li><li>阶梯图：stairs(Y)</li></ul><h3 id="向量图形">向量图形</h3><ul><li><p>罗盘图：compass(U,V)</p></li><li><p>羽毛图：feather(U,V)</p></li><li><p>箭头图：quiver(U,V)/quiver3</p><p>返回数值梯度：gradient(Z,2,2)</p></li></ul><h1>三维绘图</h1><h2 id="绘图命令">绘图命令</h2><ul><li><p>plot3/fplot3</p></li><li><p>三维网格命令</p><ul><li>mesh(X,Y,Z) 网线面</li><li>mesh(X,Y) x-y为底，y对应的值为z轴</li><li>meshc 加基本等高线</li><li>meshz 网格线与零平面连起来</li><li>fmesh(f)</li></ul></li><li><p>三维曲面命令</p><ul><li>surf<ul><li>surfc 加基本等高线</li><li>surfl 有亮度的曲面</li></ul></li><li>fsurf</li></ul></li><li><p>柱面与球面</p><ul><li><p>[X,Y,Z]=cylinder 返回对应函数的x,y,z坐标值</p><p>cylinder(2,6) 正六边形，半径为2的棱柱</p></li><li><p>sphere 生成球面</p><p>[X,Y,Z]=cylinder(n) 绘制n*n个面的球面，返回球面坐标</p></li></ul></li><li><p>三维图形等值线</p><ul><li><p>contour3(x,y,z)</p></li><li><p>contourf 填充颜色的二维等值图</p><p>colormap gray 应用灰度颜色图</p></li><li><p>C=contourc(Z) 计算等值线矩阵C</p></li><li><p>clabel 在二维等值图中添加高度标签</p></li><li><p>fcontour 符号函数等值线图</p></li></ul></li></ul><h2 id="三维图形修饰处理">三维图形修饰处理</h2><h3 id="视角处理">视角处理</h3><p>view(az,el) az——方位角，el——仰角</p><h3 id="颜色处理">颜色处理</h3><ul><li><p>brighten(beat) 明暗处理0&lt;beat&lt;1</p></li><li><p>caxi([cmin,cmax]) 色轴刻度</p><p>colorbar 显示垂直色轴</p></li><li><p>shading 颜色渲染设置</p></li><li><p>colormap(M) 将M作为当前窗口颜色映像</p></li></ul><h3 id="光照处理">光照处理</h3><ul><li>surfl 带光照模式</li><li>light/lightangle 确定光源位置</li></ul><h2 id="图像处理">图像处理</h2><ul><li>imread 图像读入</li><li>imwrite 图像写入</li><li>image/imageesc/imshow 图像显示</li><li>imfinfo 图像信息查询</li></ul><h1>程序设计</h1><h2 id="M文件">M文件</h2><ul><li><p>命令文件</p></li><li><p>函数文件</p><p>function开始</p></li></ul><h2 id="程序设计">程序设计</h2><ul><li>程序结构<ul><li>顺序结构</li><li>循环结构</li><li>分支结构</li></ul></li><li>流程控制<ul><li>break</li><li>pause(10) 暂停10秒</li><li>continue</li><li>return</li><li>echo on 显示执行过程中每一行语句的执行过程</li><li>waring(massage) 不影响正常运行</li><li>error(massage) 终止运行</li></ul></li><li>交互式输入<ul><li>input(massage)</li><li>keyboard 暂停程序，使用键盘调用命令</li><li>menu</li></ul></li><li>程序调试<ul><li>系统提示</li><li>断点</li></ul></li></ul><h2 id="函数句柄">函数句柄</h2><p>1.创建</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun_handle=@save <span class="comment">%创建函数save()的句柄</span></span><br><span class="line"></span><br><span class="line">fun_handle =</span><br><span class="line">  包含以下值的 function_handle:</span><br><span class="line">    @save</span><br></pre></td></tr></table></figure><p>2.调用——feval()</p><h1>矩阵分析</h1><h2 id="特征值与特征向量">特征值与特征向量</h2><ul><li><p>[V,D]=eig(A,balanceOption) 求矩阵A的特征值和特征向量</p><p>balanceOption:默认平衡处理</p></li><li><p>[T,B]=balance(A) 求相似变换矩阵T，平衡矩阵B</p><p>[S,P,B]=balance(A) 缩放向量S，置换向量P</p></li><li><p>c=ploy(A) 求特征多项式</p></li><li><p>r=roots© 求特征多项式的根</p></li><li><p>eigs 部分特征值</p></li><li><p>eig(A,B) 求广义特征值</p></li></ul><h2 id="矩阵对角化">矩阵对角化</h2><p>判断矩阵能否对角化</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span>=<span class="title">isdiag1</span><span class="params">(A)</span></span></span><br><span class="line"><span class="comment">%该函数用来判断矩阵A是否可以对角化</span></span><br><span class="line"><span class="comment">%若返回值为1，则说明A可以对角化；若返回值为0，则说明A不可以对角化</span></span><br><span class="line"></span><br><span class="line">[m,n]=<span class="built_in">size</span>(A); <span class="comment">%求矩阵A的阶数</span></span><br><span class="line"><span class="keyword">if</span> m~=n<span class="comment">%若A不是方阵，则肯定不能对角化</span></span><br><span class="line">    y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    [V,D]=eig(A);</span><br><span class="line">    <span class="keyword">if</span> rank(V)==n <span class="comment">%判断A的特征向量是否线性无关</span></span><br><span class="line">        y=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>矩阵对角化</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span><span class="params">[P,D]</span>=<span class="title">reduce_diag</span><span class="params">(A)</span></span></span><br><span class="line"><span class="keyword">if</span> ~isdiag(A)</span><br><span class="line">error(<span class="string">&#x27;该矩阵不能对角化&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;将下面的矩阵P乘以任意非零整数所得矩阵仍满足inv(P)*P*A=D&#x27;</span>);</span><br><span class="line">[P,D]=eig(A);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="若尔当标准型">若尔当标准型</h2><p>[P,J]=jordam(A) 若尔当标准形矩阵J，相似变换矩阵P</p><h2 id="矩阵的反射与旋转变换">矩阵的反射与旋转变换</h2><h3 id="豪斯霍尔德反射波变换">豪斯霍尔德反射波变换</h3><p>避免上溢求豪斯霍尔德向量函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[v,beta]</span>=<span class="title">house</span><span class="params">(x)</span></span></span><br><span class="line"><span class="comment">%此函数用来计算满足v(1)=1的v和beta使得P=I-beta*v*v&#x27;</span></span><br><span class="line"><span class="comment">%是正交矩阵且P*x=norm(x)*e1</span></span><br><span class="line"></span><br><span class="line">n=<span class="built_in">length</span>(x);</span><br><span class="line"><span class="keyword">if</span> n==<span class="number">1</span></span><br><span class="line">    error(<span class="string">&#x27;请正确输入向量!&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    sigma=x(<span class="number">2</span>:n)&#x27;*x(<span class="number">2</span>:n);</span><br><span class="line">    v=[<span class="number">1</span>;x(<span class="number">2</span>:n)];</span><br><span class="line">    <span class="keyword">if</span> sigma==<span class="number">0</span></span><br><span class="line">        <span class="built_in">beta</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        mu=<span class="built_in">sqrt</span>(x(<span class="number">1</span>)^<span class="number">2</span>+sigma);</span><br><span class="line">        <span class="keyword">if</span> x(<span class="number">1</span>)&lt;=<span class="number">0</span></span><br><span class="line">            v(<span class="number">1</span>)=x(<span class="number">1</span>)-mu;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v(<span class="number">1</span>)=-sigma/(x(<span class="number">1</span>)+mu);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">beta</span>=<span class="number">2</span>*v(<span class="number">1</span>)^<span class="number">2</span>/(sigma+v(<span class="number">1</span>)^<span class="number">2</span>);</span><br><span class="line">        v=v/v(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>豪斯霍尔德矩阵求法</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]&#x27;;</span><br><span class="line">[v,<span class="built_in">beta</span>]=house(x)</span><br><span class="line">P=<span class="built_in">eye</span>(<span class="number">3</span>)-<span class="built_in">beta</span>*v*v&#x27; </span><br><span class="line">a=norm(x)</span><br><span class="line">P*x </span><br></pre></td></tr></table></figure><h3 id="吉文斯旋转变换">吉文斯旋转变换</h3><p>[G,y]=planerot(x) y=Gx且y(2)=0,x——二维列向量</p><h1>符号运算</h1><h2 id="符号与数值">符号与数值</h2><ul><li>eval(expression) 符号-&gt;数值</li><li>subs(s) 数值-&gt;符号</li><li>digits(D) 有效数字个数为D</li><li>vpa(x) 算数精度</li><li>B=sparse(A) 将A转换为稀疏格式</li><li>B=sparse(A) 创建A的伴随矩阵</li></ul><h2 id="符号矩阵">符号矩阵</h2><h3 id="创建">创建</h3><ul><li><p>直接输入</p></li><li><p>sym(‘x’) sym(‘a’,n)</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">x = sym(<span class="string">&#x27;x&#x27;</span>); </span><br><span class="line">y = sym(<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">a=[x+y,x;y,y+<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">a = sym(<span class="string">&#x27;a&#x27;</span>, [<span class="number">1</span> <span class="number">4</span>])<span class="comment">%用自动生成的元素创建符号向量</span></span><br><span class="line">a = sym(<span class="string">&#x27;x_%d&#x27;</span>, [<span class="number">1</span> <span class="number">4</span>])</span><br><span class="line"> </span><br><span class="line">a(<span class="number">1</span>)</span><br><span class="line">a(<span class="number">2</span>:<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">a = </span><br><span class="line">[a1, a2, a3, a4]</span><br><span class="line">a =</span><br><span class="line">[x_1, x_2, x_3, x_4]</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">x_1</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">[x_2, x_3]</span><br></pre></td></tr></table></figure></li><li><p>数值矩阵-&gt;符号矩阵</p><p>B=sym(A)</p></li></ul><p>计算不同精度的pi值</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pi</span><span class="comment">%默认精度</span></span><br><span class="line">vpa(<span class="built_in">pi</span>)<span class="comment">%使用可变精度，32位数字</span></span><br><span class="line"></span><br><span class="line">digits(<span class="number">10</span>)<span class="comment">%将vpa精度设成10</span></span><br><span class="line">vpa(<span class="built_in">pi</span>)<span class="comment">%10位有效数字</span></span><br><span class="line"> </span><br><span class="line">r = sym(<span class="built_in">pi</span>)</span><br><span class="line">f = sym(<span class="built_in">pi</span>,<span class="string">&#x27;f&#x27;</span>)<span class="comment">%返回精确的有理数 </span></span><br><span class="line">d = sym(<span class="built_in">pi</span>,<span class="string">&#x27;d&#x27;</span>)<span class="comment">%使用十进制模式将浮点数转换为符号数字</span></span><br><span class="line">e = sym(<span class="built_in">pi</span>,<span class="string">&#x27;e&#x27;</span>)<span class="comment">%使用误差估值模式将浮点数转换为符号数字</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =<span class="number">3.1416</span></span><br><span class="line"><span class="built_in">ans</span> =<span class="number">3.141592654</span> </span><br><span class="line"><span class="built_in">ans</span> =<span class="number">3.141592654</span></span><br><span class="line">r =<span class="built_in">pi</span></span><br><span class="line">f =<span class="number">884279719003555</span>/<span class="number">281474976710656</span></span><br><span class="line">d =<span class="number">3.141592654</span></span><br><span class="line">e =<span class="built_in">pi</span> - (<span class="number">198</span>*<span class="built_in">eps</span>)/<span class="number">359</span></span><br></pre></td></tr></table></figure><h3 id="其他运算">其他运算</h3><ul><li>转置<ul><li>B=A.’</li><li>B=transpose(A)</li></ul></li><li>行列式运算 d=det(A)</li><li>逆 inv(A)</li><li>求秩 rank(A)</li><li>特征值，特征向量 eig()</li><li>奇异值 svd()</li><li>若尔当标准型 jordan()</li></ul><h3 id="符号多项式简化">符号多项式简化</h3><ul><li><p>因式分解 factor(x) 返回x的所有不可约因子</p></li><li><p>符号矩阵的展开 expand(S)</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">syms x y</span><br><span class="line">expand((x+<span class="number">3</span>)^<span class="number">4</span>)</span><br><span class="line">expand(<span class="built_in">cos</span>(x+y))</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> = x^<span class="number">4</span> + <span class="number">12</span>*x^<span class="number">3</span> + <span class="number">54</span>*x^<span class="number">2</span> + <span class="number">108</span>*x + <span class="number">81</span></span><br><span class="line"><span class="built_in">ans</span> = <span class="built_in">cos</span>(x)*<span class="built_in">cos</span>(y) - <span class="built_in">sin</span>(x)*<span class="built_in">sin</span>(y)</span><br></pre></td></tr></table></figure></li><li><p>符号简化 simplify</p></li><li><p>分式通分 [n,d]=numden(A) 表达式分子n,分母d</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">syms x y</span><br><span class="line">[n,d]=numden(x/y-y/x+x.^<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">n = x^<span class="number">3</span>*y + x^<span class="number">2</span> - y^<span class="number">2</span></span><br><span class="line">d = x*y</span><br></pre></td></tr></table></figure></li><li><p>“秦九韶型”重写 horner(p)</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syms x</span><br><span class="line">horner(x^<span class="number">4</span><span class="number">-3</span>*x^<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =x^<span class="number">2</span>*(x^<span class="number">2</span> - <span class="number">3</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h1>数列与极限</h1><h2 id="数列">数列</h2><h3 id="数列求和">数列求和</h3><ul><li>sum(A,dim)<ul><li>向量——所有元素和 dim=1：不求和；dim=2：求和</li><li>矩阵——每一列元素和 dim=1：列求和，行显示；dim=2：行求和，列显示</li><li>sum(·，nanflag) nanflag=includenan——计算NaN,nanflag=omitnan——计算NaN,</li></ul></li><li>nansum(A) 忽略NaN累计求和函数</li><li>cumsum(A) 求此元素之前的元素和函数</li><li>cumtrapz(Y) 求梯形累计和函数(积分)</li></ul><h3 id="数列求积">数列求积</h3><ul><li><p>元素连续相乘函数 B=prod(A)</p><p>矩阵：按列向量的所有元素的积</p></li><li><p>求累计积函数 B=cumprod(A)</p></li><li><p>阶乘函数 f=factorial(n)</p></li><li><p>伽马函数(非整数的阶乘) gamma()</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">factorial</span>(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">   <span class="number">720</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="built_in">gamma</span>(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">   <span class="number">120</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="number">6</span>*<span class="built_in">gamma</span>(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">   <span class="number">720</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="极限和导数">极限和导数</h2><h3 id="极限">极限</h3><ul><li><p>x-&gt;0</p><p>limit(f)</p></li><li><p>x-&gt;∞</p><p>limit(f,inf,’right’) right:右极限</p></li></ul><h3 id="导数">导数</h3><ul><li>diff(f,n) 求函数f的n阶导数</li><li>diff(f,x) 求函数f对x的导数</li></ul><h2 id="级数求和">级数求和</h2><ul><li>有限项级数求和 symsum(f,k,a,b) 计算级数f关于指数k从a到b的有限项和</li><li>无穷级数求和 将b改为inf</li></ul><h1>积分</h1><h2 id="积分">积分</h2><ul><li>定积分和广义积分 int(f,x,a,b)</li><li>不定积分 int(f,x)</li></ul><h2 id="多重积分">多重积分</h2><ul><li><p>二重积分 intergral2(fun,xmin,xmax,ymin,ymax)</p><p>fzero(‘2*x-0.5*x’,0) 求f1-f2=0，即f1,f2的交点</p></li></ul><h2 id="泰勒展开">泰勒展开</h2><p>taylor(f,m,a)</p><p>taylor(f,’order’,5) 五阶麦克劳林型近似展开</p><h2 id="傅里叶展开">傅里叶展开</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[a0,an,bn]</span>=<span class="title">Fourierzpi</span><span class="params">(f)</span></span></span><br><span class="line">syms x n</span><br><span class="line">a0=int(f,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>)/<span class="built_in">pi</span>;</span><br><span class="line">an=int(f*<span class="built_in">cos</span>(n*x),<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>)/<span class="built_in">pi</span>;</span><br><span class="line">bn=int(f*<span class="built_in">sin</span>(n*x),<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>)/<span class="built_in">pi</span>;</span><br></pre></td></tr></table></figure><h2 id="积分变换">积分变换</h2><ul><li>傅里叶积分变换 fourier(f,u,v)</li><li>傅里叶逆变换 ifourier(F,v,u)</li><li>快速傅里叶变换</li><li>拉普拉斯变换 laplace(F,w,z)</li><li>拉普拉斯逆变换 ilaplace(L,x,y)</li></ul><h1>方程求解</h1><h2 id="线性方程组求解">线性方程组求解</h2><h3 id="判断线性方程组的解">判断线性方程组的解</h3><p>Z=null(A) 求矩阵A的核空间矩阵Z，Z的列向量是Ax=0的基础解系，满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Z</mi><mi>T</mi></msup><mi>Z</mi><mo>=</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">Z^TZ=I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></p><p>Z=null(A,’r’) Z的列向量是Ax=0的有理基，Z不满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Z</mi><mi>T</mi></msup><mi>Z</mi><mo>=</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">Z^TZ=I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></p><blockquote><p>判断线性方程组Ax=b的解的存在性</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span>=<span class="title">isexist</span><span class="params">(A,b)</span></span></span><br><span class="line"><span class="comment">%该函数用来判断线性方程组Ax=b的解的存在性</span></span><br><span class="line"><span class="comment">%若方程组无解则返回0，若有唯一解则返回1，若有无穷多解则返回Inf</span></span><br><span class="line">[m,n]=<span class="built_in">size</span>(A);</span><br><span class="line">[mb,nb]=<span class="built_in">size</span>(b);</span><br><span class="line"><span class="keyword">if</span> m~=mb</span><br><span class="line">    error(<span class="string">&#x27;输入有误!&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">r=rank(A);</span><br><span class="line">s=rank([A,b]);</span><br><span class="line"><span class="keyword">if</span> r==s&amp;r==n</span><br><span class="line">    y=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">elseif</span> r==s&amp;r&lt;n</span><br><span class="line">    y=Inf;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="利用矩阵的逆-伪逆-与除法求解">利用矩阵的逆(伪逆)与除法求解</h3><p>Ax=b</p><ul><li>为恰定方程组且A是非奇异的,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><msup><mi>A</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>b</mi></mrow><annotation encoding="application/x-tex">x=A^{-1}b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">b</span></span></span></span></li><li>不为为恰定方程组或A奇异，x=A\b</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">format <span class="built_in">rat</span></span><br><span class="line">A=[<span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">1</span> <span class="number">-2</span> <span class="number">-2</span>;<span class="number">1</span> <span class="number">3</span> <span class="number">0</span> <span class="number">-2</span>];</span><br><span class="line">b=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]&#x27;;</span><br><span class="line">x0=pinv(A)*b <span class="comment">%利用伪逆求一个特解</span></span><br><span class="line">Z=null(A,<span class="string">&#x27;r&#x27;</span>)<span class="comment">%求基础解系</span></span><br><span class="line">format</span><br><span class="line"></span><br><span class="line">x0 =</span><br><span class="line">      <span class="number">13</span>/<span class="number">77</span>    </span><br><span class="line">      <span class="number">46</span>/<span class="number">77</span>    </span><br><span class="line">      <span class="number">-2</span>/<span class="number">11</span>    </span><br><span class="line">     <span class="number">-40</span>/<span class="number">77</span>    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Z =</span><br><span class="line">      <span class="number">-6</span>             <span class="number">-4</span>       </span><br><span class="line">       <span class="number">2</span>              <span class="number">2</span>       </span><br><span class="line">       <span class="number">1</span>              <span class="number">0</span>       </span><br><span class="line">       <span class="number">0</span>              <span class="number">1</span>   </span><br></pre></td></tr></table></figure><h3 id="利用行阶梯型求解">利用行阶梯型求解</h3><p>只适用于恰定方程组，且系数矩阵非奇异</p><p>矩阵-&gt;行阶梯型 [R,jb]=rref(A) jb:非零主元列</p><h3 id="利用矩阵分解法求解">利用矩阵分解法求解</h3><ul><li><p>LU分解法</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>=<span class="title">solvebyLU</span><span class="params">(A,b)</span></span></span><br><span class="line"><span class="comment">%该函数利用LU分解法求线性方程组Ax=b的解</span></span><br><span class="line">flag=isexist(A,b);<span class="comment">%调用函数isexist()判断方程组解的情况</span></span><br><span class="line"><span class="keyword">if</span> flag==<span class="number">0</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;该方程组无解!&#x27;</span>);</span><br><span class="line">    x=[];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    r=rank(A);</span><br><span class="line">    [m,n]=<span class="built_in">size</span>(A);</span><br><span class="line">    [L,U,P]=lu(A);</span><br><span class="line">    b=P*b;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">%解Ly=b</span></span><br><span class="line">    y(<span class="number">1</span>)=b(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> m&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">2</span>:m</span><br><span class="line">            y(<span class="built_in">i</span>)=b(<span class="built_in">i</span>)-L(<span class="built_in">i</span>,<span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span>)*y(<span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span>)&#x27;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    y=y&#x27;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">%解Ux=y得原方程组的一个特解</span></span><br><span class="line">    x0(r)=y(r)/U(r,r);</span><br><span class="line">    <span class="keyword">if</span> r&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span>=r<span class="number">-1</span>:<span class="number">-1</span>:<span class="number">1</span></span><br><span class="line">            x0(<span class="built_in">i</span>)=(y(<span class="built_in">i</span>)-U(<span class="built_in">i</span>,<span class="built_in">i</span>+<span class="number">1</span>:r)*x0(<span class="built_in">i</span>+<span class="number">1</span>:r)&#x27;)/U(<span class="built_in">i</span>,<span class="built_in">i</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    x0=x0&#x27;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> flag==<span class="number">1</span><span class="comment">%若方程组有唯一解</span></span><br><span class="line">        x=x0;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">%若方程组有无穷多解</span></span><br><span class="line">        format <span class="built_in">rat</span>;</span><br><span class="line">        Z=null(A,<span class="string">&#x27;r&#x27;</span>);<span class="comment">%求出对应齐次方程组的基础解系</span></span><br><span class="line">        [mZ,nZ]=<span class="built_in">size</span>(Z);</span><br><span class="line">        x0(r+<span class="number">1</span>:n)=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:nZ</span><br><span class="line">            t=sym(char([<span class="number">107</span> <span class="number">48</span>+<span class="built_in">i</span>]));</span><br><span class="line">            k(<span class="built_in">i</span>)=t;<span class="comment">%取k=[k1,k2,…]; </span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        x=x0;         </span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:nZ          </span><br><span class="line">            x=x+k(<span class="built_in">i</span>)*Z(:,<span class="built_in">i</span>); <span class="comment">%将方程组的通解表示为特解加对应齐次通解形式</span></span><br><span class="line">        <span class="keyword">end</span>        </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">format<span class="comment">%恢复数据显示格式</span></span><br></pre></td></tr></table></figure></li><li><p>QR分解法</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>=<span class="title">solvebyQR</span><span class="params">(A,b)</span></span></span><br><span class="line"><span class="comment">%该函数利用QR分解法求线性方程组Ax=b的解</span></span><br><span class="line">flag=isexist(A,b);<span class="comment">%调用函数isexist()判断方程组解的情况</span></span><br><span class="line"><span class="keyword">if</span> flag==<span class="number">0</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;该方程组无解!&#x27;</span>);</span><br><span class="line">    x=[];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    r=rank(A);</span><br><span class="line">    [m,n]=<span class="built_in">size</span>(A);</span><br><span class="line">    [Q,R]=qr(A);</span><br><span class="line">    b=Q&#x27;*b;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">%解Rx=b得原方程组的一个特解</span></span><br><span class="line">    x0(r)=b(r)/R(r,r);</span><br><span class="line">    <span class="keyword">if</span> r&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span>=r<span class="number">-1</span>:<span class="number">-1</span>:<span class="number">1</span></span><br><span class="line">            x0(<span class="built_in">i</span>)=(b(<span class="built_in">i</span>)-R(<span class="built_in">i</span>,<span class="built_in">i</span>+<span class="number">1</span>:r)*x0(<span class="built_in">i</span>+<span class="number">1</span>:r)&#x27;)/R(<span class="built_in">i</span>,<span class="built_in">i</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    x0=x0&#x27;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> flag==<span class="number">1</span> <span class="comment">%若方程组有唯一解</span></span><br><span class="line">        x=x0;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">%若方程组有无穷多解</span></span><br><span class="line">        format <span class="built_in">rat</span>;</span><br><span class="line">        Z=null(A,<span class="string">&#x27;r&#x27;</span>);<span class="comment">%求出对应齐次方程组的基础解系</span></span><br><span class="line">        [mZ,nZ]=<span class="built_in">size</span>(Z);</span><br><span class="line">        x0(r+<span class="number">1</span>:n)=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:nZ</span><br><span class="line">            t=sym(char([<span class="number">107</span> <span class="number">48</span>+<span class="built_in">i</span>]));</span><br><span class="line">            k(<span class="built_in">i</span>)=t;<span class="comment">%取k=[k1,…,kr]; </span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        x=x0;         </span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:nZ          </span><br><span class="line">            x=x+k(<span class="built_in">i</span>)*Z(:,<span class="built_in">i</span>);<span class="comment">%将方程组的通解表示为特解加对应齐次通解形式</span></span><br><span class="line">        <span class="keyword">end</span>        </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">format<span class="comment">%恢复数据显示格式</span></span><br></pre></td></tr></table></figure></li><li><p>楚列斯基分解法</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>=<span class="title">solvebyCHOL</span><span class="params">(A,b)</span></span></span><br><span class="line"><span class="comment">%该函数利用楚列斯基分解法求线性方程组Ax=b的解</span></span><br><span class="line">lambda=eig(A);</span><br><span class="line"><span class="keyword">if</span> lambda&gt;<span class="built_in">eps</span>&amp;<span class="built_in">isequal</span>(A,A&#x27;)</span><br><span class="line">    [n,n]=<span class="built_in">size</span>(A);</span><br><span class="line">    R=chol(A);</span><br><span class="line">    <span class="comment">%解R&#x27;y=b</span></span><br><span class="line">    y(<span class="number">1</span>)=b(<span class="number">1</span>)/R(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> n&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">2</span>:n</span><br><span class="line">            y(<span class="built_in">i</span>)=(b(<span class="built_in">i</span>)-R(<span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span>,<span class="built_in">i</span>)&#x27;*y(<span class="number">1</span>:<span class="built_in">i</span><span class="number">-1</span>)&#x27;)/R(<span class="built_in">i</span>,<span class="built_in">i</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%解Rx=y</span></span><br><span class="line">    x(n)=y(n)/R(n,n);</span><br><span class="line">    <span class="keyword">if</span> n&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span>=n<span class="number">-1</span>:<span class="number">-1</span>:<span class="number">1</span></span><br><span class="line">            x(<span class="built_in">i</span>)=(y(<span class="built_in">i</span>)-R(<span class="built_in">i</span>,<span class="built_in">i</span>+<span class="number">1</span>:n)*x(<span class="built_in">i</span>+<span class="number">1</span>:n)&#x27;)/R(<span class="built_in">i</span>,<span class="built_in">i</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    x=x&#x27;;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    x=[];</span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;该方法只适用于对称正定的系数矩阵!&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>  </span><br></pre></td></tr></table></figure></li></ul><h3 id="非负最小二乘解">非负最小二乘解</h3><p>lsqnonneg(A,b)</p><h2 id="方程与方程组的优化解">方程与方程组的优化解</h2><ul><li>非线性方程基本函数<ul><li>x=fzero(fun,x0)</li><li>x=fzero(fun,x0,options)</li><li>x=fzero(problem)</li><li>[x,fval,exitflag,output]=fzero(···)</li></ul></li><li>非线性方程组基本函数<ul><li>x=fslove(fun,x0)</li><li>x=fslove(fun,x0,options)</li><li>x=fslove(problem)</li><li>[x,fval,exitflag,output,jacobian]=fslove(···)</li></ul></li></ul><h1>微分方程</h1><h2 id="微分方程">微分方程</h2><p>S=desolve(eqn,cond,Name,Value)</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">syms x(t) y(t)</span><br><span class="line">eqns=[diff(x,t)==y,diff(y,t)==-x];</span><br><span class="line">S=dsolve(eqns)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;微分方程的解&#x27;</span>,blanks(<span class="number">2</span>),<span class="string">&#x27;x&#x27;</span>,blanks(<span class="number">22</span>),<span class="string">&#x27;y&#x27;</span>])</span><br><span class="line"><span class="built_in">disp</span>([S.x,S.y])<span class="comment">%显示方程的解</span></span><br></pre></td></tr></table></figure><h2 id="常微分方程的数值解法">常微分方程的数值解法</h2><h3 id="欧拉方法">欧拉方法</h3><p>根据欧拉公式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>y</mi><mi>n</mi></msub><mo>+</mo><mi>h</mi><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y_{n+1}=y_n+hf(x_n,y_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[x,y]</span>=<span class="title">euler</span><span class="params">(f,x0,y0,xf,h)</span></span></span><br><span class="line">n=<span class="built_in">fix</span>((xf-x0)/h);</span><br><span class="line">y(<span class="number">1</span>)=y0;</span><br><span class="line">x(<span class="number">1</span>)=x0;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    x(<span class="built_in">i</span>+<span class="number">1</span>)=x0+<span class="built_in">i</span>*h;</span><br><span class="line">    y(<span class="built_in">i</span>+<span class="number">1</span>)=y(<span class="built_in">i</span>)+h*feval(f,x(<span class="built_in">i</span>),y(<span class="built_in">i</span>));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>改进的欧拉公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><msub><mi>y</mi><mi>p</mi></msub><mo>=</mo><msub><mi>y</mi><mi>n</mi></msub><mo>+</mo><mi>h</mi><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><msub><mi>y</mi><mi>c</mi></msub><mo>=</mo><msub><mi>y</mi><mi>n</mi></msub><mo>+</mo><mi>h</mi><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><msub><mi>y</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><msub><mi>y</mi><mi>p</mi></msub><mo>+</mo><msub><mi>y</mi><mi>c</mi></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}&amp;y_p=y_n+hf(x_n,y_n) \\&amp;y_c=y_n+hf(x_{n+1},y_n) \\&amp;y_{n+1}=\frac{1}{2}(y_{p}+y_{c})\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.3074em;vertical-align:-2.4037em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9037em;"><span style="top:-5.3852em;"><span class="pstrut" style="height:3.3214em;"></span><span class="mord"></span></span><span style="top:-3.8852em;"><span class="pstrut" style="height:3.3214em;"></span><span class="mord"></span></span><span style="top:-1.9037em;"><span class="pstrut" style="height:3.3214em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4037em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9037em;"><span style="top:-5.3852em;"><span class="pstrut" style="height:3.3214em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.8852em;"><span class="pstrut" style="height:3.3214em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-1.9037em;"><span class="pstrut" style="height:3.3214em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4037em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[x,y]</span>=<span class="title">adeuler</span><span class="params">(f,x0,y0,xf,h)</span></span></span><br><span class="line">n=<span class="built_in">fix</span>((xf-x0)/h);</span><br><span class="line">x(<span class="number">1</span>)=x0;</span><br><span class="line">y(<span class="number">1</span>)=y0;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    x(<span class="built_in">i</span>+<span class="number">1</span>)=x0+h*<span class="built_in">i</span>;</span><br><span class="line">    yp=y(<span class="built_in">i</span>)+h*feval(f,x(<span class="built_in">i</span>),y(<span class="built_in">i</span>));</span><br><span class="line">    yc=y(<span class="built_in">i</span>)+h*feval(f,x(<span class="built_in">i</span>+<span class="number">1</span>),yp);</span><br><span class="line">    y(<span class="built_in">i</span>+<span class="number">1</span>)=(yp+yc)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="龙格-库塔方法">龙格-库塔方法</h3><ul><li><p>非刚性</p><ul><li>ode23 二、三阶R-K函数</li><li>ode45 四、五阶R-K函数</li><li>ode113</li></ul></li><li><p>刚性</p><ul><li>ode15s 多步法</li><li>ode23s 单步法</li><li>ode23t 难度适中</li><li>ode23tb 较难</li></ul></li><li><p>完全隐式 ode15i</p></li></ul><h2 id="偏微分方程-PDE">偏微分方程 PDE</h2><p>[PDE工具箱使用](<a href="https://blog.csdn.net/lusongno1/article/details/84097005">matlab的PDE工具箱的简单使用_matlab pde-CSDN博客</a>)</p><h3 id="区域设置及网格化">区域设置及网格化</h3><ul><li><p>创建偏微分方程定义的区域 文件名：pdegeom</p><ul><li><p>ne=pdegeom</p><p>ne——几何区域边界的线段数</p></li><li><p>d=pdegeom(bs)</p><p>d——一个区域边界数据的矩阵</p></li><li><p>[x,y]=pdegeom(bs,s)</p><p>bs——指定的边界线段</p><p>s——相应线段弧长的近似值</p></li></ul></li><li><p>网格化</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">model = createpde;</span><br><span class="line">geometryFromEdges(model,@cardg);<span class="comment">%根据自定义函数的几何形状创建模型对象的几何图形</span></span><br><span class="line">mesh=generateMesh(model);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>),pdemesh(model)</span><br><span class="line">title(<span class="string">&#x27;初始网格图&#x27;</span>)</span><br><span class="line">mesh=generateMesh(model,<span class="string">&#x27;Hmax&#x27;</span>,<span class="number">2</span>);  </span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),pdemesh(model)</span><br><span class="line">title(<span class="string">&#x27;修改网格边界最大值&#x27;</span>)</span><br><span class="line">mesh=generateMesh(model,<span class="string">&#x27;Hmin&#x27;</span>,<span class="number">2</span>); </span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>),pdemesh(model),title(<span class="string">&#x27;修改网格边界最小值&#x27;</span>) </span><br><span class="line">mesh=generateMesh(model,<span class="string">&#x27;GeometricOrder&#x27;</span>,<span class="string">&#x27;linear&#x27;</span>,<span class="string">&#x27;Hgrad&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>),pdemesh(model)</span><br><span class="line">title(<span class="string">&#x27;修改网格几何秩序和增长率&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="边界条件设置">边界条件设置</h3><p>M文件名：pdebound</p><p>调用格式：[q,g,h,r]=pdebound(p,e,u,time)</p><p>e——边界</p><p>工具箱自带文件squareb3,m 区域为单位正方形</p><h3 id="PDE函数求解">PDE函数求解</h3><p>result=solvepde(model) 稳态</p><p>result=solvepde(model,tlist) 时间相关</p><blockquote><p>lplsfc.m</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">model = createpde(); </span><br><span class="line">geometryFromEdges(model,@cirsg);<span class="comment">%cirsg自带的</span></span><br><span class="line">specifyCoefficients(model,<span class="string">&#x27;m&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;c&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;f&#x27;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">%方程系数</span></span><br><span class="line">rfun=@(location,state) </span><br><span class="line"><span class="comment">%初始条件</span></span><br><span class="line"><span class="built_in">cos</span>(<span class="number">2</span>/<span class="number">3</span>*<span class="built_in">atan2</span>(location.y,location.x));</span><br><span class="line">applyBoundaryCondition(model,<span class="string">&#x27;dirichlet&#x27;</span>,<span class="string">&#x27;Edge&#x27;</span>,...</span><br><span class="line"><span class="number">1</span>:model.Geometry.NumEdges,<span class="string">&#x27;r&#x27;</span>,rfun,<span class="string">&#x27;h&#x27;</span>,<span class="number">1</span>);<span class="comment">%在所有边缘设置狄利克雷条件</span></span><br><span class="line">generateMesh(model,<span class="string">&#x27;Hmax&#x27;</span>,<span class="number">0.25</span>); <span class="comment">%设置最大边界尺寸，生成模型网络</span></span><br><span class="line">results=solvepde(model);</span><br><span class="line">u=results.NodalSolution;</span><br><span class="line">pdeplot(model,<span class="string">&#x27;XYData&#x27;</span>,u,<span class="string">&#x27;ZData&#x27;</span>,u(:,<span class="number">1</span>))</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">pdemesh(model,u)</span><br><span class="line">title(<span class="string">&#x27;解的网格表面图&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>rcd.m</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">model = createpde();  </span><br><span class="line">geometryFromEdges(model,@squareg);</span><br><span class="line"><span class="comment">%自带的正方形区域</span></span><br><span class="line">applyBoundaryCondition(model,<span class="string">&#x27;dirichlet&#x27;</span>,...</span><br><span class="line"><span class="string">&#x27;Face&#x27;</span>,<span class="number">1</span>:model.Geometry.NumFaces,<span class="string">&#x27;u&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">%在所有面应用dirichlet边界条件</span></span><br><span class="line">specifyCoefficients(model,<span class="string">&#x27;m&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;c&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;f&#x27;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">%边界条件</span></span><br><span class="line">u0=@(location) location.x.^<span class="number">2</span>+location.y.^<span class="number">2</span>&lt;<span class="number">0.4</span>;</span><br><span class="line"><span class="comment">%定义初始条件</span></span><br><span class="line">setInitialConditions(model,u0);<span class="comment">%设置初始条件</span></span><br><span class="line">generateMesh(model,<span class="string">&#x27;Hmax&#x27;</span>,<span class="number">0.25</span>); </span><br><span class="line">tlist = <span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">0.1</span>,<span class="number">20</span>); <span class="comment">%时间列表</span></span><br><span class="line">results = solvepde(model,tlist);</span><br><span class="line">u=results.NodalSolution;</span><br><span class="line">pdeplot(model,<span class="string">&#x27;XYData&#x27;</span>,u,<span class="string">&#x27;ZData&#x27;</span>,u(:,<span class="number">1</span>))<span class="comment">%表面图</span></span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">pdemesh(model,u)<span class="comment">%网格图</span></span><br><span class="line">title(<span class="string">&#x27;解的网格表面图&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="解特征值方程">解特征值方程</h3><p>result=slovepdeeig(model,evr) evr——特征值范围</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">model = createpde();</span><br><span class="line">geometryFromEdges(model,@lshapeg);</span><br><span class="line"><span class="comment">%lshapeg为自带的L形区域文件</span></span><br><span class="line">Mesh=generateMesh(model); <span class="comment">%生成模型网络</span></span><br><span class="line">pdegplot(model,<span class="string">&#x27;FaceLabels&#x27;</span>,<span class="string">&#x27;on&#x27;</span>,<span class="string">&#x27;FaceAlpha&#x27;</span>,<span class="number">0.5</span>)</span><br><span class="line">applyBoundaryCondition(model,<span class="string">&#x27;dirichlet&#x27;</span>,<span class="string">&#x27;Edge&#x27;</span>,...</span><br><span class="line"><span class="number">1</span>:model.Geometry.NumEdges,<span class="string">&#x27;u&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">specifyCoefficients(model,<span class="string">&#x27;m&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;c&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;f&#x27;</span>,<span class="number">0</span>); </span><br><span class="line">evr = [-Inf,<span class="number">100</span>]; <span class="comment">%指定区间</span></span><br><span class="line">generateMesh(model,<span class="string">&#x27;Hmax&#x27;</span>,<span class="number">0.25</span>);</span><br><span class="line">results = solvepdeeig(model,evr); <span class="comment">%求解特征值</span></span><br><span class="line"></span><br><span class="line">              Basis= <span class="number">10</span>,  Time=   <span class="number">0.00</span>,  New conv eig=  <span class="number">0</span></span><br><span class="line">              Basis= <span class="number">30</span>,  Time=   <span class="number">0.00</span>,  New conv eig=  <span class="number">6</span></span><br><span class="line">              Basis= <span class="number">50</span>,  Time=   <span class="number">0.00</span>,  New conv eig= <span class="number">17</span></span><br><span class="line">              Basis= <span class="number">70</span>,  Time=   <span class="number">0.02</span>,  New conv eig= <span class="number">35</span></span><br><span class="line">End of sweep: Basis= <span class="number">70</span>,  Time=   <span class="number">0.02</span>,  New conv eig= <span class="number">33</span></span><br><span class="line">              Basis= <span class="number">43</span>,  Time=   <span class="number">0.02</span>,  New conv eig=  <span class="number">0</span></span><br><span class="line">              Basis= <span class="number">63</span>,  Time=   <span class="number">0.02</span>,  New conv eig=  <span class="number">1</span></span><br><span class="line">End of sweep: Basis= <span class="number">63</span>,  Time=   <span class="number">0.02</span>,  New conv eig=  <span class="number">1</span></span><br><span class="line"></span><br><span class="line">V = results.Eigenvectors; <span class="comment">%特征值向量</span></span><br><span class="line">pdeplot(model,<span class="string">&#x27;XYData&#x27;</span>,V,<span class="string">&#x27;ZData&#x27;</span>,V(:,<span class="number">1</span>)); </span><br><span class="line">title(<span class="string">&#x27;第一特征模态图&#x27;</span>) </span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">pdeplot(model,<span class="string">&#x27;XYData&#x27;</span>,V,<span class="string">&#x27;ZData&#x27;</span>,V(:,<span class="number">16</span>));</span><br><span class="line">title(<span class="string">&#x27;第十六特征模态图&#x27;</span>)</span><br></pre></td></tr></table></figure><h1>数据可视化分析</h1><h2 id="样本空间">样本空间</h2><p>概率：p(A)</p><h2 id="数据可视化">数据可视化</h2><h3 id="离散情况">离散情况</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=[<span class="number">25</span>  <span class="number">28</span>  <span class="number">26</span>  <span class="number">26</span>  <span class="number">29</span>  <span class="number">22</span>  <span class="number">21</span>  <span class="number">22</span>  <span class="number">26</span>  <span class="number">27</span>  <span class="number">30</span>  <span class="number">28</span>  <span class="number">29</span>];</span><br><span class="line">y=[<span class="number">28</span>  <span class="number">23</span>  <span class="number">35</span>  <span class="number">21</span>  <span class="number">24</span>  <span class="number">32</span>  <span class="number">35</span>  <span class="number">34</span>  <span class="number">31</span>  <span class="number">30</span>  <span class="number">28</span>  <span class="number">29</span>  <span class="number">27</span>]; </span><br><span class="line"> <span class="built_in">plot</span>(x,y,<span class="string">&#x27;r^&#x27;</span>) </span><br><span class="line">title(<span class="string">&#x27;尼古丁含量测试情况&#x27;</span>)</span><br><span class="line">grid on</span><br></pre></td></tr></table></figure><h3 id="连续情况">连续情况</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=[<span class="number">25</span>  <span class="number">28</span>  <span class="number">26</span>  <span class="number">26</span>  <span class="number">29</span>  <span class="number">22</span>  <span class="number">21</span>  <span class="number">22</span>  <span class="number">26</span>  <span class="number">27</span>  <span class="number">30</span>  <span class="number">28</span>  <span class="number">29</span>];</span><br><span class="line">y=[<span class="number">28</span>  <span class="number">23</span>  <span class="number">35</span>  <span class="number">21</span>  <span class="number">24</span>  <span class="number">32</span>  <span class="number">35</span>  <span class="number">34</span>  <span class="number">31</span>  <span class="number">30</span>  <span class="number">28</span>  <span class="number">29</span>  <span class="number">27</span>]; </span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;r^&#x27;</span>) </span><br><span class="line">title(<span class="string">&#x27;尼古丁含量测试情况&#x27;</span>)</span><br><span class="line">grid on</span><br></pre></td></tr></table></figure><h2 id="正交试验分析">正交试验分析</h2><h3 id="极差分析-直观分析法">极差分析(直观分析法)</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[result,sum0]</span>=<span class="title">zjjc</span><span class="params">(s,opt)</span></span></span><br><span class="line"><span class="comment">%对正交试验进行极差分析，s是输入矩阵，opt是最优参数，其中</span></span><br><span class="line"><span class="comment">%若opt=1，表示最优取最大，若opt=2，表示最优取最小</span></span><br><span class="line"><span class="comment">%s=[1     1  1    1   857;</span></span><br><span class="line"><span class="comment">%    1     2   2   2   951;</span></span><br><span class="line"><span class="comment">%    1     3   3   3   909;</span></span><br><span class="line"><span class="comment">%    2     1   2   3   878;</span></span><br><span class="line"><span class="comment">%    2     2   3   1   973;</span></span><br><span class="line"><span class="comment">%    2     3   1   2   899;</span></span><br><span class="line"><span class="comment">%    3     1   3   2   803;</span></span><br><span class="line"><span class="comment">%    3     2   1   3  1030;</span></span><br><span class="line"><span class="comment">%    3     3   2   1   927];</span></span><br><span class="line"><span class="comment">%s的最后一列是各个正交组合的试验测量值，前几列是正交表</span></span><br><span class="line"> [m,n]=<span class="built_in">size</span>(s);</span><br><span class="line">  p=<span class="built_in">max</span>(s(:,<span class="number">1</span>));<span class="comment">%取水平数</span></span><br><span class="line">  q=n<span class="number">-1</span>;<span class="comment">%取列数</span></span><br><span class="line">  sum0=<span class="built_in">zeros</span>(p,q);</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:q</span><br><span class="line">    <span class="keyword">for</span> k=<span class="number">1</span>:m </span><br><span class="line">         <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:p</span><br><span class="line">          <span class="keyword">if</span>(s(k,<span class="built_in">i</span>)==<span class="built_in">j</span>)</span><br><span class="line">              sum0(<span class="built_in">j</span>,<span class="built_in">i</span>)=sum0(<span class="built_in">j</span>,<span class="built_in">i</span>)+s(k,n);<span class="comment">%求和</span></span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line">maxdiff=<span class="built_in">max</span>(sum0)-<span class="built_in">min</span>(sum0);<span class="comment">%求极差</span></span><br><span class="line">result(<span class="number">1</span>,:)=maxdiff;</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">    maxsum0=<span class="built_in">max</span>(sum0);</span><br><span class="line">    <span class="keyword">for</span> kk=<span class="number">1</span>:q</span><br><span class="line">        modmax=<span class="built_in">mod</span>(<span class="built_in">find</span>(sum0==maxsum0(kk)),p);<span class="comment">%求最大水平</span></span><br><span class="line">        <span class="keyword">if</span> modmax==<span class="number">0</span></span><br><span class="line">            modmax=p;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        result(<span class="number">2</span>,kk)=(modmax);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   minsum0=<span class="built_in">min</span>(sum0);</span><br><span class="line">    <span class="keyword">for</span> kk=<span class="number">1</span>:q</span><br><span class="line">        modmin=<span class="built_in">mod</span>(<span class="built_in">find</span>(sum0==minsum0(kk)),p);<span class="comment">%求最小水平</span></span><br><span class="line">        <span class="keyword">if</span> modmin==<span class="number">0</span></span><br><span class="line">            modmin=p;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        result(<span class="number">2</span>,kk)=(modmin);</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">s=[  <span class="number">1</span>     <span class="number">1</span>  <span class="number">1</span>    <span class="number">1</span>  <span class="number">857</span>;</span><br><span class="line">     <span class="number">1</span>     <span class="number">2</span>   <span class="number">2</span>   <span class="number">2</span>  <span class="number">951</span>;</span><br><span class="line">     <span class="number">1</span>     <span class="number">3</span>   <span class="number">3</span>   <span class="number">3</span>  <span class="number">909</span>;</span><br><span class="line">     <span class="number">2</span>     <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>  <span class="number">878</span>;</span><br><span class="line">     <span class="number">2</span>     <span class="number">2</span>   <span class="number">3</span>   <span class="number">1</span>  <span class="number">973</span>;</span><br><span class="line">     <span class="number">2</span>     <span class="number">3</span>   <span class="number">1</span>   <span class="number">2</span>  <span class="number">899</span>;</span><br><span class="line">     <span class="number">3</span>     <span class="number">1</span>   <span class="number">3</span>   <span class="number">2</span>  <span class="number">803</span>;</span><br><span class="line">     <span class="number">3</span>     <span class="number">2</span>   <span class="number">1</span>   <span class="number">3</span>  <span class="number">1030</span>;</span><br><span class="line">     <span class="number">3</span>     <span class="number">3</span>   <span class="number">2</span>   <span class="number">1</span>   <span class="number">927</span>]; </span><br><span class="line"></span><br><span class="line">[result,sum0]=zjjc(s,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">result =</span><br><span class="line">    <span class="number">43</span>   <span class="number">416</span>   <span class="number">101</span>   <span class="number">164</span><span class="comment">%每个因素的极差</span></span><br><span class="line">     <span class="number">3</span>     <span class="number">2</span>     <span class="number">1</span>     <span class="number">3</span><span class="comment">%相应因素的最优生产条件</span></span><br><span class="line">sum0 =<span class="comment">%相应因素每个水平的数据和</span></span><br><span class="line">        <span class="number">2717</span>        <span class="number">2538</span>        <span class="number">2786</span>        <span class="number">2757</span></span><br><span class="line">        <span class="number">2750</span>        <span class="number">2954</span>        <span class="number">2756</span>        <span class="number">2653</span></span><br><span class="line">        <span class="number">2760</span>        <span class="number">2735</span>        <span class="number">2685</span>        <span class="number">2817</span></span><br></pre></td></tr></table></figure><h3 id="方差分析">方差分析</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[result,error,errorDim]</span>=<span class="title">zjfc</span><span class="params">(s,opt)</span></span></span><br><span class="line"><span class="comment">%对正交试验进行方差分析，s是输入矩阵，opt是空列参数向量，给出s中是空白列的列序号</span></span><br><span class="line"><span class="comment">%s=[1  1   1   1  1 1 1 83.4;</span></span><br><span class="line"><span class="comment">%    1  1   1   2  2 2 2    84;</span></span><br><span class="line"><span class="comment">%    1  2   2   1  1 2 2 87.3;</span></span><br><span class="line"><span class="comment">%    1  2   2   2  2 1 1 84.8;</span></span><br><span class="line"><span class="comment">%    2  1   2   1  2 1 2 87.3;</span></span><br><span class="line"><span class="comment">%    2  1   2   2  1 2 1    88;</span></span><br><span class="line"><span class="comment">%    2  2   1   1  2 2 1 92.3;</span></span><br><span class="line"><span class="comment">%    2  2   1   2  1 1 2 90.4;</span></span><br><span class="line"><span class="comment">%];</span></span><br><span class="line"><span class="comment">%opt=[3,7];</span></span><br><span class="line"><span class="comment">%s的最后一列是各个正交组合的试验测量值，前几列是正交表</span></span><br><span class="line">[m,n]=<span class="built_in">size</span>(s);</span><br><span class="line"> p=<span class="built_in">max</span>(s(:,<span class="number">1</span>)); <span class="comment">%取水平数</span></span><br><span class="line"> q=n<span class="number">-1</span>;<span class="comment">%取列数</span></span><br><span class="line"> sum0=<span class="built_in">zeros</span>(p,q);</span><br><span class="line"> <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:q</span><br><span class="line">    <span class="keyword">for</span> k=<span class="number">1</span>:m </span><br><span class="line">         <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:p</span><br><span class="line">          <span class="keyword">if</span>(s(k,<span class="built_in">i</span>)==<span class="built_in">j</span>)</span><br><span class="line">              sum0(<span class="built_in">j</span>,<span class="built_in">i</span>)=sum0(<span class="built_in">j</span>,<span class="built_in">i</span>)+s(k,n);<span class="comment">%求和</span></span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line">totalsum=sum(s(:,n));</span><br><span class="line">ss=sum0.*sum0;</span><br><span class="line">levelsum=m/p; <span class="comment">%水平重复数</span></span><br><span class="line">ss=sum(ss./levelsum)-totalsum^<span class="number">2</span>/m; <span class="comment">%每一列的S</span></span><br><span class="line">ssError=sum(ss(opt));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:q</span><br><span class="line">    f(<span class="built_in">i</span>)=p<span class="number">-1</span>;    <span class="comment">%自由度</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fError=sum(f(opt));  <span class="comment">%误差自由度</span></span><br><span class="line">ssbar=ss./f;</span><br><span class="line">Errorbar=ssError/fError;</span><br><span class="line">index=<span class="built_in">find</span>(ssbar&lt;Errorbar);</span><br><span class="line">index1=<span class="built_in">find</span>(index==opt);</span><br><span class="line">index(index==index(index1))=[];<span class="comment">%剔除重复</span></span><br><span class="line">ssErrorNew=ssError+sum(ss(index));  <span class="comment">%并入误差</span></span><br><span class="line">fErrorNew=fError+sum(f(index));  <span class="comment">%新误差自由度</span></span><br><span class="line">F=(ss./f)/(ssErrorNew./fErrorNew);   <span class="comment">%F值</span></span><br><span class="line">errorDim=[opt,index];</span><br><span class="line"> errorDim=<span class="built_in">sort</span>(errorDim);<span class="comment">%误差列的序号</span></span><br><span class="line">result=[ss&#x27;,f&#x27;,ssbar&#x27;,F&#x27;];</span><br><span class="line">error=[ssError,fError;ssErrorNew,fErrorNew];</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">s=[ <span class="number">51</span> <span class="number">25</span> <span class="number">18</span> <span class="number">32</span>;</span><br><span class="line"><span class="number">40</span> <span class="number">23</span> <span class="number">13</span> <span class="number">35</span>;</span><br><span class="line"><span class="number">43</span> <span class="number">24</span> <span class="number">12</span> <span class="number">34</span>;</span><br><span class="line"><span class="number">48</span> <span class="number">26</span> <span class="number">16</span> <span class="number">30</span>;</span><br><span class="line"><span class="number">35</span> <span class="number">30</span> <span class="number">11</span> <span class="number">35</span>;</span><br><span class="line"><span class="number">32</span> <span class="number">31</span> <span class="number">10</span> <span class="number">37</span>];</span><br><span class="line"></span><br><span class="line">[result,sum0]=zjfc(s,<span class="number">1</span>)<span class="comment">%第1列为空白列以考查试验误差进行方差分析</span></span><br><span class="line"></span><br><span class="line">result =<span class="comment">%方差分析结果</span></span><br><span class="line">   <span class="number">1.0e+04</span> *</span><br><span class="line">    <span class="number">5.1773</span>    <span class="number">0.0050</span>    <span class="number">0.1035</span>    <span class="number">0.0001</span></span><br><span class="line">    <span class="number">5.1773</span>    <span class="number">0.0050</span>    <span class="number">0.1035</span>    <span class="number">0.0001</span></span><br><span class="line">    <span class="number">5.1773</span>    <span class="number">0.0050</span>    <span class="number">0.1035</span>    <span class="number">0.0001</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sum0 =<span class="comment">%误差</span></span><br><span class="line">   <span class="number">1.0e+04</span> *</span><br><span class="line">    <span class="number">5.1773</span>    <span class="number">0.0050</span></span><br><span class="line">    <span class="number">5.1773</span>    <span class="number">0.0050</span></span><br></pre></td></tr></table></figure><h1>回归分析和方差分析</h1><h2 id="回归分析">回归分析</h2><h3 id="一元线性回归">一元线性回归</h3><p>ployfit()</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">x=[<span class="number">82</span> <span class="number">93</span> <span class="number">105</span> <span class="number">130</span> <span class="number">144</span> <span class="number">150</span> <span class="number">160</span> <span class="number">180</span> <span class="number">270</span> <span class="number">300</span> <span class="number">400</span>]; </span><br><span class="line">y=[<span class="number">75</span> <span class="number">85</span> <span class="number">92</span> <span class="number">105</span> <span class="number">120</span> <span class="number">130</span> <span class="number">145</span> <span class="number">156</span> <span class="number">200</span> <span class="number">200</span> <span class="number">240</span>];</span><br><span class="line">[p,s]=polyfit(x,y,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">x0=[<span class="built_in">min</span>(x):<span class="number">1</span>:<span class="built_in">max</span>(x)];<span class="comment">%重新定义取值点，间隔为1</span></span><br><span class="line">y0=p(<span class="number">1</span>)*x0+p(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span> on </span><br><span class="line"><span class="built_in">plot</span>(x0,y0)</span><br><span class="line"></span><br><span class="line">p =<span class="comment">%多项式的系数向量</span></span><br><span class="line">    <span class="number">0.5269</span>   <span class="number">44.2547</span></span><br><span class="line">s = <span class="comment">%用于获取误差估计值的结构体</span></span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">        R: [<span class="number">2</span>×<span class="number">2</span> double]</span><br><span class="line">       df: <span class="number">9</span></span><br><span class="line">    normr: <span class="number">36.8058</span></span><br></pre></td></tr></table></figure><h3 id="多元线性回归">多元线性回归</h3><p>[b,bint,r,rint,stats]=regress(y,X,alpha) 因变量y,自变量X</p><p>b——对回归系数的最小二乘估计</p><p>bint——回归系数b的95%置信度的置信区间</p><p>r——残差</p><p>rint——r的置信区间</p><p>stats——检验统计量</p><blockquote><p>假设回归方程有常数项，计算stats时，X应该包含一个全1的列</p></blockquote><p>alpha——指定的置信水平</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">y=[<span class="number">11.9</span> <span class="number">22.8</span> <span class="number">18.7</span> <span class="number">20.1</span> <span class="number">12.9</span> <span class="number">21.7</span> <span class="number">27.1</span> <span class="number">25.4</span> <span class="number">21.3</span> <span class="number">19.3</span> <span class="number">25.4</span> <span class="number">27.2</span> <span class="number">11.7</span><span class="number">17.8</span> <span class="number">12.8</span> <span class="number">23.9</span> <span class="number">22.6</span> <span class="number">25.4</span> <span class="number">14.8</span> <span class="number">21.1</span>];</span><br><span class="line"><span class="comment">%测量数据</span></span><br><span class="line">x=[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>; <span class="number">19.5</span> <span class="number">24.7</span> <span class="number">30.7</span> <span class="number">29.8</span><span class="number">19.1</span><span class="number">25.6</span><span class="number">31.4</span><span class="number">27.9</span><span class="number">22.1</span><span class="number">25.5</span> <span class="number">31.1</span><span class="number">30.4</span><span class="number">18.7</span><span class="number">19.7</span><span class="number">14.6</span><span class="number">29.5</span><span class="number">27.7</span><span class="number">30.2</span><span class="number">22.7</span><span class="number">25.2</span>;  <span class="number">43.1</span><span class="number">49.8</span><span class="number">51.9</span><span class="number">54.3</span><span class="number">42.2</span><span class="number">53.9</span><span class="number">58.6</span><span class="number">52.1</span><span class="number">49.9</span><span class="number">53.5</span> <span class="number">56.6</span><span class="number">56.7</span><span class="number">46.5</span><span class="number">44.2</span><span class="number">42.7</span><span class="number">54.4</span><span class="number">55.3</span><span class="number">58.6</span><span class="number">48.2</span><span class="number">51</span>; <span class="number">29.1</span>  <span class="number">28.2</span><span class="number">37</span><span class="number">31.1</span><span class="number">30.9</span><span class="number">23.7</span><span class="number">27.6</span><span class="number">30.6</span><span class="number">23.2</span><span class="number">24.8</span> <span class="number">30</span><span class="number">28.3</span><span class="number">23</span><span class="number">28.6</span><span class="number">21.3</span><span class="number">30.1</span><span class="number">25.6</span><span class="number">24.6</span><span class="number">27.1</span><span class="number">27.5</span> ]; <span class="comment">%构建分析数据矩阵</span></span><br><span class="line">[b,bint,r,rint,stats]=regress(y&#x27;,x&#x27;)</span><br><span class="line"></span><br><span class="line">b =<span class="comment">%系数估计值</span></span><br><span class="line">  <span class="number">107.8763</span></span><br><span class="line">    <span class="number">4.0599</span></span><br><span class="line">   <span class="number">-2.6200</span></span><br><span class="line">   <span class="number">-2.0402</span></span><br><span class="line">bint =<span class="comment">%系数估计值的置信边界的上界和下界</span></span><br><span class="line"> <span class="number">-100.7196</span>  <span class="number">316.4721</span></span><br><span class="line">   <span class="number">-2.2526</span>   <span class="number">10.3723</span></span><br><span class="line">   <span class="number">-8.0200</span>    <span class="number">2.7801</span></span><br><span class="line">   <span class="number">-5.3790</span>    <span class="number">1.2986</span></span><br><span class="line">r =<span class="comment">%残差</span></span><br><span class="line">   <span class="number">-2.8541</span></span><br><span class="line">    <span class="number">2.6523</span></span><br><span class="line">   <span class="number">-2.3515</span></span><br><span class="line">   <span class="number">-3.0467</span></span><br><span class="line">    <span class="number">1.0842</span></span><br><span class="line">   <span class="number">-0.5405</span></span><br><span class="line">    <span class="number">1.5828</span></span><br><span class="line">    <span class="number">3.1830</span></span><br><span class="line">    <span class="number">1.7691</span></span><br><span class="line">   <span class="number">-1.3383</span></span><br><span class="line">    <span class="number">0.7572</span></span><br><span class="line">    <span class="number">2.1928</span></span><br><span class="line">   <span class="number">-3.3433</span></span><br><span class="line">    <span class="number">4.0958</span></span><br><span class="line">    <span class="number">0.9780</span></span><br><span class="line">    <span class="number">0.1931</span></span><br><span class="line">   <span class="number">-0.6220</span></span><br><span class="line">   <span class="number">-1.3659</span></span><br><span class="line">   <span class="number">-3.6641</span></span><br><span class="line">    <span class="number">0.6382</span></span><br><span class="line">rint =<span class="comment">%用于诊断离群值的区间</span></span><br><span class="line">   <span class="number">-7.0569</span>    <span class="number">1.3488</span></span><br><span class="line">   <span class="number">-2.1810</span>    <span class="number">7.4856</span></span><br><span class="line">   <span class="number">-6.2623</span>    <span class="number">1.5593</span></span><br><span class="line">   <span class="number">-7.9378</span>    <span class="number">1.8444</span></span><br><span class="line">   <span class="number">-3.2626</span>    <span class="number">5.4310</span></span><br><span class="line">   <span class="number">-5.6469</span>    <span class="number">4.5659</span></span><br><span class="line">   <span class="number">-3.1194</span>    <span class="number">6.2849</span></span><br><span class="line">   <span class="number">-1.5201</span>    <span class="number">7.8862</span></span><br><span class="line">   <span class="number">-3.0732</span>    <span class="number">6.6113</span></span><br><span class="line">   <span class="number">-6.0888</span>    <span class="number">3.4121</span></span><br><span class="line">   <span class="number">-4.3244</span>    <span class="number">5.8388</span></span><br><span class="line">   <span class="number">-2.8440</span>    <span class="number">7.2297</span></span><br><span class="line">   <span class="number">-7.8489</span>    <span class="number">1.1623</span></span><br><span class="line">   <span class="number">-0.3044</span>    <span class="number">8.4960</span></span><br><span class="line">   <span class="number">-3.4144</span>    <span class="number">5.3703</span></span><br><span class="line">   <span class="number">-4.9673</span>    <span class="number">5.3534</span></span><br><span class="line">   <span class="number">-5.7883</span>    <span class="number">4.5444</span></span><br><span class="line">   <span class="number">-6.1250</span>    <span class="number">3.3932</span></span><br><span class="line">   <span class="number">-8.3703</span>    <span class="number">1.0420</span></span><br><span class="line">   <span class="number">-4.6541</span>    <span class="number">5.9305</span></span><br><span class="line">stats =<span class="comment">%模型统计量</span></span><br><span class="line">    <span class="number">0.7993</span>   <span class="number">21.2383</span>    <span class="number">0.0000</span>    <span class="number">6.2145</span></span><br></pre></td></tr></table></figure><h3 id="部分最小二乘回归">部分最小二乘回归</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[beta,VIP]</span>= <span class="title">pls</span><span class="params">(X,Y)</span></span></span><br><span class="line">[n,p]=<span class="built_in">size</span>(X);</span><br><span class="line">[n,q]=<span class="built_in">size</span>(Y); </span><br><span class="line">meanX=<span class="built_in">mean</span>(X);<span class="comment">%均值</span></span><br><span class="line">varX=var(X);<span class="comment">%方差</span></span><br><span class="line">meanY=<span class="built_in">mean</span>(Y);<span class="comment">%均值</span></span><br><span class="line">varY=var(Y);<span class="comment">%方差 </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">%%%%数据标准化过程</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:p      </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:n</span><br><span class="line">    X0(<span class="built_in">j</span>,<span class="built_in">i</span>)=(X(<span class="built_in">j</span>,<span class="built_in">i</span>)-meanX(<span class="built_in">i</span>))/((varX(<span class="built_in">i</span>))^<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:q</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:n</span><br><span class="line">    Y0(<span class="built_in">j</span>,<span class="built_in">i</span>)=(Y(<span class="built_in">j</span>,<span class="built_in">i</span>)-meanY(<span class="built_in">i</span>))/((varY(<span class="built_in">i</span>))^<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"> </span><br><span class="line">[omega(:,<span class="number">1</span>),t(:,<span class="number">1</span>),pp(:,<span class="number">1</span>),XX(:,:,<span class="number">1</span>),rr(:,<span class="number">1</span>),YY(:,:,<span class="number">1</span>)]=plsfactor(X0,Y0);</span><br><span class="line">[omega(:,<span class="number">2</span>),t(:,<span class="number">2</span>),pp(:,<span class="number">2</span>),XX(:,:,<span class="number">2</span>),rr(:,<span class="number">2</span>),YY(:,:,<span class="number">2</span>)]=plsfactor(XX(:,:,<span class="number">1</span>), YY(:,:,<span class="number">1</span>));</span><br><span class="line"> </span><br><span class="line">PRESShj=<span class="number">0</span>;</span><br><span class="line">tt0=<span class="built_in">ones</span>(n<span class="number">-1</span>,<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    YY0(<span class="number">1</span>:(<span class="built_in">i</span><span class="number">-1</span>),:)=Y0(<span class="number">1</span>:(<span class="built_in">i</span><span class="number">-1</span>),:);</span><br><span class="line">    YY0(<span class="built_in">i</span>:(n<span class="number">-1</span>),:)=Y0((<span class="built_in">i</span>+<span class="number">1</span>):n,:);</span><br><span class="line">    tt0(<span class="number">1</span>:(<span class="built_in">i</span><span class="number">-1</span>),:)=t(<span class="number">1</span>:(<span class="built_in">i</span><span class="number">-1</span>),:);</span><br><span class="line">     tt0(<span class="built_in">i</span>:(n<span class="number">-1</span>),:)=t((<span class="built_in">i</span>+<span class="number">1</span>):n,:);</span><br><span class="line">     expPRESS(<span class="built_in">i</span>,:)=(Y0(<span class="built_in">i</span>,:)-t(<span class="built_in">i</span>,:)*inv((tt0&#x27;*tt0))*tt0&#x27;*YY0);</span><br><span class="line">     <span class="keyword">for</span> m=<span class="number">1</span>:q</span><br><span class="line">        PRESShj=PRESShj+expPRESS(<span class="built_in">i</span>,m)^<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> sum1=sum(PRESShj);</span><br><span class="line"> PRESSh=sum(sum1);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> m=<span class="number">1</span>:q</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">             SShj(<span class="built_in">i</span>,m)=YY(<span class="built_in">i</span>,m,<span class="number">1</span>)^<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"> sum2=sum(SShj);</span><br><span class="line"> SSh=sum(sum2);</span><br><span class="line"> </span><br><span class="line"> Q=<span class="number">1</span>-(PRESSh/SSh);</span><br><span class="line"> </span><br><span class="line"> k=<span class="number">3</span>;</span><br><span class="line"> <span class="comment">%%%%%%%%%%%%%%%%循环，提取主元 </span></span><br><span class="line"> <span class="keyword">while</span> Q&gt;<span class="number">0.0975</span></span><br><span class="line">     [omega(:,k),t(:,k),pp(:,k),XX(:,:,k),rr(:,k),YY(:,:,k)]=plsfactor (XX(:,:,k<span class="number">-1</span>),YY(:,:,k<span class="number">-1</span>));</span><br><span class="line">      PRESShj=<span class="number">0</span>;</span><br><span class="line">    tt00=<span class="built_in">ones</span>(n<span class="number">-1</span>,k);</span><br><span class="line"> <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    YY0(<span class="number">1</span>:(<span class="built_in">i</span><span class="number">-1</span>),:)=Y0(<span class="number">1</span>:(<span class="built_in">i</span><span class="number">-1</span>),:);</span><br><span class="line">    YY0(<span class="built_in">i</span>:(n<span class="number">-1</span>),:)=Y0((<span class="built_in">i</span>+<span class="number">1</span>):n,:);</span><br><span class="line">     tt00(<span class="number">1</span>:(<span class="built_in">i</span><span class="number">-1</span>),:)=t(<span class="number">1</span>:(<span class="built_in">i</span><span class="number">-1</span>),:);</span><br><span class="line">     tt00(<span class="built_in">i</span>:(n<span class="number">-1</span>),:)=t((<span class="built_in">i</span>+<span class="number">1</span>):n,:);</span><br><span class="line">     expPRESS(<span class="built_in">i</span>,:)=(Y0(<span class="built_in">i</span>,:)-t(<span class="built_in">i</span>,:)*((tt00&#x27;*tt00)^(<span class="number">-1</span>))*tt00&#x27;*YY0);</span><br><span class="line">     <span class="keyword">for</span> m=<span class="number">1</span>:q</span><br><span class="line">        PRESShj=PRESShj+expPRESS(<span class="built_in">i</span>,m)^<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line"> <span class="keyword">for</span> m=<span class="number">1</span>:q</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">            SShj(<span class="built_in">i</span>,m)=YY(<span class="built_in">i</span>,m,k<span class="number">-1</span>)^<span class="number">2</span>;</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">sum2=sum(SShj);</span><br><span class="line"> SSh=sum(sum2);</span><br><span class="line">  Q=<span class="number">1</span>-(PRESSh/SSh);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> Q&gt;<span class="number">0.0975</span></span><br><span class="line">     k=k+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">h=k<span class="number">-1</span>;<span class="comment">%%%%%%%%%提取主元的个数 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%还原回归系数 </span></span><br><span class="line">omegaxing=<span class="built_in">ones</span>(p,h,q);</span><br><span class="line"><span class="keyword">for</span> m=<span class="number">1</span>:q</span><br><span class="line">omegaxing(:,<span class="number">1</span>,m)=rr(m,<span class="number">1</span>)*omega(:,<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">2</span>:(h)</span><br><span class="line">       <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:(<span class="built_in">i</span><span class="number">-1</span>)</span><br><span class="line">          omegaxingi =(<span class="built_in">eye</span>(p)-omega(:,<span class="built_in">j</span>)*pp(:,<span class="built_in">j</span>)&#x27;);</span><br><span class="line">          omegaxingii=<span class="built_in">eye</span>(p);</span><br><span class="line">          omegaxingii=omegaxingii*omegaxingi;</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">      omegaxing(:,<span class="built_in">i</span>,m)=rr(m,<span class="built_in">i</span>)*omegaxingii*omega(:,<span class="built_in">i</span>);</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="built_in">beta</span>(:,m)=sum(omegaxing(:,:,m),<span class="number">2</span>);</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="comment">%%%%%%%计算相关系数 </span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:h</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:q</span><br><span class="line">        relation(<span class="built_in">i</span>,<span class="built_in">j</span>)=sum(prod(corrcoef(t(:,<span class="built_in">i</span>),Y(:,<span class="built_in">j</span>))))/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">Rd=relation.*relation;</span><br><span class="line">RdYt=sum(Rd,<span class="number">2</span>)/q;</span><br><span class="line">Rdtttt=sum(RdYt);</span><br><span class="line">omega22=omega.*omega; </span><br><span class="line">VIP=((p/Rdtttt)*(omega22*RdYt)).^<span class="number">0.5</span>; <span class="comment">%%%计算VIP系数</span></span><br></pre></td></tr></table></figure><p>提取主元</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[omega,t,pp,XXX,r,YYY]</span>=<span class="title">plsfactor</span><span class="params">(X0,Y0)</span> </span></span><br><span class="line">XX=X0&#x27;*Y0*Y0&#x27;*X0;</span><br><span class="line">[V,D]=eig(XX);</span><br><span class="line">Lamda=<span class="built_in">max</span>(D);</span><br><span class="line">[MAXLamda,I]=<span class="built_in">max</span>(Lamda);</span><br><span class="line">omega=V(:,I);          <span class="comment">%最大特征值对应的特征向量 </span></span><br><span class="line"> <span class="comment">%%%第一主元 </span></span><br><span class="line">t=X0*omega;</span><br><span class="line">pp=X0&#x27;*t/(t&#x27;*t);</span><br><span class="line">XXX=X0-t*pp&#x27;;</span><br><span class="line">r=Y0&#x27;*t/(t&#x27;*t);</span><br><span class="line">YYY=Y0-t*r&#x27;;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">X=[<span class="number">191</span> <span class="number">36</span> <span class="number">50</span>;<span class="comment">%自变量</span></span><br><span class="line"><span class="number">189</span> <span class="number">37</span> <span class="number">52</span>;</span><br><span class="line"><span class="number">193</span> <span class="number">38</span> <span class="number">58</span>;</span><br><span class="line"><span class="number">162</span> <span class="number">35</span> <span class="number">62</span>;</span><br><span class="line"><span class="number">189</span> <span class="number">35</span> <span class="number">46</span>;</span><br><span class="line"><span class="number">182</span> <span class="number">36</span> <span class="number">56</span>;</span><br><span class="line"><span class="number">211</span> <span class="number">38</span> <span class="number">56</span>;</span><br><span class="line"><span class="number">167</span> <span class="number">34</span> <span class="number">60</span>;</span><br><span class="line"><span class="number">176</span> <span class="number">31</span> <span class="number">74</span>;</span><br><span class="line"><span class="number">154</span> <span class="number">33</span> <span class="number">56</span>;</span><br><span class="line"><span class="number">169</span> <span class="number">34</span> <span class="number">50</span>;</span><br><span class="line"><span class="number">166</span> <span class="number">33</span> <span class="number">52</span>;</span><br><span class="line"><span class="number">154</span> <span class="number">34</span> <span class="number">64</span>;</span><br><span class="line"><span class="number">247</span> <span class="number">46</span> <span class="number">50</span>;</span><br><span class="line"><span class="number">193</span> <span class="number">36</span> <span class="number">46</span>;</span><br><span class="line"><span class="number">202</span> <span class="number">37</span> <span class="number">62</span>;</span><br><span class="line"><span class="number">176</span> <span class="number">37</span> <span class="number">54</span>;</span><br><span class="line"><span class="number">157</span> <span class="number">32</span> <span class="number">52</span>;</span><br><span class="line"><span class="number">156</span> <span class="number">33</span> <span class="number">54</span>;</span><br><span class="line"><span class="number">138</span> <span class="number">33</span> <span class="number">68</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">Y=[<span class="number">5</span> <span class="number">162</span> <span class="number">60</span>;<span class="comment">%因变量</span></span><br><span class="line"><span class="number">2</span> <span class="number">110</span> <span class="number">60</span>;</span><br><span class="line"><span class="number">12</span> <span class="number">101</span> <span class="number">101</span>;</span><br><span class="line"><span class="number">12</span> <span class="number">105</span> <span class="number">37</span>;</span><br><span class="line"><span class="number">13</span> <span class="number">155</span> <span class="number">58</span>;</span><br><span class="line"><span class="number">4</span> <span class="number">101</span> <span class="number">42</span>;</span><br><span class="line"><span class="number">8</span> <span class="number">101</span> <span class="number">38</span>;</span><br><span class="line"><span class="number">6</span> <span class="number">125</span> <span class="number">40</span>;</span><br><span class="line"><span class="number">15</span> <span class="number">200</span> <span class="number">40</span>;</span><br><span class="line"><span class="number">17</span> <span class="number">251</span> <span class="number">250</span>;</span><br><span class="line"><span class="number">17</span> <span class="number">120</span> <span class="number">38</span>;</span><br><span class="line"><span class="number">13</span> <span class="number">210</span> <span class="number">115</span>;</span><br><span class="line"><span class="number">14</span> <span class="number">215</span> <span class="number">105</span>;</span><br><span class="line"><span class="number">1</span> <span class="number">50</span> <span class="number">50</span> ;</span><br><span class="line"><span class="number">6</span> <span class="number">70</span> <span class="number">31</span>;</span><br><span class="line"><span class="number">12</span> <span class="number">210</span> <span class="number">120</span>;</span><br><span class="line"><span class="number">4</span> <span class="number">60</span> <span class="number">25</span>;</span><br><span class="line"><span class="number">11</span> <span class="number">230</span> <span class="number">80</span>;</span><br><span class="line"><span class="number">15</span> <span class="number">225</span> <span class="number">73</span>;</span><br><span class="line"><span class="number">2</span> <span class="number">110</span> <span class="number">43</span>];</span><br><span class="line">[<span class="built_in">beta</span>,VIP]=pls(X,Y)<span class="comment">%进行部分最小二乘回归</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">beta</span> =</span><br><span class="line">   <span class="number">-0.0778</span>   <span class="number">-0.1385</span>   <span class="number">-0.0604</span></span><br><span class="line">   <span class="number">-0.4989</span>   <span class="number">-0.5244</span>   <span class="number">-0.1559</span></span><br><span class="line">   <span class="number">-0.1322</span>   <span class="number">-0.0854</span>   <span class="number">-0.0073</span></span><br><span class="line">VIP =</span><br><span class="line">    <span class="number">0.9982</span></span><br><span class="line">    <span class="number">1.2977</span></span><br><span class="line">    <span class="number">0.5652</span></span><br></pre></td></tr></table></figure><h2 id="数理统计基础">数理统计基础</h2><h3 id="样本均值">样本均值</h3><p>M=mean(A)</p><ul><li>算术平均 nanmean</li><li>几何平均 geomean</li><li>调和平均 harmmean</li><li>调整平均 trimmean</li></ul><h3 id="样本方差与标准差">样本方差与标准差</h3><ul><li><p>方差 var(A,w) w——权重向量</p></li><li><p>标准差 std(A,w)</p><p>w=0(默认)，按N-1进行归一化</p><p>w=1，按观测数值量N进行归一化</p></li></ul><h3 id="协方差和相关系数">协方差和相关系数</h3><ul><li>协方差 cov(A)</li><li>相关系数 corrcoef(A)</li></ul><h2 id="多元数据相关分析">多元数据相关分析</h2><h3 id="主成分分析">主成分分析</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[F,rate,maxlamda]</span>=<span class="title">mainfactor</span><span class="params">(X)</span></span></span><br><span class="line">[n,p]=<span class="built_in">size</span>(X);</span><br><span class="line">meanX=<span class="built_in">mean</span>(X);</span><br><span class="line">varX=var(X);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:p      </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:n</span><br><span class="line">    X0(<span class="built_in">j</span>,<span class="built_in">i</span>)=(X(<span class="built_in">j</span>,<span class="built_in">i</span>)-meanX(<span class="built_in">i</span>))/((varX(<span class="built_in">i</span>))^<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">V=corrcoef(X0);</span><br><span class="line">[VV0,lamda0]=eig(V);</span><br><span class="line">lamda1=sum(lamda0);</span><br><span class="line">lamda=lamda1(<span class="built_in">find</span>(lamda1&gt;<span class="number">0</span>));</span><br><span class="line">VV=VV0(:,<span class="built_in">find</span>(lamda1&gt;<span class="number">0</span>));</span><br><span class="line">k=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(k&lt;=<span class="built_in">length</span>(lamda))</span><br><span class="line">    [maxlamda(k),I]=<span class="built_in">max</span>(lamda);</span><br><span class="line">    maxVV(:,k)=VV(:,I);</span><br><span class="line">    lamda(I)=[];</span><br><span class="line">    VV(:,I)=[];</span><br><span class="line">    k=k+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">lamdarate=maxlamda/sum(maxlamda);</span><br><span class="line">rate=(<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(maxlamda)));</span><br><span class="line"><span class="keyword">for</span> l=<span class="number">1</span>:<span class="built_in">length</span>(maxlamda)</span><br><span class="line">    F(:,l)=maxVV(:,<span class="number">1</span>)&#x27;*X&#x27;;</span><br><span class="line">    <span class="keyword">for</span> m=<span class="number">1</span>:l</span><br><span class="line">    rate(l)=rate(l)+lamdarate(m);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">X=[<span class="number">19.5</span> <span class="number">24.7</span> <span class="number">30.7</span> <span class="number">29.8</span> <span class="number">19.1</span> <span class="number">25.6</span> <span class="number">31.4</span> <span class="number">27.9</span> <span class="number">22.1</span> <span class="number">25.5</span>  <span class="number">31.1</span> <span class="number">30.4</span> <span class="number">18.7</span> <span class="number">19.7</span> <span class="number">14.6</span><span class="number">29.5</span><span class="number">27.7</span><span class="number">30.2</span><span class="number">22.7</span><span class="number">25.2</span>;<span class="number">43.1</span><span class="number">49.8</span><span class="number">51.9</span><span class="number">54.3</span><span class="number">42.2</span><span class="number">53.9</span><span class="number">58.6</span><span class="number">52.1</span><span class="number">49.9</span><span class="number">53.5</span> <span class="number">56.6</span><span class="number">56.7</span><span class="number">46.5</span><span class="number">44.2</span><span class="number">42.7</span><span class="number">54.4</span><span class="number">55.3</span><span class="number">58.6</span><span class="number">48.2</span><span class="number">51</span>;  <span class="number">29.1</span> <span class="number">28.2</span><span class="number">37</span><span class="number">31.1</span><span class="number">30.9</span><span class="number">23.7</span><span class="number">27.6</span><span class="number">30.6</span><span class="number">23.2</span><span class="number">24.8</span>  <span class="number">30</span><span class="number">28.3</span><span class="number">23</span><span class="number">28.6</span><span class="number">21.3</span><span class="number">30.1</span><span class="number">25.6</span><span class="number">24.6</span><span class="number">27.1</span><span class="number">27.5</span>];</span><br><span class="line">[F,rate,maxlamda]=mainfactor(X)</span><br><span class="line"></span><br><span class="line">F =<span class="comment">%对应的主成分</span></span><br><span class="line">  <span class="number">113.2766</span>  <span class="number">113.2766</span>  <span class="number">113.2766</span>  <span class="number">113.2766</span>  <span class="number">113.2766</span>  <span class="number">113.2766</span></span><br><span class="line">  <span class="number">229.0117</span>  <span class="number">229.0117</span>  <span class="number">229.0117</span>  <span class="number">229.0117</span>  <span class="number">229.0117</span>  <span class="number">229.0117</span></span><br><span class="line">  <span class="number">123.3809</span>  <span class="number">123.3809</span>  <span class="number">123.3809</span>  <span class="number">123.3809</span>  <span class="number">123.3809</span>  <span class="number">123.3809</span></span><br><span class="line">rate =<span class="comment">%每个主成分的贡献率</span></span><br><span class="line">    <span class="number">0.9681</span>    <span class="number">1.0000</span>    <span class="number">1.0000</span>    <span class="number">1.0000</span>    <span class="number">1.0000</span>    <span class="number">1.0000</span></span><br><span class="line">maxlamda =<span class="comment">%从大到小排列的协方差阵特征值</span></span><br><span class="line">   <span class="number">19.3620</span>    <span class="number">0.6380</span>    <span class="number">0.0000</span>    <span class="number">0.0000</span>    <span class="number">0.0000</span>    <span class="number">0.0000</span></span><br></pre></td></tr></table></figure><h3 id="典型相关分析">典型相关分析</h3><p>看是否存在相关关系</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[maxVV1,maxVV2,F,G]</span>=<span class="title">dxxg</span><span class="params">(X,Y)</span></span></span><br><span class="line">[n,p]=<span class="built_in">size</span>(X);</span><br><span class="line">[n,q]=<span class="built_in">size</span>(Y);</span><br><span class="line">meanX=<span class="built_in">mean</span>(X);</span><br><span class="line">varX=var(X);</span><br><span class="line">meanY=<span class="built_in">mean</span>(Y);</span><br><span class="line">varY=var(Y);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:p      </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:n</span><br><span class="line">    X0(<span class="built_in">j</span>,<span class="built_in">i</span>)=(X(<span class="built_in">j</span>,<span class="built_in">i</span>)-meanX(<span class="built_in">i</span>))/((varX(<span class="built_in">i</span>))^<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:q</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:n</span><br><span class="line">    Y0(<span class="built_in">j</span>,<span class="built_in">i</span>)=(Y(<span class="built_in">j</span>,<span class="built_in">i</span>)-meanY(<span class="built_in">i</span>))/((varY(<span class="built_in">i</span>))^<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">V1=inv(X0&#x27;*X0)*X0&#x27;*Y0*inv(Y0&#x27;*Y0)*Y0&#x27;*X0;</span><br><span class="line">V2=inv(Y0&#x27;*Y0)*Y0&#x27;*X0*inv(X0&#x27;*X0)*X0&#x27;*Y0;</span><br><span class="line">[VV1,lamda1]=eig(V1);</span><br><span class="line">[VV2,lamda2]=eig(V2);</span><br><span class="line">lamda11=sum(lamda1);</span><br><span class="line">lamda21=sum(lamda2);</span><br><span class="line">k=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(k&lt;=(<span class="built_in">length</span>(lamda1))^<span class="number">0.5</span>)</span><br><span class="line">    [maxlamda1(k),I]=<span class="built_in">max</span>(lamda11);   </span><br><span class="line">    maxVV1(:,k)=VV1(:,I);</span><br><span class="line">    lamda11(I)=[];</span><br><span class="line">    VV1(:,I)=[];</span><br><span class="line">     [maxlamda2(k),I]=<span class="built_in">max</span>(lamda21);</span><br><span class="line">    maxVV2(:,k)=VV2(:,I);</span><br><span class="line">     lamda21(I)=[];</span><br><span class="line">    VV2(:,I)=[];</span><br><span class="line">    k=k+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">F=X0*maxVV1;</span><br><span class="line">G=Y0*maxVV2;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">X=[<span class="number">191</span> <span class="number">36</span> <span class="number">50</span>; <span class="number">189</span> <span class="number">37</span> <span class="number">52</span>; <span class="number">193</span> <span class="number">38</span> <span class="number">58</span>; <span class="number">162</span> <span class="number">35</span> <span class="number">62</span>; <span class="number">189</span> <span class="number">35</span> <span class="number">46</span>; <span class="number">182</span> <span class="number">36</span> <span class="number">56</span>; <span class="number">211</span> <span class="number">38</span> <span class="number">56</span>; <span class="number">167</span> <span class="number">34</span> <span class="number">60</span>; <span class="number">176</span> <span class="number">31</span> <span class="number">74</span>; <span class="number">154</span> <span class="number">33</span> <span class="number">56</span>; <span class="number">169</span> <span class="number">34</span> <span class="number">50</span>; <span class="number">166</span> <span class="number">33</span> <span class="number">52</span>; <span class="number">154</span> <span class="number">34</span> <span class="number">64</span>; <span class="number">247</span> <span class="number">46</span> <span class="number">50</span>; <span class="number">193</span> <span class="number">36</span> <span class="number">46</span>; <span class="number">202</span> <span class="number">37</span> <span class="number">62</span>; <span class="number">176</span> <span class="number">37</span> <span class="number">54</span>; <span class="number">157</span> <span class="number">32</span> <span class="number">52</span>; <span class="number">156</span> <span class="number">33</span> <span class="number">54</span>; <span class="number">138</span> <span class="number">33</span> <span class="number">68</span>];</span><br><span class="line">Y=[<span class="number">5</span> <span class="number">162</span> <span class="number">60</span>; <span class="number">2</span> <span class="number">110</span> <span class="number">60</span>; <span class="number">12</span> <span class="number">101</span> <span class="number">101</span>; <span class="number">12</span> <span class="number">105</span> <span class="number">37</span>; <span class="number">13</span> <span class="number">155</span> <span class="number">58</span>; <span class="number">4</span> <span class="number">101</span> <span class="number">42</span>; <span class="number">8</span> <span class="number">101</span> <span class="number">38</span>; <span class="number">6</span> <span class="number">125</span> <span class="number">40</span>; <span class="number">15</span> <span class="number">200</span> <span class="number">40</span>; <span class="number">17</span> <span class="number">251</span> <span class="number">250</span>; <span class="number">17</span> <span class="number">120</span> <span class="number">38</span>; <span class="number">13</span> <span class="number">210</span> <span class="number">115</span>; <span class="number">14</span> <span class="number">215</span> <span class="number">105</span>; <span class="number">1</span> <span class="number">50</span> <span class="number">50</span> ; <span class="number">6</span> <span class="number">70</span> <span class="number">31</span>; <span class="number">12</span> <span class="number">210</span> <span class="number">120</span>; <span class="number">4</span> <span class="number">60</span> <span class="number">25</span>; <span class="number">11</span> <span class="number">230</span> <span class="number">80</span>; <span class="number">15</span> <span class="number">225</span> <span class="number">73</span>; <span class="number">2</span> <span class="number">110</span> <span class="number">43</span>];</span><br><span class="line">[maxVV1,maxVV2,F,G]=dxxg(X,Y)</span><br><span class="line"></span><br><span class="line">maxVV1 =<span class="comment">%X的典型主轴</span></span><br><span class="line">    <span class="number">0.4405</span></span><br><span class="line">   <span class="number">-0.8971</span></span><br><span class="line">    <span class="number">0.0336</span></span><br><span class="line">maxVV2 =<span class="comment">%Y的典型主轴</span></span><br><span class="line">   <span class="number">-0.2645</span></span><br><span class="line">   <span class="number">-0.7976</span></span><br><span class="line">    <span class="number">0.5421</span></span><br><span class="line">F =<span class="comment">%X的典型成分</span></span><br><span class="line">    <span class="number">0.0247</span></span><br><span class="line">   <span class="number">-0.2819</span></span><br><span class="line">   <span class="number">-0.4627</span></span><br><span class="line">   <span class="number">-0.1566</span></span><br><span class="line">    <span class="number">0.2506</span></span><br><span class="line">   <span class="number">-0.1079</span></span><br><span class="line">   <span class="number">-0.1510</span></span><br><span class="line">    <span class="number">0.2035</span></span><br><span class="line">    <span class="number">1.2698</span></span><br><span class="line">    <span class="number">0.2331</span></span><br><span class="line">    <span class="number">0.1926</span></span><br><span class="line">    <span class="number">0.4286</span></span><br><span class="line">   <span class="number">-0.0098</span></span><br><span class="line">   <span class="number">-1.7782</span></span><br><span class="line">    <span class="number">0.0417</span></span><br><span class="line">   <span class="number">-0.0034</span></span><br><span class="line">   <span class="number">-0.5045</span></span><br><span class="line">    <span class="number">0.5482</span></span><br><span class="line">    <span class="number">0.2595</span></span><br><span class="line">    <span class="number">0.0036</span></span><br><span class="line">G =<span class="comment">%Y的典型成分</span></span><br><span class="line">   <span class="number">-0.0960</span></span><br><span class="line">    <span class="number">0.7170</span></span><br><span class="line">    <span class="number">0.7649</span></span><br><span class="line">    <span class="number">0.0373</span></span><br><span class="line">   <span class="number">-0.4281</span></span><br><span class="line">    <span class="number">0.5414</span></span><br><span class="line">    <span class="number">0.2990</span></span><br><span class="line">    <span class="number">0.1142</span></span><br><span class="line">   <span class="number">-1.2921</span></span><br><span class="line">    <span class="number">0.1779</span></span><br><span class="line">   <span class="number">-0.3935</span></span><br><span class="line">   <span class="number">-0.5266</span></span><br><span class="line">   <span class="number">-0.7461</span></span><br><span class="line">    <span class="number">1.4262</span></span><br><span class="line">    <span class="number">0.7202</span></span><br><span class="line">   <span class="number">-0.4237</span></span><br><span class="line">    <span class="number">0.8843</span></span><br><span class="line">   <span class="number">-1.0515</span></span><br><span class="line">   <span class="number">-1.2619</span></span><br><span class="line">    <span class="number">0.5373</span></span><br></pre></td></tr></table></figure><h2 id="方差分析-2">方差分析</h2><h3 id="单因素方差分析">单因素方差分析</h3><p>anoval(X,group) group——标识箱线图中的坐标</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">X=[<span class="number">4.3</span>  <span class="number">6.1</span>  <span class="number">6.5</span>  <span class="number">9.3</span>  <span class="number">9.5</span>; <span class="number">7.8</span>  <span class="number">7.3</span>  <span class="number">8.3</span><span class="number">8.7</span> <span class="number">8.8</span>; <span class="number">3.2</span>  <span class="number">4.2</span>  <span class="number">8.6</span><span class="number">7.2</span><span class="number">11.4</span>; <span class="number">6.5</span>  <span class="number">4.1</span>  <span class="number">8.2</span>  <span class="number">10.1</span>  <span class="number">7.8</span>];</span><br><span class="line"><span class="built_in">mean</span>(X)</span><br><span class="line">[p,<span class="built_in">table</span>,stats]=anova1(X)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =<span class="comment">%样本均值</span></span><br><span class="line">    <span class="number">5.4500</span>    <span class="number">5.4250</span>    <span class="number">7.9000</span>    <span class="number">8.8250</span>    <span class="number">9.3750</span></span><br><span class="line">p =<span class="comment">%各列均值相等的概率值</span></span><br><span class="line">    <span class="number">0.0042</span></span><br><span class="line"><span class="built_in">table</span> =<span class="comment">%方差分析表</span></span><br><span class="line">  <span class="number">4</span>×<span class="number">6</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;来源&#x27;</span>&#125;    &#123;<span class="string">&#x27;SS&#x27;</span>     &#125;    &#123;<span class="string">&#x27;df&#x27;</span>&#125;    &#123;<span class="string">&#x27;MS&#x27;</span>      &#125;    &#123;<span class="string">&#x27;F&#x27;</span>       &#125;    &#123;<span class="string">&#x27;p 值(F)&#x27;</span> &#125;</span><br><span class="line">    &#123;<span class="string">&#x27;列&#x27;</span>  &#125;    &#123;[<span class="number">55.5370</span>]&#125;    &#123;[ <span class="number">4</span>]&#125;    &#123;[ <span class="number">13.8843</span>]&#125;    &#123;[  <span class="number">6.0590</span>]&#125;    &#123;[  <span class="number">0.0042</span>]&#125;</span><br><span class="line">    &#123;<span class="string">&#x27;误差&#x27;</span>&#125;    &#123;[<span class="number">34.3725</span>]&#125;    &#123;[<span class="number">15</span>]&#125;    &#123;[  <span class="number">2.2915</span>]&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> double&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> double&#125;</span><br><span class="line">    &#123;<span class="string">&#x27;合计&#x27;</span>&#125;    &#123;[<span class="number">89.9095</span>]&#125;    &#123;[<span class="number">19</span>]&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> double&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> double&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> double&#125;</span><br><span class="line">stats = <span class="comment">%结果结构体</span></span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">    gnames: [<span class="number">5</span>×<span class="number">1</span> char]</span><br><span class="line">         n: [<span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="number">4</span>]</span><br><span class="line">    source: <span class="string">&#x27;anova1&#x27;</span></span><br><span class="line">     means: [<span class="number">5.4500</span> <span class="number">5.4250</span> <span class="number">7.9000</span> <span class="number">8.8250</span> <span class="number">9.3750</span>]</span><br><span class="line">        df: <span class="number">15</span></span><br><span class="line">         s: <span class="number">1.5138</span></span><br></pre></td></tr></table></figure><h3 id="双因素方差分析">双因素方差分析</h3><p>anova2(X,reps) reps——试验重复次数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">X=[<span class="number">58.2</span>    <span class="number">52.6</span> <span class="number">56.2</span> <span class="number">41.2</span>    <span class="number">65.3</span> <span class="number">60.8</span>;<span class="number">49.1</span> <span class="number">42.8</span> <span class="number">54.1</span> <span class="number">50.5</span> <span class="number">51.6</span> <span class="number">48.4</span>;<span class="number">60.1</span> <span class="number">58.3</span>    <span class="number">70.9</span> <span class="number">73.2</span>    <span class="number">39.2</span> <span class="number">40.7</span>;<span class="number">75.8</span> <span class="number">71.5</span>    <span class="number">58.2</span> <span class="number">51</span>    <span class="number">48.7</span> <span class="number">41.4</span>];</span><br><span class="line">[p,<span class="built_in">table</span>,stats]=anova2(X&#x27;,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p =</span><br><span class="line">    <span class="number">0.0260</span>    <span class="number">0.0035</span>    <span class="number">0.0001</span></span><br><span class="line"><span class="built_in">table</span> =</span><br><span class="line">  <span class="number">6</span>×<span class="number">6</span> cell 数组</span><br><span class="line">    &#123;<span class="string">&#x27;来源&#x27;</span>   &#125;    &#123;<span class="string">&#x27;SS&#x27;</span>        &#125;    &#123;<span class="string">&#x27;df&#x27;</span>&#125;    &#123;<span class="string">&#x27;MS&#x27;</span>      &#125;    &#123;<span class="string">&#x27;F&#x27;</span>       &#125;    &#123;<span class="string">&#x27;p 值(F)&#x27;</span>   &#125;</span><br><span class="line">    &#123;<span class="string">&#x27;列&#x27;</span>     &#125;    &#123;[  <span class="number">261.6750</span>]&#125;    &#123;[ <span class="number">3</span>]&#125;    &#123;[ <span class="number">87.2250</span>]&#125;    &#123;[  <span class="number">4.4174</span>]&#125;    &#123;[    <span class="number">0.0260</span>]&#125;</span><br><span class="line">    &#123;<span class="string">&#x27;行&#x27;</span>     &#125;    &#123;[  <span class="number">370.9808</span>]&#125;    &#123;[ <span class="number">2</span>]&#125;    &#123;[<span class="number">185.4904</span>]&#125;    &#123;[  <span class="number">9.3939</span>]&#125;    &#123;[    <span class="number">0.0035</span>]&#125;</span><br><span class="line">    &#123;<span class="string">&#x27;交互效应&#x27;</span>&#125;    &#123;[<span class="number">1.7687e+03</span>]&#125;    &#123;[ <span class="number">6</span>]&#125;    &#123;[<span class="number">294.7821</span>]&#125;    &#123;[ <span class="number">14.9288</span>]&#125;    &#123;[<span class="number">6.1511e-05</span>]&#125;</span><br><span class="line">    &#123;<span class="string">&#x27;误差&#x27;</span>   &#125;    &#123;[  <span class="number">236.9500</span>]&#125;    &#123;[<span class="number">12</span>]&#125;    &#123;[ <span class="number">19.7458</span>]&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> double&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> double  &#125;</span><br><span class="line">    &#123;<span class="string">&#x27;合计&#x27;</span>   &#125;    &#123;[<span class="number">2.6383e+03</span>]&#125;    &#123;[<span class="number">23</span>]&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> double&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> double&#125;    &#123;<span class="number">0</span>×<span class="number">0</span> double  &#125;</span><br><span class="line">stats = </span><br><span class="line">  包含以下字段的 struct:</span><br><span class="line">      source: <span class="string">&#x27;anova2&#x27;</span></span><br><span class="line">     sigmasq: <span class="number">19.7458</span></span><br><span class="line">    colmeans: [<span class="number">55.7167</span> <span class="number">49.4167</span> <span class="number">57.0667</span> <span class="number">57.7667</span>]</span><br><span class="line">        coln: <span class="number">6</span></span><br><span class="line">    rowmeans: [<span class="number">58.5500</span> <span class="number">56.9125</span> <span class="number">49.5125</span>]</span><br><span class="line">        rown: <span class="number">8</span></span><br><span class="line">       inter: <span class="number">1</span></span><br><span class="line">        pval: <span class="number">6.1511e-05</span></span><br><span class="line">          df: <span class="number">12</span></span><br></pre></td></tr></table></figure><h1>数据拟合与插值</h1><h2 id="数据插值">数据插值</h2><h3 id="拉格朗日插值">拉格朗日插值</h3>]]></content>
      
      
      <categories>
          
          <category> 数模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人类观察录前言</title>
      <link href="/2024/06/10/guancha/%E8%A7%82%E5%AF%9F%E5%BD%95%E5%89%8D%E8%A8%80/"/>
      <url>/2024/06/10/guancha/%E8%A7%82%E5%AF%9F%E5%BD%95%E5%89%8D%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1>写在前面</h1><p>这里收集了各式各样的人~明媚的，深沉的，我真诚地想记录下来每一个有趣的灵魂（才不要在时间的长河里抹掉你们的印记），欢迎常来看看我的赛博收集手册~</p><blockquote><p>说不定你就是其中珍贵的一页呢？</p></blockquote><p>这个分类其实想写一些奇幻经历，会慢慢更新哒，包括但不限于一些恐怖故事，害怕的宝宝晚上慎看🍀</p><p>还有一本万言书（希望还有时间以连载的形式更完），颠沛流离的结局兴许不是繁花似锦，但起码不应当被遗忘。机械化的时代太过嘈杂，灵感也会随之枯竭，或许只有事无巨细地刻画下来，忘记的时候才不会那么怅然若失。愿未来某时的你，灵魂尚有余温。</p><p>还有还有，可能会夹杂一些寻人启事，人和人的相遇真的全凭缘分，有些人错过就是错过了，甚至连说再见的机会都没有，想在这里写下我仅存的印象，如果各位或者本人有幸能看到的话还请留下联系方式，这对我很重要，谢谢谢谢！！！</p><p>好像有点多？哈哈，因为这些同等重要💕</p><blockquote><p>声明：本人向来身体健康，精神状态正常</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 人类观猹录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 观猹 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP</title>
      <link href="/2024/05/24/shuju/DP/"/>
      <url>/2024/05/24/shuju/DP/</url>
      
        <content type="html"><![CDATA[<h1>背包问题</h1><p><a href="https://www.cnblogs.com/jbelial/articles/2116074.html#:~:text=%E5%88%86%E7%BB%84%E7%9A%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%B0%86%E5%BD%BC%E6%AD%A4">背包九讲问题-dd大牛的《背包九讲》</a></p><h2 id="0-1背包问题">0-1背包问题</h2><p>有n 个物品，它们有各自的体积/重量和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？</p><p>每件物品只有一个</p><h3 id="思路">思路</h3><p><img src="https://pic.imgdb.cn/item/6700f2bed29ded1a8ccdf41c.jpg" alt=""></p><h3 id="二维（朴素）">二维（朴素）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n ;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= m;j++)&#123;</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= v[i]) f[i][j] = <span class="built_in">max</span>(f[i][j],f[i - <span class="number">1</span>][j - v[i]]+ w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一维优化（滚动数组）">一维优化（滚动数组）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n ;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m;j &gt;=v[i];j--)&#123;<span class="comment">//j从0-v[i-1]没有意义，逆序</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j],f[j - v[i]]+ w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/solution/content/1374/">极好的题解</a></p><h2 id="完全背包问题">完全背包问题</h2><p>有n 个物品，它们有各自的体积/重量和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？</p><p>每件物品有无限个</p><h3 id="思路-2">思路</h3><p><img src="https://pic.imgdb.cn/item/6700fee7d29ded1a8cd8fded.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/67010171d29ded1a8cdb5f8a.jpg" alt=""></p><h3 id="朴素">朴素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n ;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= m;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k*v[i] &lt;= j;k++)&#123;</span><br><span class="line">                 f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-k*v[i]]+k*w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化-简化内部关系">优化(简化内部关系)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n ;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= m;j++)&#123;</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j-v[i]&gt;=<span class="number">0</span>)</span><br><span class="line">                f[i][j]=<span class="built_in">max</span>(f[i][j],f[i][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一维优化">一维优化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i&lt;=n ;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= m;j++)&#123;<span class="comment">//从小到大循环</span></span><br><span class="line">            <span class="keyword">if</span>(j-v[i]&gt;=<span class="number">0</span>)</span><br><span class="line">                f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">            <span class="comment">//当前不放的状态和放了的状态比较</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多重背包问题">多重背包问题</h2><p>有n 个物品，它们有各自的体积/重量和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？</p><p>每件物品有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>个</p><h3 id="思路-3">思路</h3><p><img src="https://pic.imgdb.cn/item/67011609d29ded1a8cedf669.jpg" alt=""></p><h3 id="朴素-2">朴素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> f[N][N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n ;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= m;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k*v[i] &lt;= j &amp;&amp; k &lt;= s[i];k++)&#123;</span><br><span class="line">                 f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-k*v[i]]+k*w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化（二进制优化、0-1背包）">优化（二进制优化、0-1背包）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25000</span>,M=<span class="number">2010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N]=&#123;<span class="number">0</span>&#125;,w[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> f[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a,b,s;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> k=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;=s)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            v[cnt] = a*k;</span><br><span class="line">            w[cnt] = b*k;</span><br><span class="line">            s-=k;</span><br><span class="line">            k *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            v[cnt] = a*s;</span><br><span class="line">            w[cnt] = b*s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    n = cnt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n ;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m;j &gt;= v[i];j--)&#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分组背包问题">分组背包问题</h2><p>有 N 组物品和一个容量是 V 的背包。每组物品有若干个，同一组内的物品最多只能选一个。每件物品的体积是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">v_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>，价值是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">w_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>，其中 i 是组号，j 是组内编号。求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p><h3 id="思路-4">思路</h3><p><img src="https://cdn.acwing.com/media/article/image/2019/08/06/1606_ecd551d6b7-%E6%8D%95%E8%8E%B7.PNG" alt=""></p><h3 id="优化（0-1背包）">优化（0-1背包）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N][N],w[N][N],s[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; s[i];j++)&#123;<span class="comment">//注意</span></span><br><span class="line">            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">// 遍历每一组物品  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; --j) <span class="comment">// 遍历背包容量从m到0  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; s[i]; ++k) <span class="comment">// 遍历第i组中的每个物品  </span></span><br><span class="line">            <span class="keyword">if</span> (v[i][k] &lt;= j) <span class="comment">// 如果当前物品可以放入背包中  </span></span><br><span class="line">                <span class="comment">// 更新背包的最大价值，考虑放入当前物品或不放入的情况  </span></span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);  </span><br><span class="line">                </span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>线性DP</h1>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap</title>
      <link href="/2024/05/24/shuju/HashMap/"/>
      <url>/2024/05/24/shuju/HashMap/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/check-if-a-string-contains-all-binary-codes-of-size-k/">1461. 检查一个字符串是否包含所有长度为 K 的二进制子串</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasAllCodes</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;string&gt; set;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + k &lt;= s.<span class="built_in">size</span>(); i ++) set.<span class="built_in">insert</span>(s.<span class="built_in">substr</span>(i, k));</span><br><span class="line">        <span class="keyword">return</span> set.<span class="built_in">size</span>() == (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/">2841. 几乎唯一子数组的最大和</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> m, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123; <span class="comment">// 先统计 k-1 个数</span></span><br><span class="line">            sum += nums[i];</span><br><span class="line">            cnt[nums[i]]++;<span class="comment">//处理前两个元素：cnt = &#123;1: 1, 2: 1&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k - <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            sum += nums[i]; <span class="comment">// 再添加一个数就是 k 个数了</span></span><br><span class="line">            cnt[nums[i]]++;</span><br><span class="line">            <span class="keyword">if</span> (cnt.<span class="built_in">size</span>() &gt;= m)</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> out = nums[i - k + <span class="number">1</span>];</span><br><span class="line">            sum -= out; <span class="comment">// 下一个子数组不包含 out，移出窗口</span></span><br><span class="line">            <span class="keyword">if</span> (--cnt[out] == <span class="number">0</span>)</span><br><span class="line">                cnt.<span class="built_in">erase</span>(out);<span class="comment">//删除元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-number-of-occurrences-of-a-substring/">1297. 子串的最大出现次数</a></p><p>substr()操作和unordered_set的用法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxFreq</span><span class="params">(string s, <span class="type">int</span> maxLetters, <span class="type">int</span> minSize, <span class="type">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>() - minSize + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            string str = s.<span class="built_in">substr</span>(i, minSize);</span><br><span class="line">            <span class="function">unordered_set&lt;<span class="type">char</span>&gt; <span class="title">exist</span><span class="params">(str.begin(), str.end())</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (exist.<span class="built_in">size</span>() &lt;= maxLetters)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt[str] ++ ;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, cnt[str]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">排序算法</th><th>最坏时间复杂度</th><th>最优时间复杂度</th><th>平均时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td style="text-align:left"><strong>插入排序（Insertion Sort, IS）</strong></td><td><code>O(n^2)</code></td><td><code>O(n)</code></td><td><code>O(n^2)</code></td><td><code>O(1)</code></td></tr><tr><td style="text-align:left"><strong>自顶向下归并排序（MergeX）</strong></td><td><code>O(n log n)</code></td><td><code>O(n log n)</code></td><td><code>O(n log n)</code></td><td><code>O(n)</code></td></tr><tr><td style="text-align:left"><strong>自底向上归并排序（MergeBU）</strong></td><td><code>O(n log n)</code></td><td><code>O(n log n)</code></td><td><code>O(n log n)</code></td><td><code>O(n)</code></td></tr><tr><td style="text-align:left"><strong>随机快速排序（Quick）</strong></td><td><code>O(n^2)</code></td><td><code>O(n log n)</code></td><td><code>O(n log n)</code></td><td><code>O(log n)</code></td></tr><tr><td style="text-align:left"><strong>三向划分快速排序（Quick3way）</strong></td><td><code>O(n^2)</code></td><td><code>O(n log n)</code></td><td><code>O(n log n)</code></td><td><code>O(log n)</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++STL</title>
      <link href="/2024/05/24/shuju/c++STL/"/>
      <url>/2024/05/24/shuju/c++STL/</url>
      
        <content type="html"><![CDATA[<h1>&lt;vector&gt;</h1><p>可变长数组，倍增思想，支持随机访问，不支持任意位置O(1)插入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; b[<span class="number">233</span>]; <span class="comment">//第一维长233，第二维动态变化</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rec</span>&#123;&#125;;</span><br><span class="line">vector&lt;rec&gt; c;<span class="comment">//自定义结构体</span></span><br></pre></td></tr></table></figure><p>size/empty，clear，push_back/pop_back</p><p>begin/end，容器[)，end返回第n个元素再往后的边界</p><p>front/back，front = *a.bsgin()/a[0]；back = *–a.end()/a[size() - 1]</p><blockquote><p>迭代器：指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; ::iterator it;<span class="comment">//保存int的迭代器</span></span><br></pre></td></tr></table></figure></blockquote><h1>&lt;queue&gt;</h1><h2 id="循环队列-queue">循环队列&lt;queue&gt;</h2><p>O(1)，push，pop，front，back</p><h2 id="优先队列-priority-queue">优先队列&lt;priority_queue&gt;</h2><p>较大元素在堆顶</p><table><thead><tr><th>方法</th><th>复杂度</th></tr></thead><tbody><tr><td>push</td><td>O(logn)</td></tr><tr><td>pop</td><td>O(logn)</td></tr><tr><td>top</td><td>O(1)</td></tr></tbody></table><h2 id="重载“-”运算符">重载“&lt;”运算符</h2><p>用于使用自定义的结构体类型</p><h2 id="懒惰删除法">懒惰删除法</h2><p>先给要删除的数打一个标记，等它到堆顶的时候，删除</p><h1>双端队列 &lt;deque&gt;</h1><p>支持随机访问</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">复杂度</th></tr></thead><tbody><tr><td style="text-align:center">front/back</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">push_back</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">push_front</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">pop_front</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">pop_back</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">clear</td><td style="text-align:center">O(n)</td></tr></tbody></table><h1>头文件&lt;set&gt;</h1><h2 id="set-有序集合">set 有序集合</h2><p>元素不重复</p><h2 id="multiset-有序多重集">multiset 有序多重集</h2><p>元素可重复</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rec</span>&#123;...&#125;;</span><br><span class="line">set rec s;<span class="comment">//必须定义“小于号”运算符</span></span><br><span class="line">multiset&lt;<span class="type">double</span>&gt; s;</span><br></pre></td></tr></table></figure><p>双向迭代器：O(logn)，++指向下一名元素，不支持随机访问，支持<code>*</code>的解除引用</p><p>insert:O(logn)</p><p>find(x):找到x元素，返回指向该元素的迭代器，不存在就返回s.end()</p><p>lower_bound/upper_bound:O(logn)，查找&gt;=x元素中最小/最大的一个</p><p>erase:</p><ul><li>迭代器：删除该迭代器指向的元素O(logn)</li><li>元素：删除所有相同的元素O(logn+k)</li></ul><p>count</p><h1>&lt;map&gt;</h1><p>key-value，以key为关键字的红黑树，key定义“小于号”运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;key_type,vlue_type&gt; name;</span><br></pre></td></tr></table></figure><p>迭代器：双向访问迭代器</p><p>set/empty/clear/begin/end</p><p>insert/erase :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;key_type,vlue_type&gt;<span class="comment">//insert</span></span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; h;</span><br><span class="line">h.<span class="built_in">insert</span>(meak_pair&lt;<span class="number">1</span>,<span class="number">2</span>&gt;),h.<span class="built_in">insert</span>(meak_pair&lt;<span class="number">2</span>,<span class="number">3</span>&gt;);</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator it = h.<span class="built_in">begin</span>();</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p = * it;</span><br><span class="line">h.<span class="built_in">erase</span>(it),h.<span class="built_in">erase</span>(<span class="built_in">meak_pair</span>(<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">cout &lt;&lt; p.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>[]操作符：O(logn) h[key],返回key映射的value的引用，可进行赋值操作。若查找的value不存在，则创建一个(ket,zero)。可以先用find查询key的存在性。</p><blockquote><p>zero:广义0值</p></blockquote><h1>&lt;bitset&gt;</h1><p>多位二进制数，8位一字节</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;10000&gt; s;<span class="comment">//1000位二进制数</span></span><br></pre></td></tr></table></figure><p>~s：返回对bitsset s按位取反的结果</p><p>&amp;,|,^：位数相同的bitset按位与，或，以或运算</p><p>&gt;&gt;,&lt;&lt;：右移/左移</p><p>==,!=：比较相等</p><p>s[k]：s的第k位，最低位为s[0]</p><p>count：返回有多少位为1</p><p>any/none：s所有位为0，s.none()=true;否则s.any()=true</p><p>set/reset/flip：</p><ul><li>s.set() 所有位置1</li><li>s.set(k,v) s[k] = v</li><li>s.reset(k) 第k位置0</li><li>s.flip(k) 第k位取反</li></ul><h1>&lt;algorithm&gt;</h1><p>用于序列</p><h2 id="reverse-翻转">reverse 翻转</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reberse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());<span class="comment">//也可放数组下标</span></span><br></pre></td></tr></table></figure><h2 id="unique-去重">unique 去重</h2><p>返回去重之后末尾元素的下一个位置，用于离散化，指针加减计算去重后的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m = <span class="built_in">unique</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()) - a.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure><h2 id="random-shuffle-随机打乱">random_shuffle 随机打乱</h2><p>用法同revsrse</p><h2 id="next-permutation-下一个排列">next_permutation 下一个排列</h2><p>两个指针的区域为一个排列，求这些元素构成的全排列中字典序排在下一个的序列，若不存在，返回false。prev_permutation同理。</p><h2 id="sort-快排">sort 快排</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</span><br></pre></td></tr></table></figure><h2 id="lower-bound-upper-bound-二分">lower_bound/upper_bound 二分</h2><p>lower_bound返回指向&gt;=x的元素位置的迭代器；</p><p>upper_bound返回指向=x的元素位置的迭代器。</p><blockquote><p>两指针指定的部分应该是提前排序好的</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learning_O代码梳理</title>
      <link href="/2024/03/18/NER/Learing_o/"/>
      <url>/2024/03/18/NER/Learing_o/</url>
      
        <content type="html"><![CDATA[<h1>主函数</h1><h2 id="创建解释器，添加命令行参数">创建解释器，添加命令行参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(...)</span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure><h2 id="设置随机数种子以及每个任务包含的的标签数量">设置随机数种子以及每个任务包含的的标签数量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_seed(args)</span><br><span class="line">per_types = args.per_types</span><br></pre></td></tr></table></figure><h2 id="持续学习">持续学习</h2><p>迭代每个任务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> step_id <span class="keyword">in</span> <span class="built_in">range</span>(args.start_step, args.nb_tasks)</span><br></pre></td></tr></table></figure><p>获取当前任务的标签集，标签数量和 PAD ids。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">labels = get_labels_dy(args.labels, per_types, step_id=step_id)</span><br><span class="line">num_labels = <span class="built_in">len</span>(labels)</span><br><span class="line">pad_token_label_id = CrossEntropyLoss().ignore_index</span><br></pre></td></tr></table></figure><p>设置 model_name_or_path</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果是第一轮，则加载 bert-base-uncased 模型</span></span><br><span class="line"><span class="keyword">if</span> step_id == <span class="number">0</span>:</span><br><span class="line">    model_name_or_path = <span class="string">&quot;bert-base-uncased&quot;</span> </span><br><span class="line"><span class="keyword">else</span>: <span class="comment"># 否则加载上一轮模型</span></span><br><span class="line">    model_name_or_path = os.path.join(args.output_dir, <span class="string">&quot;task_&quot;</span> + <span class="built_in">str</span>(step_id - <span class="number">1</span>))      </span><br></pre></td></tr></table></figure><p>训练和评价模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_and_eval(args, labels, num_labels, pad_token_label_id, model_name_or_path,output_dir, data_dir, step_id)</span><br></pre></td></tr></table></figure><h1>准备数据集</h1><h2 id="read-examples-from-file">read_examples_from_file()</h2><h2 id="convert-examples-to-features">convert_examples_to_features()</h2><h2 id="load-and-cache-examples">load_and_cache_examples()</h2><h3 id="从文件中加载样本特征">从文件中加载样本特征</h3><p>如果 cached_features_file 存在，则直接从该文件中加载特征</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">features = torch.load(cached_features_file)</span><br></pre></td></tr></table></figure><p>否则先处理原始数据，再加载特征</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">examples = read_examples_from_file(data_dir, mode)</span><br><span class="line">features = convert_examples_to_features(...)</span><br></pre></td></tr></table></figure><h3 id="提取features的属性并构建数据集">提取features的属性并构建数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">all_input_ids = torch.tensor([f.input_ids <span class="keyword">for</span> f <span class="keyword">in</span> features], dtype=torch.long)</span><br><span class="line">all_input_mask = torch.tensor([f.input_mask <span class="keyword">for</span> f <span class="keyword">in</span> features], dtype=torch.long)</span><br><span class="line">all_segment_ids = torch.tensor([f.segment_ids <span class="keyword">for</span> f <span class="keyword">in</span> features], dtype=torch.long)</span><br><span class="line">all_label_ids = torch.tensor([f.label_ids <span class="keyword">for</span> f <span class="keyword">in</span> features], dtype=torch.long)</span><br><span class="line">dataset = TensorDataset(all_input_ids, all_input_mask, all_segment_ids, all_label_ids)</span><br></pre></td></tr></table></figure><h3 id="返回该数据集">返回该数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> dataset</span><br></pre></td></tr></table></figure><h1>工具函数</h1><h2 id="get-exemplar-means">get_exemplar_means()</h2><p><strong>计算每个类别的原型，即均值向量</strong></p><h3 id="1-将每个样本按标签分类">1. 将每个样本按标签分类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建了一个字典，包含了所有可能的类别索引，每个类别对应一个空列表</span></span><br><span class="line">cls_exemplar = &#123;cls: [] <span class="keyword">for</span> cls <span class="keyword">in</span> <span class="built_in">range</span>(n_tags)&#125;  。</span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(support_reps, support_labels):</span><br><span class="line">    <span class="comment"># 将每个样本按照标签分类存储在cls_exemplar字典中</span></span><br><span class="line">    cls_exemplar[y.item()].append(x)</span><br></pre></td></tr></table></figure><h3 id="计算每个类别的原型">计算每个类别的原型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> cls, exemplar <span class="keyword">in</span> cls_exemplar.items():</span><br><span class="line">    features = []</span><br><span class="line">    <span class="keyword">for</span> feature <span class="keyword">in</span> exemplar:</span><br><span class="line">        feature.data = feature.data / feature.data.norm()  <span class="comment"># Normalize  </span></span><br><span class="line">        features.append(feature)</span><br><span class="line">        <span class="comment"># 如果当前类别下没有样本，则随机初始化一个与样本表示reps大小相同的张量作为该类别的原型</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(features) == <span class="number">0</span>:</span><br><span class="line">            mu_y = torch.normal(<span class="number">0</span>, <span class="number">1</span>, size=<span class="built_in">tuple</span>(x.size())).to(args.device)</span><br><span class="line">            mu_y = mu_y.squeeze()  </span><br><span class="line">        <span class="comment"># 如果有，则计算当前类别的所有样本的reps的均值作为原型</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            features = torch.stack(features) </span><br><span class="line">            mu_y = features.mean(<span class="number">0</span>).squeeze()</span><br><span class="line">        mu_y.data = mu_y.data / mu_y.data.norm()  <span class="comment"># Normalize  </span></span><br><span class="line">        exemplar_means[cls] = mu_y</span><br></pre></td></tr></table></figure><h3 id="返回包含每个类别原型的列表">返回包含每个类别原型的列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> exemplar_means</span><br></pre></td></tr></table></figure><h2 id="get-support-encodings-and-labels-total">get_support_encodings_and_labels(_total)()</h2><p><strong>获取支持集的encodings和labels</strong></p><h3 id="获取train-loader，support-loader，support-o-loader中的encodings和labels">获取train_loader，support_loader，support_o_loader中的encodings和labels</h3><p>获取train_loader中每个批次的encodings和labels(仅get_support_encodings_and_labels_total)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">train_iterator = tqdm(train_loader, desc=<span class="string">&quot;Support data representations&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> index, batch <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_iterator):</span><br><span class="line">    encodings, labels = get_token_encodings_and_labels(args, model, batch)</span><br><span class="line">    encodings = encodings.view(-<span class="number">1</span>, encodings.shape[-<span class="number">1</span>])</span><br><span class="line">    labels = labels.flatten()</span><br><span class="line">    <span class="comment"># 过滤掉标签为填充标记的部分</span></span><br><span class="line">    idx = torch.where((labels - pad_token_label_id) != <span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">    support_encodings.append(encodings[idx])</span><br><span class="line">    support_labels.append(labels[idx])</span><br></pre></td></tr></table></figure><p>同样的操作获取support_loader和support_o_loader中每个批次的encodings和labels</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">support_iterator = tqdm(support_loader, desc=<span class="string">&quot;Support data representations&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> index, batch <span class="keyword">in</span> <span class="built_in">enumerate</span>(support_iterator):</span><br><span class="line">        ...</span><br><span class="line">support_o_iterator = tqdm(support_o_loader, desc=<span class="string">&quot;Support data representations&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _, batch <span class="keyword">in</span> <span class="built_in">enumerate</span>(support_o_iterator):</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><h3 id="返回所有的encodings和labels">返回所有的encodings和labels</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> torch.cat(support_encodings), torch.cat(support_labels)</span><br></pre></td></tr></table></figure><h2 id="get-token-logits-and-labels">get_token_logits_and_labels</h2><p><strong>使用原有的预训练BERT-NER模型获取预测分数和输出标签</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    inputs = &#123;<span class="string">&quot;input_ids&quot;</span>: batch[<span class="number">0</span>], <span class="string">&quot;attention_mask&quot;</span>: batch[<span class="number">1</span>], </span><br><span class="line">                <span class="string">&quot;output_hidden_states&quot;</span>: <span class="literal">True</span>, <span class="string">&quot;mode&quot;</span>: <span class="string">&quot;dev&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> model.config.model_type != <span class="string">&quot;distilbert&quot;</span>:</span><br><span class="line">        inputs[<span class="string">&quot;token_type_ids&quot;</span>] = (batch[<span class="number">2</span>] <span class="keyword">if</span> model.config.model_type <span class="keyword">in</span> [<span class="string">&quot;bert&quot;</span>, <span class="string">&quot;xlnet&quot;</span>] </span><br><span class="line">                                    <span class="keyword">else</span> <span class="literal">None</span>)  <span class="comment"># XLM and RoBERTa don&quot;t use token_type_ids</span></span><br><span class="line">        outputs = model(**inputs)</span><br><span class="line">        logits = outputs[-<span class="number">1</span>] </span><br><span class="line"><span class="keyword">return</span> logits, label_batch</span><br></pre></td></tr></table></figure><h2 id="get-rehearsal-prototype">get_rehearsal_prototype()</h2><h3 id="加载支持集以及它们的encodings和labels">加载支持集以及它们的encodings和labels</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">support_dataset = load_and_cache_examples(args, tokenizer, labels, pad_token_label_id, mode=<span class="string">&quot;memory&quot;</span>, data_dir=data_dir)</span><br><span class="line">support_o_dataset = load_and_cache_examples(args, tokenizer, labels, pad_token_label_id, mode=<span class="string">&quot;memory_o&quot;</span>, data_dir=data_dir)</span><br><span class="line">support_sampler = SequentialSampler(support_dataset)</span><br><span class="line">support_dataloader = DataLoader(support_dataset, sampler=support_sampler, batch_size=args.eval_batch_size)</span><br><span class="line">support_o_dataloader = DataLoader(support_o_dataset, sampler=support_o_sampler, batch_size=args.eval_batch_size)</span><br><span class="line">support_encodings, support_labels = get_support_features_and_labels(args, model, support_dataloader, support_o_dataloader, pad_token_label_id)</span><br><span class="line"><span class="comment"># 将support_encodings归一化</span></span><br><span class="line">support_encodings = F.normalize(support_encodings)</span><br></pre></td></tr></table></figure><h3 id="计算类别相似度">计算类别相似度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(labels)):  <span class="comment"># 迭代每个非&quot;O&quot;标签的类别</span></span><br><span class="line">    <span class="comment"># 计算类别i的样本之间的余弦相似度</span></span><br><span class="line">    support_reps_dists = torch.matmul(support_encodings[support_labels == i],</span><br><span class="line">                                          support_encodings[support_labels == i].T)</span><br><span class="line">    <span class="comment"># 将对角线上的元素（样本与自身的相似度）设置为0，以避免将自身视为原型。</span></span><br><span class="line">    support_reps_dists = torch.scatter(support_reps_dists, <span class="number">1</span>, torch.arange(support_reps_dists.shape[<span class="number">0</span>]).view(-<span class="number">1</span>, <span class="number">1</span>).to(args.device),<span class="number">0.</span>)</span><br><span class="line">    <span class="comment"># 计算类别i的类别相似度</span></span><br><span class="line">    prototype_dists.append(support_reps_dists[support_reps_dists &gt; <span class="number">0</span>].view(-<span class="number">1</span>).mean(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h3 id="返回类别相似度列表">返回类别相似度列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> prototype_dists</span><br></pre></td></tr></table></figure><h1>定义模型</h1><h2 id="MySftBertModel">MySftBertModel()</h2><h3 id="初始化-init">初始化 init</h3><p>接受Bert配置参数以及其他自定义参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.per_types = per_types  <span class="comment"># 设置每轮任务的类型数量。</span></span><br><span class="line">self.feat_dim = feat_dim  <span class="comment"># 设置特征维度。</span></span><br><span class="line">self.hidden_size = config.hidden_size  <span class="comment"># 设置隐藏状态的大小。</span></span><br><span class="line">self.num_labels = config.num_labels  <span class="comment"># 设置标签数量。</span></span><br><span class="line">self.bert = BertModel(config, add_pooling_layer=<span class="literal">False</span>) </span><br></pre></td></tr></table></figure><p>设置了分类器(classifier)和投影头(head)，根据mode选择性地设置分类器的输出层。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">classifier_dropout = (  <span class="comment"># 设置分类器的dropout概率</span></span><br><span class="line">            config.classifier_dropout <span class="keyword">if</span> config.classifier_dropout <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> config.hidden_dropout_prob</span><br><span class="line">        )</span><br><span class="line"><span class="keyword">if</span> mode == <span class="string">&quot;train&quot;</span>:  <span class="comment"># 根据不同模式设置线性分类器的不同输出维度</span></span><br><span class="line">    <span class="keyword">if</span> self.num_labels-<span class="number">1</span> &gt; self.per_types:  <span class="comment"># 对“O”样本重新标记过</span></span><br><span class="line">        self.classifier = nn.Linear(config.hidden_size, config.num_labels - self.per_types)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.classifier = nn.Linear(config.hidden_size, config.num_labels)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.classifier = nn.Linear(config.hidden_size, config.num_labels)</span><br></pre></td></tr></table></figure><p>设置不同的head（线性层或多层感知机）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> head == <span class="string">&#x27;linear&#x27;</span>:</span><br><span class="line">   self.head = nn.Linear(self.hidden_size, self.hidden_size)</span><br><span class="line"><span class="keyword">elif</span> head == <span class="string">&#x27;mlp&#x27;</span>:</span><br><span class="line">    self.head = nn.Sequential(</span><br><span class="line">        nn.Linear(self.hidden_size, self.hidden_size),</span><br><span class="line">        nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">        nn.Linear(self.hidden_size, self.feat_dim)</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> NotImplementedError(<span class="string">&#x27;head not supported: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(head))</span><br></pre></td></tr></table></figure><h3 id="前向传播-forward">前向传播 forward</h3><p><strong>提取特征</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用原有的Bert模型初步提取出样本的特征</span></span><br><span class="line">outputs = self.bert(...)</span><br><span class="line">features_enc = outputs[<span class="number">0</span>]   </span><br><span class="line"><span class="comment"># 通过self.head对进一步提取出样本的特征并归一化。</span></span><br><span class="line">features = F.normalize(self.head(features_enc.view(-<span class="number">1</span>, self.hidden_size)), dim=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 使用初步特征进行预测</span></span><br><span class="line">sequence_output = outputs[<span class="number">0</span>]</span><br><span class="line">sequence_output = self.dropout(sequence_output)</span><br><span class="line">logits = self.classifier(sequence_output)</span><br></pre></td></tr></table></figure><p>如果不是训练模式，直接返回features_enc，features，logits</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loss = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> mode != <span class="string">&quot;train&quot;</span>:</span><br><span class="line">    <span class="keyword">return</span> loss, features_enc, features, logits</span><br></pre></td></tr></table></figure><p><strong>计算损失函数</strong><br>如果是第一轮训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> self.num_labels-<span class="number">1</span> == self.per_types:  </span><br><span class="line">    <span class="keyword">if</span> loss_name == <span class="string">&quot;supcon&quot;</span>:         loss = supcon_loss</span><br><span class="line">    <span class="keyword">elif</span> loss_name == <span class="string">&quot;supcon_o&quot;</span>:     loss = supcon_o_loss</span><br><span class="line">    <span class="keyword">elif</span> loss_name == <span class="string">&quot;supcon_o_ce&quot;</span>:  loss = supcon_o_loss+ce_loss</span><br><span class="line">    <span class="keyword">elif</span> loss_name == <span class="string">&quot;supcon_o_bce&quot;</span>: loss = supcon_o_loss + bce_loss</span><br><span class="line">    <span class="keyword">elif</span> loss_name == <span class="string">&quot;ce&quot;</span>:           loss = ce_loss</span><br><span class="line">    <span class="keyword">elif</span> loss_name == <span class="string">&quot;bce_o&quot;</span>:        loss = bce_loss</span><br><span class="line">    <span class="keyword">elif</span> loss_name == <span class="string">&quot;supcon_ce&quot;</span>:    loss = supcon_loss + ce_loss</span><br><span class="line">    <span class="keyword">elif</span> loss_name == <span class="string">&quot;supcon_bce&quot;</span>:   loss = supcon_loss + bce_loss</span><br></pre></td></tr></table></figure><p>如果不是第一轮训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> self.num_labels &gt; self.per_types: </span><br><span class="line">    <span class="comment"># 整理新类别标签labels_new，新类别样本的logits：student_new 以及</span></span><br><span class="line">    <span class="comment"># 旧类别样本的logits：s_logits，teacher模型的logits：old_logits</span></span><br><span class="line">    labels_new, student_new, s_logits, old_logits = gather_rh_ce( labels, t_logits, </span><br><span class="line">                                            logits, self.num_labels - self.per_types)</span><br><span class="line">    <span class="keyword">if</span> loss_name == <span class="string">&quot;supcon&quot;</span>:        loss = supcon_loss+kd_loss</span><br><span class="line">    <span class="keyword">elif</span> loss_name == <span class="string">&quot;supcon_nokd&quot;</span>: loss = supcon_loss</span><br><span class="line">    <span class="keyword">elif</span> loss_name == <span class="string">&quot;supcon_o&quot;</span>:    loss = supcon_o_loss+kd_loss</span><br><span class="line">    <span class="keyword">elif</span> loss_name == <span class="string">&quot;supcon_o_ce&quot;</span>: loss = supcon_o_loss+ce_loss+kd_loss</span><br><span class="line">    <span class="keyword">elif</span> loss_name == <span class="string">&quot;supcon_o_bce&quot;</span>:loss = supcon_o_loss + bce_loss</span><br><span class="line">    <span class="keyword">elif</span> loss_name == <span class="string">&quot;ce&quot;</span>:          loss = ce_loss+kd_loss</span><br><span class="line">    <span class="keyword">elif</span> loss_name == <span class="string">&quot;bce_o&quot;</span>:       loss = bce_loss</span><br><span class="line">    <span class="keyword">elif</span> loss_name == <span class="string">&quot;supcon_ce&quot;</span>:   loss = supcon_loss+ce_loss+kd_loss</span><br><span class="line">    <span class="keyword">elif</span> loss_name == <span class="string">&quot;supcon_bce&quot;</span>:  loss = supcon_loss+bce_loss</span><br></pre></td></tr></table></figure><h3 id="3-返回-loss-features-enc-features-logits">3. 返回 loss, features_enc, features, logits</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> loss, features_enc, features, logits</span><br></pre></td></tr></table></figure><h1>训练和评估模型</h1><h2 id="train-and-eval">train_and_eval( )</h2><h3 id="加载上一轮预训练的参数配置、模型和分词器">加载上一轮预训练的参数配置、模型和分词器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建模型配置、模型类别和分词器类</span></span><br><span class="line">config_class, model_class, tokenizer_class = MODEL_CLASSES[args.model_type]</span><br><span class="line"><span class="comment"># 如果是第一轮，则直接加载 bert-base-uncased 模型</span></span><br><span class="line">config = config_class.from_pretrained(args.config_name <span class="keyword">if</span> args.config_name <span class="keyword">else</span> model_name_or_path，num_labels=num_labels)</span><br><span class="line">tokenizer = tokenizer_class.from_pretrained(args.tokenizer_name <span class="keyword">if</span> args.tokenizer_name <span class="keyword">else</span> model_name_or_path,do_lower_case=args.do_lower_case)</span><br><span class="line">model = model_class.from_pretrained(model_name_or_path, from_tf=<span class="built_in">bool</span>(<span class="string">&quot;.ckpt&quot;</span> <span class="keyword">in</span> model_name_or_path),config=config)</span><br></pre></td></tr></table></figure><h3 id="获取训练集">获取训练集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># train_dataset=TensorDataset(all_input_ids, all_input_mask, all_segment_ids, all_label_ids)</span></span><br><span class="line">train_dataset=load_and_cache_examples(args,tokenizer,labels,pad_token_label_id,mode=<span class="string">&quot;rehearsal&quot;</span>,data_dir=data_dir)</span><br><span class="line"><span class="comment"># 顺序采样</span></span><br><span class="line">train_sampler = SequentialSampler(train_dataset) <span class="keyword">if</span> args.local_rank == -<span class="number">1</span> <span class="keyword">else</span> DistributedSampler(train_dataset)</span><br><span class="line"><span class="comment"># 创建训练数据加载器</span></span><br><span class="line">train_dataloader = DataLoader(train_dataset, sampler=train_sampler, batch_size=args.train_batch_size)  </span><br></pre></td></tr></table></figure><h3 id="获取旧模型的特征">获取旧模型的特征</h3><p><strong>teacher_evaluate()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果当前不是第一个任务，则需要对老师模型进行评估。</span></span><br><span class="line"><span class="keyword">if</span> step_id &gt; <span class="number">0</span>: </span><br><span class="line">    t_logits, out_new_labels = teacher_evaluate(args, train_dataloader, model, tokenizer,labels,</span><br><span class="line">                                                pad_token_label_id, mode=<span class="string">&quot;train&quot;</span>, data_dir=data_dir)</span><br><span class="line">    model.new_classifier()  <span class="comment"># 创建一个新的分类器</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    t_logits = <span class="literal">None</span></span><br><span class="line">    out_new_labels = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="训练模型">训练模型</h3><p><strong>train()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">global_step, tr_loss = train(args, train_dataset, train_dataloader, model, tokenizer, labels,</span><br><span class="line">                                pad_token_label_id, data_dir=data_dir, output_dir=output_dir,</span><br><span class="line">                                t_logits=t_logits, out_new_labels=out_new_labels)</span><br><span class="line"><span class="comment"># 保存训练过程中得到的模型参数、配置和分词器    </span></span><br><span class="line">model_to_save.save_pretrained(output_dir)</span><br><span class="line">tokenizer.save_pretrained(output_dir)</span><br><span class="line">torch.save(args, os.path.join(output_dir, <span class="string">&quot;training_args.bin&quot;</span>))                            </span><br></pre></td></tr></table></figure><h3 id="在开发集上评估模型">在开发集上评估模型</h3><p><strong>evaluate()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于每个检查点，加载模型并进行评估</span></span><br><span class="line"><span class="keyword">for</span> checkpoint <span class="keyword">in</span> checkpoints:</span><br><span class="line">    model = model_class.from_pretrained(checkpoint, mode=<span class="string">&quot;dev&quot;</span>)</span><br><span class="line">    train_dataloader=<span class="literal">None</span></span><br><span class="line">     _, result,  _ = evaluate(args, model, tokenizer, labels, pad_token_label_id, mode=<span class="string">&quot;dev&quot;</span>,</span><br><span class="line">                            data_dir=data_dir, prefix=global_step)</span><br></pre></td></tr></table></figure><h3 id="在测试集上进行预测">在测试集上进行预测</h3><p><strong>evaluate()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载模型和分词器</span></span><br><span class="line">tokenizer = tokenizer_class.from_pretrained(output_dir, do_lower_case=args.do_lower_case)</span><br><span class="line">model = model_class.from_pretrained(output_dir, mode=<span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="comment"># 调用 evaluate 函数对测试集进行预测，获取macro-F1和micro-F1结果以及预测的标签。</span></span><br><span class="line">macro_results, micro_results, predictions = evaluate(args, model, tokenizer, labels,</span><br><span class="line">                                                    pad_token_label_id, mode=<span class="string">&quot;test&quot;</span>, data_dir=data_dir)</span><br></pre></td></tr></table></figure><h2 id="teacher-evaluate">teacher_evaluate()</h2><h3 id="根据不同模式设置数据集加载器">根据不同模式设置数据集加载器</h3><p>如果模式是 “train”，，则使用训练数集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> mode == <span class="string">&quot;train&quot;</span>:</span><br><span class="line">    eval_dataloader = train_dataloader</span><br></pre></td></tr></table></figure><p>如果模式是 “dev”，则使用开发集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> mode == <span class="string">&quot;dev&quot;</span>:</span><br><span class="line">    eval_dataset = load_and_cache_examples(args, tokenizer, labels, pad_token_label_id, mode=mode,data_dir=data_dir)</span><br><span class="line">    eval_sampler = SequentialSampler(eval_dataset) <span class="keyword">if</span> args.local_rank == -<span class="number">1</span> <span class="keyword">else</span> DistributedSampler(eval_dataset)</span><br><span class="line">    eval_dataloader = DataLoader(eval_dataset, sampler=eval_sampler, batch_size=args.eval_batch_size)</span><br></pre></td></tr></table></figure><h3 id="评估模型">评估模型</h3><p>将模型设置为评估模式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.<span class="built_in">eval</span>()</span><br></pre></td></tr></table></figure><p>使用 get_token_logits_and_labels 函数获取每个batch的预测分数 logits 和输出标签 out_labels</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(eval_dataloader, desc=<span class="string">&quot;Evaluating&quot;</span>):</span><br><span class="line">    logits, out_labels = get_token_logits_and_labels(args, model, batch)</span><br><span class="line">    <span class="comment"># 对评估步骤计数，以便跟踪已评估的批次数量</span></span><br><span class="line">    nb_eval_steps += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将每个批次的 logits 分数添加到 logits_list 列表中</span></span><br><span class="line">    logits_list.append(logits.detach().cpu())</span><br></pre></td></tr></table></figure><h3 id="用原型重新标记阈值重新标记旧实体类">用原型重新标记阈值重新标记旧实体类</h3><p>计算原型重新标记阈值和与每个样本的原型相似度最高的实体类别<br><strong>evaluate()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算每个批次样本中原型相似度最大值所在的类别索引 preds</span></span><br><span class="line"><span class="comment"># 每个批次样本与每个类别的原型相似度的最大值 emissions</span></span><br><span class="line"><span class="comment"># 根据原有模型预测的标签索引序列 out_label_ids</span></span><br><span class="line"><span class="comment"># 每个旧类别的原型重新标记阈值列表（还未乘βi）prototype_dists</span></span><br><span class="line">preds, emissions, out_label_ids, prototype_dists = evaluate(args, model, tokenizer, labels, pad_token_label_id, </span><br><span class="line">                                                        mode=<span class="string">&quot;rehearsal&quot;</span>, data_dir=data_dir)</span><br><span class="line"><span class="comment"># 计算原型重新标记阈值 (根据不同的任务步骤i来调整超参数βi)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(current_task_id):</span><br><span class="line">    <span class="keyword">if</span> args.change_th:</span><br><span class="line">        task_para = th_para - (current_task_id - i - <span class="number">1</span>)*th_reduction  <span class="comment"># βi</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        task_para = th_para</span><br><span class="line">        prototype_dists[i*args.per_types+<span class="number">1</span>:(i+<span class="number">1</span>)*args.per_types+<span class="number">1</span>] *= task_para</span><br></pre></td></tr></table></figure><p>重新标记旧实体类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(out_label_ids.shape[<span class="number">0</span>]):  <span class="comment"># 迭代每个batch  </span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(out_label_ids.shape[<span class="number">1</span>]):  <span class="comment"># 迭代每个样本  </span></span><br><span class="line">        idx = preds[i][j]   <span class="comment"># 根据原型相似度预测的类别索引</span></span><br><span class="line">        <span class="comment"># 如果原型的相似度大于重新标记阈值并且预测的标签是旧实体类的标签</span></span><br><span class="line">        <span class="keyword">if</span> emissions[i][j] &gt; prototype_dists[idx].item() <span class="keyword">and</span> out_label_ids[i][j] &lt; <span class="built_in">len</span>(labels) - args.per_types: </span><br><span class="line">                out_label_new_list[i].append(preds[i][j])  <span class="comment"># 则将该“O”预测为这个旧实体类  </span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 否则，保持原始的标签不变</span></span><br><span class="line">            out_label_new_list[i].append(out_label_ids[i][j])</span><br></pre></td></tr></table></figure><h3 id="返回-logits-list-out-label-new-list">返回 logits_list, out_label_new_list</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> logits_list, out_label_new_list</span><br></pre></td></tr></table></figure><h2 id="evaluate">evaluate ()</h2><h3 id="读取数据集">读取数据集</h3><p>读取eval_dataset，support_dataset，support_o_dataset，train_dataset。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">eval_dataset = load_and_cache_examples(args, tokenizer, labels, pad_token_label_id, mode=mode, data_dir=data_dir)</span><br><span class="line">support_dataset = load_and_cache_examples(args, tokenizer, labels, pad_token_label_id, mode=<span class="string">&quot;memory&quot;</span>, data_dir=data_dir)</span><br><span class="line">support_o_dataset = load_and_cache_examples(args, tokenizer, labels, pad_token_label_id, mode=<span class="string">&quot;memory_o&quot;</span>, data_dir=data_dir)</span><br><span class="line">train_dataset = load_and_cache_examples(args, tokenizer, labels, pad_token_label_id, mode=<span class="string">&quot;train&quot;</span>, data_dir=data_dir)</span><br><span class="line"><span class="comment"># 顺序采样</span></span><br><span class="line">eval_sampler = SequentialSampler(eval_dataset) <span class="keyword">if</span> args.local_rank == -<span class="number">1</span> <span class="keyword">else</span> DistributedSampler(eval_dataset)</span><br><span class="line">eval_dataloader = DataLoader(eval_dataset, sampler=eval_sampler, batch_size=args.eval_batch_size)</span><br><span class="line">support_sampler = SequentialSampler(support_dataset) <span class="keyword">if</span> args.local_rank == -<span class="number">1</span> <span class="keyword">else</span> DistributedSampler(support_dataset)</span><br><span class="line">support_o_sampler = SequentialSampler(support_o_dataset) <span class="keyword">if</span> args.local_rank == -<span class="number">1</span> <span class="keyword">else</span> DistributedSampler(support_o_dataset)</span><br><span class="line">train_sampler = SequentialSampler(train_dataset) <span class="keyword">if</span> args.local_rank == -<span class="number">1</span> <span class="keyword">else</span> DistributedSampler(train_dataset)</span><br><span class="line"><span class="comment"># 数据集加载器</span></span><br><span class="line">support_dataloader = DataLoader(support_dataset, sampler=support_sampler, batch_size=args.eval_batch_size)</span><br><span class="line">support_o_dataloader = DataLoader(support_o_dataset, sampler=support_o_sampler, batch_size=args.eval_batch_size)</span><br><span class="line">train_dataloader = DataLoader(train_dataset, sampler=train_sampler, batch_size=args.eval_batch_size)</span><br></pre></td></tr></table></figure><h3 id="获取支持数据集的embbedings和labels">获取支持数据集的embbedings和labels</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">support_encodings, support_labels = get_support_encodings_and_labels_total(args, model, support_dataloader, support_o_dataloader, train_dataloader, pad_token_label_id)</span><br></pre></td></tr></table></figure><h3 id="三种重新标记来自旧类别的“O”的策略">三种重新标记来自旧类别的“O”的策略</h3><h4 id="使用原型重新标记">使用原型重新标记</h4><p>基于“O”样本与原型之间的距离<br><strong>计算每个类别的原型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exemplar_means = get_exemplar_means(args, support_encodings, support_labels)</span><br></pre></td></tr></table></figure><p><strong>计算原型重新标记阈值以及“O”与原型的最高相似度</strong></p><p>利用 NNClassification() 计算nn_preds，nn_emissions，prototype_dists</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, batch <span class="keyword">in</span> <span class="built_in">enumerate</span>(eval_iterator):</span><br><span class="line">    batch = <span class="built_in">tuple</span>(t.to(args.device) <span class="keyword">for</span> t <span class="keyword">in</span> batch)</span><br><span class="line">    <span class="comment"># 循环迭代 eval_iterator，使用原有的模型获取每个批次的encodings和labels</span></span><br><span class="line">    encodings, encoding_labels = get_token_encodings_and_labels(args, model, batch)</span><br><span class="line">    <span class="comment"># 如果是rehearsal模式，则去除掉当前task样本的support_encodings和support_labels再进行预测。</span></span><br><span class="line">    <span class="keyword">if</span> mode==<span class="string">&quot;rehearsal&quot;</span>:</span><br><span class="line">        cls = NNClassification()</span><br><span class="line">        support_encodings = support_encodings[support_labels &lt; <span class="built_in">len</span>(labels) - args.per_types]</span><br><span class="line">        support_labels = support_labels[support_labels &lt; <span class="built_in">len</span>(labels) - args.per_types]</span><br><span class="line">        nn_preds(batch_size, sent_len) 包含每个样本中原型相似度最大值所在的类别索引</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        nn_preds(batch_size, sent_len) 包含每个样本中原型相似度最大值所在的类别索引</span></span><br><span class="line"><span class="string">        nn_emissions(batch_size, sent_len, ndim) 包含每个样本与每个类别的原型相似度的最大值</span></span><br><span class="line"><span class="string">        prototype_dists 每个旧类别的原型重新标记阈值列表（还未乘βi）</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nn_preds, nn_emissions, prototype_dists = cls.nn_classifier_dot_prototype(encodings, support_encodings, support_labels, exemplar_means)</span><br></pre></td></tr></table></figure><h4 id="使用最近邻重新标记">使用最近邻重新标记</h4><p>基于“O”样本与每个类别示例之间的距离</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> args.cls_name == <span class="string">&quot;ncm_dot&quot;</span>:  </span><br><span class="line">    cls = NcmClassification()</span><br><span class="line">    nn_preds = cls.ncm_classifier_dot(encodings, support_encodings, support_labels, exemplar_means)</span><br></pre></td></tr></table></figure><h4 id="使用原有模型重新标记">使用原有模型重新标记</h4><p>作为前两种方法的参考标注</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> args.cls_name == <span class="string">&quot;linear&quot;</span>:</span><br><span class="line">    nn_preds, encoding_labels = get_token_logits_and_labels(args, model, batch)</span><br></pre></td></tr></table></figure><h3 id="保存预测结果">保存预测结果</h3><p>将每个批次的预测结果追加到 preds 中，并将作为参考标准的预测标签保存到 out_label_ids 中。如果当前模式是rehearsal模式，还会保存emissions。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> preds <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># 第一次预测</span></span><br><span class="line">    preds = nn_preds.detach().cpu().numpy()</span><br><span class="line">    out_label_ids = encoding_labels.detach().cpu().numpy()</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&quot;rehearsal&quot;</span>:</span><br><span class="line">        emissions = nn_emissions.detach().cpu().numpy()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    preds = np.append(preds, nn_preds.detach().cpu().numpy(), axis=<span class="number">0</span>)</span><br><span class="line">    out_label_ids = np.append(out_label_ids, encoding_labels.detach().cpu().numpy(), axis=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&quot;rehearsal&quot;</span>:</span><br><span class="line">        emissions = np.append(emissions, nn_emissions.detach().cpu().numpy(), axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="预测结果">预测结果</h3><p>如果当前模式是rehearsal模式，那么函数直接将返回 preds、 emissions、out_label_ids 和prototype_dists。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> mode == <span class="string">&quot;rehearsal&quot;</span>:</span><br><span class="line">    <span class="keyword">return</span> preds, emissions, out_label_ids, prototype_dists</span><br></pre></td></tr></table></figure><p>如果使用的是线性分类器，根据 preds 得出预测的最大logits？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> args.cls_name == <span class="string">&quot;linear&quot;</span>:</span><br><span class="line">    preds = np.argmax(preds, axis=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>out_label_list 和 preds_list存储使用原有模型和使用自定义方法预测的标签字符串序列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 label_map 字典，将标签的索引映射到相应标签的字符串名称。</span></span><br><span class="line">label_map = &#123;i: <span class="string">&quot;I-&quot;</span>+label <span class="keyword">for</span> i, label <span class="keyword">in</span> <span class="built_in">enumerate</span>(labels)&#125;</span><br><span class="line">label_map[<span class="number">0</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(out_label_ids.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(out_label_ids.shape[<span class="number">1</span>]):</span><br><span class="line">        <span class="keyword">if</span> out_label_ids[i, j] != pad_token_label_id:</span><br><span class="line">            out_label_list[i].append(label_map[out_label_ids[i][j]])</span><br><span class="line">            preds_list[i].append(label_map[preds[i][j]])</span><br></pre></td></tr></table></figure><p>输出评价指标结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 seqeval 库计算 F1-score。</span></span><br><span class="line">metric = load_metric(<span class="string">&quot;seqeval&quot;</span>)</span><br><span class="line">metric.add_batch(predictions=preds_list, references=out_label_list)</span><br><span class="line">macro_results, micro_results, _ = compute_metrics(metric)</span><br></pre></td></tr></table></figure><p>返回评价指标结果以及预测的标签序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> macro_results, micro_results, preds_list</span><br></pre></td></tr></table></figure><h2 id="train">train()</h2><h3 id="计算训练总步数t-total和训练轮数num-train-epochs">计算训练总步数t_total和训练轮数num_train_epochs</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果设置了训练最大步数max_steps，则t_total = args.max_steps，并计算num_train_epochs，否则根据num_train_epochs计算t_total。</span></span><br><span class="line"><span class="keyword">if</span> args.max_steps &gt; <span class="number">0</span>:</span><br><span class="line">    t_total = args.max_steps</span><br><span class="line">    args.num_train_epochs = args.max_steps // (<span class="built_in">len</span>(train_dataloader) // args.gradient_accumulation_steps) + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    t_total = <span class="built_in">len</span>(train_dataloader) // args.gradient_accumulation_steps * args.num_train_epochs</span><br></pre></td></tr></table></figure><h3 id="配置优化器">配置优化器</h3><p>使用AdamW优化器，使用了。权重衰减和学习率调节器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">no_decay = [<span class="string">&quot;bias&quot;</span>, <span class="string">&quot;LayerNorm.weight&quot;</span>]  <span class="comment"># 不需要衰减的参数</span></span><br><span class="line">optimizer_grouped_parameters = [</span><br><span class="line">    &#123;<span class="string">&quot;params&quot;</span>: [p <span class="keyword">for</span> n, p <span class="keyword">in</span> model.named_parameters() <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">any</span>(nd <span class="keyword">in</span> n <span class="keyword">for</span> nd <span class="keyword">in</span> no_decay)],</span><br><span class="line">    <span class="string">&quot;weight_decay&quot;</span>: args.weight_decay&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;params&quot;</span>: [p <span class="keyword">for</span> n, p <span class="keyword">in</span> model.named_parameters() <span class="keyword">if</span> <span class="built_in">any</span>(nd <span class="keyword">in</span> n <span class="keyword">for</span> nd <span class="keyword">in</span> no_decay)], <span class="string">&quot;weight_decay&quot;</span>: <span class="number">0.0</span>&#125;</span><br><span class="line">]</span><br><span class="line">optimizer = AdamW(optimizer_grouped_parameters, lr=args.learning_rate, eps=args.adam_epsilon)</span><br><span class="line">scheduler = get_linear_schedule_with_warmup(optimizer, num_warmup_steps=args.warmup_steps, num_training_steps=t_total)</span><br></pre></td></tr></table></figure><h3 id="训练">训练</h3><p>迭代每一轮</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> train_iterator:</span><br><span class="line">    <span class="keyword">if</span> epoch &gt;= args.start_train_o_epoch:</span><br></pre></td></tr></table></figure><p>获取每个类别的类别相似度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prototype_dists = get_rehearsal_prototype(args, model, tokenizer, labels,</span><br><span class="line">                                   pad_token_label_id, mode=<span class="string">&quot;rehearsal&quot;</span>,</span><br><span class="line">                                   data_dir=data_dir)</span><br></pre></td></tr></table></figure><p>获取样本的logits和标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按批次遍历训练集中的数据</span></span><br><span class="line"><span class="keyword">for</span> step, batch <span class="keyword">in</span> <span class="built_in">enumerate</span>(epoch_iterator):</span><br><span class="line">    model.train()  <span class="comment"># 将模型切换到训练模式</span></span><br><span class="line">    <span class="keyword">if</span> num_labels-<span class="number">1</span> &gt; args.per_types:  <span class="comment"># 如果不是第一轮训练</span></span><br><span class="line">        t_logits_step = t_logits[step]</span><br><span class="line">        new_labels = out_new_labels[step * args.train_batch_size:step * args.train_batch_size + <span class="built_in">len</span>(batch[<span class="number">3</span>])]</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># 如果是第一轮训练，使用训练集的原始标签</span></span><br><span class="line">        t_logits_step = <span class="literal">None</span></span><br><span class="line">        new_labels = batch[<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">if</span> epoch &gt;= args.start_train_o_epoch:</span><br><span class="line">        loss_name = args.loss_name2  <span class="comment"># 实体和“O”的联合损失函数</span></span><br><span class="line">        cls = NNClassification()</span><br><span class="line">        encodings, encoding_labels = get_token_features_and_labels(args, model, batch)</span><br></pre></td></tr></table></figure><p>计算样本之间的余弦相似度分数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    # top_emissions_step(batch_size*set_len, batch_size*set_len):存储样本之间大于实体阈值的余弦相似度分数</span><br><span class="line">    # 选择类别相似度的中位数作为实体阈值 th_dists</span><br><span class="line">    top_emissions_step, _ = cls.get_top_emissions_with_th(encodings, encoding_labels, </span><br><span class="line">                                                        th_dists=torch.median(prototype_dists).item())</span><br><span class="line">else:</span><br><span class="line">    top_emissions_step = top_emissions</span><br></pre></td></tr></table></figure><p>用自定义的模型进行训练，获取损失值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">inputs = &#123;<span class="string">&quot;input_ids&quot;</span>: batch[<span class="number">0</span>],  </span><br><span class="line">        <span class="string">&quot;attention_mask&quot;</span>: batch[<span class="number">1</span>],  </span><br><span class="line">        <span class="string">&quot;token_type_ids&quot;</span>: batch[<span class="number">2</span>] <span class="keyword">if</span> args.model_type <span class="keyword">in</span> [<span class="string">&quot;bert&quot;</span>, <span class="string">&quot;xlnet&quot;</span>] <span class="keyword">else</span> <span class="literal">None</span>,</span><br><span class="line">        <span class="comment"># XLM and RoBERTa don&quot;t use segment_ids</span></span><br><span class="line">        <span class="string">&quot;labels&quot;</span>: new_labels,  </span><br><span class="line">        <span class="string">&quot;t_logits&quot;</span>: t_logits_step,  </span><br><span class="line">        <span class="string">&quot;mode&quot;</span>: <span class="string">&quot;train&quot;</span>,  </span><br><span class="line">        <span class="string">&quot;loss_name&quot;</span>: loss_name,  </span><br><span class="line">        <span class="string">&quot;top_emissions&quot;</span>: top_emissions_step,</span><br><span class="line">        <span class="string">&quot;topk_th&quot;</span>: <span class="literal">True</span>  </span><br><span class="line">        &#125;</span><br><span class="line">outputs = model(**inputs)  </span><br><span class="line">loss = outputs[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 如果设置了梯度累积步数，则需要对损失值进行除以梯度累积步数，以得到平均损失值</span></span><br><span class="line"><span class="keyword">if</span> args.gradient_accumulation_steps &gt; <span class="number">1</span>:</span><br><span class="line">    loss = loss / args.gradient_accumulation_steps</span><br></pre></td></tr></table></figure><p>更新参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">loss.backward()  <span class="comment"># 后向传播</span></span><br><span class="line">tr_loss += loss.item()</span><br><span class="line"><span class="comment"># 如果达到梯度累计步数</span></span><br><span class="line"><span class="keyword">if</span> (step + <span class="number">1</span>) % args.gradient_accumulation_steps == <span class="number">0</span>:</span><br><span class="line">    torch.nn.utils.clip_grad_norm_(model.parameters(), args.max_grad_norm) </span><br><span class="line">    optimizer.step()  </span><br><span class="line">    scheduler.step()  </span><br><span class="line">    optimizer.zero_grad()  <span class="comment"># 清除优化器中所有参数的梯度</span></span><br><span class="line">    global_step += <span class="number">1</span>  <span class="comment"># 更新全局步数</span></span><br></pre></td></tr></table></figure><h3 id="评估">评估</h3><p>在开发集上评估模型性能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_, results, _ = evaluate(args, model, tokenizer, labels, pad_token_label_id, mode=<span class="string">&quot;dev&quot;</span>,</span><br><span class="line">                                     data_dir=data_dir)</span><br></pre></td></tr></table></figure><p>保存模型及参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model_to_save.save_pretrained(output_dir)</span><br><span class="line">torch.save(args, os.path.join(output_dir, <span class="string">&quot;training_args.bin&quot;</span>)) </span><br></pre></td></tr></table></figure><p>达到最大步数时停止训练</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if args.max_steps &gt; 0 and global_step &gt; args.max_steps:  </span><br><span class="line">    epoch_iterator.close()  # 关闭当前的 epoch 迭代器</span><br><span class="line">    break</span><br></pre></td></tr></table></figure><h3 id="返回全局步数和平均损失">返回全局步数和平均损失</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> global_step, tr_loss / global_step  </span><br></pre></td></tr></table></figure><h1>分类器</h1><h2 id="NNClassification">NNClassification()</h2><h3 id="nn-classifier-dot-prototype">nn_classifier_dot_prototype()</h3><p><strong>根据原型进行重新标记来自旧实体类别的“O”</strong><br>计算“O”与每个类别原型的最大相似度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将输入的表示 reps 重塑为二维张量，并对其进行归一化处理。</span></span><br><span class="line">feature = reps.view(-<span class="number">1</span>, reps.shape[-<span class="number">1</span>])  <span class="comment"># (batch_size, ndim)</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(feature.size(<span class="number">0</span>)):  <span class="comment"># Normalize</span></span><br><span class="line">    feature.data[j] = feature.data[j] / feature.data[j].norm()</span><br><span class="line">    means = torch.stack([exemplar_means[cls] <span class="keyword">for</span> cls <span class="keyword">in</span> <span class="built_in">range</span>(n_tags)])  <span class="comment"># (n_classes, ndim)</span></span><br><span class="line">    dists = torch.matmul(feature, means.T)  <span class="comment"># (batch_size, n_classes)</span></span><br><span class="line">    dists[:, <span class="number">0</span>] = torch.zeros(<span class="number">1</span>).to(reps.device)  <span class="comment"># 将第一列真正的“O” 类别的相似度设为0</span></span><br><span class="line">    <span class="comment"># emissions 包含每个样本中原型相似度的最大值，tags 包含每个样本中原型相似度最大值所在的类别索引。</span></span><br><span class="line">    emissions, tags = dists.<span class="built_in">max</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>计算每个类别的原型重新标记阈值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将support_reps 重塑为二维张量，并对其进行归一化处理。</span></span><br><span class="line">support_reps = support_reps.view(-<span class="number">1</span>, support_reps.shape[-<span class="number">1</span>])</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(support_reps.size(<span class="number">0</span>)):  <span class="comment"># Normalize</span></span><br><span class="line">    support_reps.data[j] = support_reps.data[j] / support_reps.data[j].norm()</span><br><span class="line">support_reps = F.normalize(support_reps)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_tags):</span><br><span class="line">    <span class="comment"># 计算每个类别原型与支持集中对应类别的样本的相似度</span></span><br><span class="line">    support_reps_dists = torch.matmul(support_reps[support_tags==i], means[i].T)</span><br><span class="line">    <span class="comment"># 沿着最后一个维度（即特征维度）寻找最小值，并返回这些最小值以及对应的索引</span></span><br><span class="line">    prototype_dists.append(support_reps_dists.<span class="built_in">min</span>(-<span class="number">1</span>)[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h3 id="get-top-emissions-with-th">get_top_emissions_with_th()</h3><p>计算样本之间的余弦相似度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scores = self._euclidean_metric_dot_2(reps.view(-<span class="number">1</span>, ndim), reps.view(-<span class="number">1</span>, ndim), <span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 排除“O”样本的分数（第二维）</span></span><br><span class="line">        scores = torch.where(reps_labels == <span class="number">0</span>, scores.double(), -<span class="number">100.</span>)  </span><br><span class="line">        <span class="comment"># 排除样本与自身的分数</span></span><br><span class="line">        scores = torch.scatter(scores, <span class="number">1</span>,</span><br><span class="line">                               torch.arange(scores.shape[<span class="number">0</span>]).view(-<span class="number">1</span>, <span class="number">1</span>).to(device), -<span class="number">100.</span>)</span><br></pre></td></tr></table></figure><p>筛选出大于实体阈值的分数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top_emissions = scores &gt; th_dists</span><br></pre></td></tr></table></figure><p>返回 top_emissions, scores</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> top_emissions, scores</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NER </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NER </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learning_O说明文档</title>
      <link href="/2024/03/18/NER/O%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/"/>
      <url>/2024/03/18/NER/O%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p>整理自：<a href="https://siljing.github.io/2024/07/21/%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/">J</a></p><h1>概述</h1><h2 id="工具函数">工具函数</h2><table><thead><tr><th>功能</th><th>类/函数</th><th>描述</th></tr></thead><tbody><tr><td>计算类别相似度</td><td><a href="#get_rehearsal_prototype">get_rehearsal_prototype()</a></td><td>根据 memory 和 memory_o 数据集预测的特征和标签计算每个类别的余弦相似度</td></tr><tr><td>预测特征</td><td><a href="#get_token_features_and_labels">get_token_features_and_labels()</a></td><td>使用上一轮的模型预测特征</td></tr><tr><td>预测隐藏状态序列</td><td><a href="#get_token_encodings_and_labels">get_token_encodings_and_labels()</a></td><td>使用上一轮的模型预测最后一层输出端的隐藏状态序列</td></tr><tr><td>计算类别的原型</td><td><a href="#get_exemplar_means">get_exemplar_means()</a></td><td>根据支持集的 encoding 计算每个类别的原型，即均值</td></tr></tbody></table><h2 id="准备数据集">准备数据集</h2><table><thead><tr><th>功能</th><th>类/函数</th><th>描述</th></tr></thead><tbody><tr><td>表示训练/测试样本的对象</td><td><a href="#InputExample">InputExample(object)</a></td><td>包含每个样本的编号，单词序列，标签序列</td></tr><tr><td>表示样本特征集的对象</td><td><a href="#InputFeatures">InputFeatures(object)</a></td><td>包含每个样本特征的 input_ids，input_mask，segment_ids，label_ids</td></tr><tr><td>从文件中读取数据</td><td><a href="#read_examples_from_file">read_examples_from_file()</a></td><td>返回 InputExample 对象的列表</td></tr><tr><td>提取标签集</td><td><a href="#get_labels_dy">get_labels_dy()</a></td><td>提取当前任务及之前的所有标签集</td></tr><tr><td>提取每个样本的 InputFeatures 对象</td><td><a href="#convert_examples_to_features">convert_examples_to_features</a></td><td>将输入的文本样本（通过 InputExample 对象表示）转换为模型输入的特征表示（通过 InputFeatures 对象表示）</td></tr><tr><td>加载并处理数据集样本</td><td><a href="#load_and_cache_examples">load_and_cache_examples()</a></td><td>调用前两个函数从原始数据集中提取特征</td></tr></tbody></table><h2 id="训练和评估">训练和评估</h2><table><thead><tr><th>功能</th><th>类/函数</th><th>描述</th></tr></thead><tbody><tr><td>老师模型函数</td><td><a href="#teacher_evaluate">teacher_evaluate()</a></td><td>使用老师模型预测 logits 分数和进行重新标记旧实体类</td></tr><tr><td>评估及重新标记函数</td><td><a href="#evaluate">evaluate()</a></td><td>评估模型性能以及使用原型对评估集进行重新标记</td></tr><tr><td>训练函数</td><td><a href="#train">train()</a></td><td>训练模型，更新参数</td></tr><tr><td>训练和评估函数</td><td><a href="#train_and_eval">train_and_eval()</a></td><td>调用 teacher_evaluate()，evaluate() 和 train() 进行训练和评估</td></tr></tbody></table><h2 id="损失函数">损失函数</h2><table><thead><tr><th>功能</th><th>类/函数</th><th>描述</th></tr></thead><tbody><tr><td>监督对比损失函数</td><td><a href="#SupConLoss">SupConLoss()</a></td><td>实体的监督对比损失函数</td></tr><tr><td>监督对比损失函数</td><td><a href="#SupConLoss_o">SupConLoss_o()</a></td><td>实体和“O”的联合监督对比损失函数</td></tr></tbody></table><h2 id="自定义模型">自定义模型</h2><p><a href="#MySftBertModel">MySftBertModel()</a></p><h2 id="主函数">主函数</h2><p><a href="#mian">main()</a></p><h1>工具函数</h1><hr><p><a id="get_rehearsal_prototype"> </a></p><h2 id="get-rehearsal-prototype">get_rehearsal_prototype()</h2><h4 id="参数说明：">参数说明：</h4><p>get_rehearsal_prototype(args, model, tokenizer, labels, pad_token_label_id, mode, data_dir)</p><ul><li>labels：当前任务及之前的所有标签集</li><li>pad_token_label_id：PAD 标记的索引</li></ul><h4 id="用法：">用法：</h4><ul><li>加载当前任务的 memory 和 memory_o 数据集，并用当前模型预测特征和标签。</li><li>根据预测特征和标签计算当前任务及之前的所有类别的余弦相似度。</li></ul><h4 id="测试：对-task0-的-memory-和-memory-o-数据集进行测试：">测试：对 task0 的 memory 和 memory_o 数据集进行测试：</h4><p><a id="get_token_features_and_labels"> </a></p><h2 id="get-token-features-and-labels">get_token_features_and_labels()</h2><h4 id="参数说明：-2">参数说明：</h4><p>get_token_features_and_labels(args, model, batch)</p><ul><li>model：当前加载的上一轮的模型</li><li>btach：要预测的批次</li></ul><h4 id="功能：">功能：</h4><p>使用上一轮的模型预测特征，并提取出原数据集的标签。<br><a id="get_token_encodings_and_labels"> </a></p><h2 id="get-token-encodings-and-labels">get_token_encodings_and_labels()</h2><h4 id="功能：-2">功能：</h4><p>同 get_token_features_and_labels()，使用上一轮的模型预测最后一层输出端的隐藏状态序列，并提取出原数据集的标签。<br><a id="get_exemplar_means"> </a></p><h2 id="get-exemplar-means">get_exemplar_means()</h2><h4 id="功能：-3">功能：</h4><p>将每个 label 的所有样本的 encoding 取均值后归一化作为该类别的原型。</p><h1>准备数据集</h1><hr><p><a id="InputExample"></a></p><h2 id="InputExample-object">InputExample(object)</h2><p>表示一个训练或测试的样本的对象，该类包含以下属性：</p><ul><li>guid：句子的编号，用作句子的唯一标识符。</li><li>words：句子中的单词序列，以列表形式存储。</li><li>labels：(可选)序列中每个单词的标签，以列表形式存储。对于测试句子，不需要提供标签列表。</li></ul><p><a id="InputFeatures"></a></p><h2 id="InputFeatures-object">InputFeatures(object)</h2><p>表示一个样本特征集的对象，该类包含以下属性：</p><ul><li>input_ids：表示单词在词汇表中的索引，是模型输入的主要部分。</li><li>input_mask：用于指示哪些部分是真实的输入，哪些部分是填充的。</li><li>segment_ids：在BERT处理句子对中，用于区分不同句子的标识，0表示属于第一个句子，1表示属于第二个句子。</li><li>label_ids：标签的索引。</li></ul><p><a id="get_labels_dy"></a></p><h2 id="get-labels-dy">get_labels_dy()</h2><p>get_labels_dy(path, per_types, step_id)</p><h4 id="参数说明：-3">参数说明：</h4><ul><li>path：标签集的存储路径</li><li>per_types：每个任务要学习的标签数量</li><li>step_id：当前任务的索引</li></ul><h4 id="功能：-4">功能：</h4><p>返回包含当前任务及之前的所有标签的列表。</p><p><a id="read_examples_from_file"></a></p><h2 id="read-examples-from-file">read_examples_from_file()</h2><h4 id="参数说明：-4">参数说明：</h4><p>read_examples_from_file(data_dir, mode)</p><ul><li>data_dir: 数据文件存储的目录，文件读取的路径格式为&quot;data_dir/{mode}.txt&quot;</li><li>mode：根据不同的模式读取不同的样本<ul><li>train：读取 train.txt。</li><li>memory：读取 memory.txt。</li><li>dev：读取 dev.txt。</li><li>rehearsal：同时读取 train.txt 和 memory.txt，并将它们合并成一个列表返回。</li></ul></li></ul><h4 id="用法">用法:</h4><ul><li>使用 os.path.join 构造文件路径，该路径由 data_dir 和 mode 组成。</li><li>打开文件并逐行读取数据。</li><li>对于每一行：<ul><li>如果行以 “-DOCSTART-” 开头或为空行，则表示前一个句子的结束。此时，将累积的words和labels作为一个样本添加到 examples 列表中，并清空 words 和 labels 列表。</li><li>否则，将行按制表符分割，获取单词和标签，并将它们添加到 words 和 labels 列表中。</li></ul></li><li>返回 examples 列表，其中每个元素都是一个 InputExample 对象，代表一个句子。</li></ul><p><a id="convert_examples_to_features"></a></p><h2 id="convert-examples-to-features">convert_examples_to_features()</h2><h4 id="参数说明：-5">参数说明：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">convert_examples_to_features(examples, label_list, max_seq_length, tokenizer, cls_token_at_end=<span class="literal">False</span>, cls_token=<span class="string">&quot;[CLS]&quot;</span>, </span><br><span class="line">                        cls_token_segment_id=<span class="number">1</span>, sep_token=<span class="string">&quot;[SEP]&quot;</span>, sep_token_extra=<span class="literal">False</span>, pad_on_left=<span class="literal">False</span>, pad_token=<span class="number">0</span>, </span><br><span class="line">                        pad_token_segment_id=<span class="number">0</span>, pad_token_label_id=-<span class="number">1</span>, sequence_a_segment_id=<span class="number">0</span>, mask_padding_with_zero=<span class="literal">True</span>):</span><br></pre></td></tr></table></figure><ul><li>examples：经过 read_example_from_file() 函数处理的 InputExample 对象列表</li><li>label_list：当前增量学习任务的标签</li><li>max_seq_length：tokenization 后的最大序列长度，比这个长的会被截断，比这个短的会被填充。</li><li>cls_token_at_end：是否在序列最后加一个 CLS token：<ul><li>False (Default, BERT/XLM pattern): [CLS] + A + [SEP] + B + [SEP]</li><li>True (XLNet/GPT pattern): A + [SEP] + B + [SEP] + [CLS]</li></ul></li><li>cls_token_segment_id：定义关于 CLS token 的段id (0 for BERT, 2 for XLNet)。</li><li>sep_token_extra：是否在结尾再添加 SEP token( for RoBERTa pattern)。</li><li>pad_on_left：是否在句子左边填充 PAD。</li></ul><h4 id="用法-2">用法</h4><ul><li>将增量学习任务的标签从0编号，构建标签到索引映射 label_map。</li><li>遍历每个 example:<ul><li>使用分词器 tokenizer 对句子的每个单词进行分词，并在 label_ids 列表中添加它们的标签编号。</li><li>根据序列的长度和特殊标记的数量，截断序列，使其长度符合 max_seq_length 的要求。</li><li>添加特殊标记 [CLS] 和 [SEP]，以及相应的标签编号。</li><li>构建 segment_ids (全为0) 表示句子的段落编号。</li><li>构建 input_ids 列表，将 tokens 序列映射为其对应的 ID。</li><li>构建输入掩码 input_mask，1 for real tokens and 0 for padding tokens。</li><li>对不足长度的序列进行填充。</li><li>将每个 example 的处理结果存储为一个 InputFeatures 对象，并添加到 features 列表中。</li></ul></li><li>返回 features 列表。</li></ul><p><a id="load_and_cache_examples"></a></p><h2 id="load-and-cache-examples">load_and_cache_examples()</h2><h4 id="参数说明：-6">参数说明：</h4><p>load_and_cache_examples(args, tokenizer, labels, pad_token_label_id, mode, data_dir)</p><ul><li>tokenizer：分词器</li><li>labels: 当前增量学习任务的标签</li><li>pad_token_label_id：PAD 位置的掩码</li><li>mode：指定当前的模式，可能为 train，dev，rehears。</li><li>data_dir: 数据文件存储的目录。</li></ul><p>data_dir，mode 传入 read_examples_from_file 函数读取样本。<br>tokenizer，传入 convert_examples_to_features 函数将样本转换为特征。</p><h4 id="功能：-5">功能：</h4><ol><li>调用 read_examples_from_file() 和 convert_examples_to_features() 函数，根据不同的模式从 data_dir 中读取样本并转换为特征，如果是’rehearsal’模式，则读取 train.txt 和 memory.txt，如果是开发，训练，测试模式，则读取相应的dev.txt，train.txt，test.txt。</li><li>如果是分布式训练的非主进程，直接从缓存文件中加载特征。</li><li>返回一个 TensorDataset 对象 dataset(all_input_ids, all_input_mask, all_segment_ids, all_label_ids)。</li></ol><h4 id="测试">测试</h4><p>对 task0 的训练集的句子进行测试：<br><strong>获取标签集</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">labels = get_labels_dy(path=<span class="string">&quot;../data/labels.txt&quot;</span>, per_types=<span class="number">6</span>, step_id=<span class="number">0</span>)</span><br><span class="line">labels</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;O&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;building-library&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;organization-showorganization&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;other-award&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;building-other&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;organization-religion&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;organization-sportsteam&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>运行 load_and_cache_examples() 函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_dataset = load_and_cache_examples(args, tokenizer, labels, pad_token_label_id, mode=mode, data_dir=data_dir)</span><br></pre></td></tr></table></figure><p>输出日志()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">03/28/2024 13:38:28 - INFO - __main__ -   Creating features from dataset file at ../data/tasks/task_0</span><br><span class="line">03/28/2024 13:38:28 - INFO - util.supervised_util -   Writing example 0 of 100</span><br><span class="line">03/28/2024 13:38:28 - INFO - util.supervised_util -   *** Example ***</span><br><span class="line">03/28/2024 13:38:28 - INFO - util.supervised_util -   guid: train-1</span><br><span class="line">03/28/2024 13:38:28 - INFO - util.supervised_util -   tokens: [CLS] this rivalry intensified in 1919 when arsenal were unexpectedly promoted to the first division , taking a place that tottenham believed should be theirs . [SEP]</span><br><span class="line">03/28/2024 13:38:28 - INFO - util.supervised_util -   input_ids: 101 2023 10685 15767 1999 4529 2043 9433 2020 14153 3755 2000 1996 2034 2407 1010 2635 1037 2173 2008 18127 3373 2323 2022 17156 1012 102 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">03/28/2024 13:38:28 - INFO - util.supervised_util -   input_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">03/28/2024 13:38:28 - INFO - util.supervised_util -   segment_ids: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">03/28/2024 13:38:28 - INFO - util.supervised_util -   label_ids: -100 0 0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 0 0 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100</span><br><span class="line">03/28/2024 13:38:28 - INFO - util.supervised_util -   *** Example ***</span><br><span class="line">03/28/2024 13:38:28 - INFO - util.supervised_util -   guid: train-2</span><br><span class="line">03/28/2024 13:38:28 - INFO - util.supervised_util -   tokens: [CLS] only one of four entered corvette ##s - gt ##1 c ##6 ##r of luc alpha ##nd ave ##nt ##ures - eventually finished the race , taking second place in class . [SEP]</span><br><span class="line">03/28/2024 13:38:28 - INFO - util.supervised_util -   input_ids: 101 2069 2028 1997 2176 3133 22687 2015 1011 14181 2487 1039 2575 2099 1997 12776 6541 4859 13642 3372 14900 1011 2776 2736 1996 2679 1010 2635 2117 2173 1999 2465 1012 102 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">03/28/2024 13:38:28 - INFO - util.supervised_util -   input_mask: 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">03/28/2024 13:38:28 - INFO - util.supervised_util -   segment_ids: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">03/28/2024 13:38:28 - INFO - util.supervised_util -   label_ids: -100 0 0 0 0 0 0 -100 0 0 -100 0 -100 -100 0 6 6 -100 6 -100 -100 0 0 0 0 0 0 0 0 0 0 0 0 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100</span><br><span class="line">......仅展示前两个句子</span><br><span class="line">03/28/2024 13:38:28 - INFO - __main__ -   Saving features into cached file ../data/tasks/task_0\cached_rehearsal_output_nerd_128</span><br></pre></td></tr></table></figure><h1>训练和评估</h1><p><a id="teacher_evaluate"> </a></p><h2 id="teacher-evaluate">teacher_evaluate()</h2><h4 id="用法：-2">用法：</h4><ol><li>使用老师模型，即上一轮的模型预测训练集的 <code>logits_list</code> 和获取真实标签 <code>out_labels</code>。</li><li>调用 <a href="#evaluate">evaluate(mode=“rehearsal”)</a> 获取训练集的 <code>preds</code>, <code>emissions</code>, <code>out_label_ids</code>, 以及重新标记阈值 <code>prototype_dists</code>。</li><li>重新标记旧实体类：对于训练集的每个样本，如果它的原型的相似度大于重新标记阈值，则将该样本预测为这个旧实体类，否则保持原来的预测标签不变。</li><li>返回 <code>logits_list</code> 和重新标记过的标签列表 <code>out_label_new_list</code>。</li></ol><p><a id="evaluate"> </a></p><h2 id="evaluate">evaluate()</h2><h4 id="用法：-3">用法：</h4><ol><li>加载数据集：调用 <a href="#load_and_cache_examples">load_and_cache_examples()</a> 根据不同模式加载评估集，support 集（提取实体样本），support_o 集（提取“O”样本），训练集。</li><li>计算类别原型：</li></ol><ul><li>使用上一轮模型预测支持集的 encoding 和label。</li><li>调用 <a href="#get_exemplar_means">get_exemplar_means()</a> 根据支持集的 encoding 和label 计算每个类别的原型。</li></ul><ol start="3"><li>调用 <a href="#get_token_encodings_and_labels">get_token_encodings_and_labels()</a> 使用上一轮模型预测评估集的 encoding 和 标签 <code>out_label_ids</code>。</li><li>如果是’rehearsal’模式，则剔除掉支持集中当前任务标签的样本，并调用 NNClassification 的 <a href="#nn_classifier_dot_prototype">nn_classifier_dot_prototype()</a> 计算：</li></ol><ul><li><code>preds</code>：评估集每个样本中原型相似度最大值所在的类别索引</li><li><code>emissions</code>：评估集每个样本与每个类别的原型相似度的最大值</li><li><code>prototype_dists</code>：根据支持集计算的每个旧类别的原型重新标记阈值列表</li></ul><ol start="5"><li>如果是’rehearsal’模式，则直接返回 <code>preds</code>, <code>emissions</code>, <code>out_label_ids</code>, <code>prototype_dists</code>。</li><li>将 <code>out_label_ids</code>，<code>preds</code> 的标签从索引形式转换为真实的字符串形式。</li><li>将评估集的 <code>out_label_list</code> 作为真实标签，将 <code>preds_list</code> 作为预测标签，使用 seqeval 库计算 F1 分数 <code>macro_results</code>,<br><code>micro_results</code>。</li><li>返回 <code>macro_results</code>， <code>micro_results</code>，<code>preds_list</code>。</li></ol><p><a id="train"> </a></p><h2 id="train">train()</h2><h4 id="参数说明：-7">参数说明：</h4><p>train(args, train_dataset, train_dataloader, model, tokenizer, labels, pad_token_label_id, data_dir, output_dir, t_logits, out_new_labels):</p><ul><li>train_dataset：训练集</li><li>train_dataloader：训练集加载器</li><li>labels：当前任务及之前的所有真实标签集</li><li>pad_token_label_id：PAD 标记的索引</li><li>data_dir：输入数据集的文件路径</li><li>output_dir：保存模型的检查点的文件路径</li><li>t_logits：老师模型预测的 logits 分数</li><li>out_new_labels：老师模型预测的标签</li></ul><h4 id="用法：-4">用法：</h4><h6 id="参数配置">参数配置</h6><ol><li>设置训练总步数 t_total（用于传入 warmup 中）：</li></ol><ul><li>通过 <code>args.max_steps</code> 可以指定 t_total，并覆盖 <code>arg.num_train_epochs</code>。</li><li>否则通过 <code>t_total = len(train_dataloader) // args.gradient_accumulation_steps * args.num_train_epochs</code> 计算 t_total。</li></ul><ol start="2"><li>配置优化器：使用AdamW优化器，使用了权重衰减,学习率调节器。</li></ol><ul><li><code>args.learning_rate</code>(default=5e-5) 和 <code>args.adam_epsilon</code>(default=1e-8) 可修改AdamW的学习率和模糊因子。</li><li><code>args.warmup_steps</code>(default=0) 可修改 warmup 的初始预热步数。</li></ul><ol start="3"><li>根据 <code>args.fp16</code> 选择是否启用混合精度训练。</li></ol><h6 id="训练模型：">训练模型：</h6><p>迭代每一轮：</p><ol><li>如果当前轮次 &gt;=  <code>args.start_train_o_epoch</code>：<ul><li>利用 <a href="#get_rehearsal_prototype">get_rehearsal_prototype()</a> 函数计算类别相似度</li><li>将 <code>loss_name</code> 设为 实体和“O”联合损失函数。</li><li>调用 <a href="#get_token_features_and_labels">get_token_features_and_labels()</a> 函数使用当前模型预测特征和标签。</li><li>调用 <a href="#get_top_emissions_with_th">get_top_emissions_with_th()</a> 选择“O”的正样本。</li></ul></li><li>如果是第一个任务，使用原始数据集的标签。</li><li>如果不是第一个任务，使用老师模型 <a href="#tearch_evaluate">tearch_evaluate()</a> 预测 logits 分数 <code>t_logits</code> 和标签 <code>out_new_labels</code>。</li><li>模型前向传播，获取模型输出的损失值。</li><li>模型反向传播。</li><li>更新参数</li><li>调用 <a href="#evaluate">evaluate()</a> 的开发模式对开发集进行评估</li><li>达到 <code>args.save_steps</code> 时保存 checkpoint 文件和模型。</li><li>返回训练总步数和平均损失值。</li></ol><p><a id="train_and_eval"> </a></p><h2 id="train-and-eval">train_and_eval()</h2><h4 id="参数说明：-8">参数说明：</h4><p>train_and_eval(args, labels, num_labels, pad_token_label_id, model_name_or_path, output_dir, data_dir, step_id)</p><ul><li>labels：当前任务及之前的所有标签集</li><li>num_labels：labels 的数量</li><li>pad_token_label_id：PAD 标记的索引</li><li>model_name_or_path：加载模型的路径</li><li>output_dir：输出结果的文件路径</li><li>data_dir：读取数据集的文件路径</li><li>step_id：当前任务的 id</li></ul><h4 id="用法：-5">用法：</h4><ol><li>加载上一个任务的模型参数，分词器，模型。</li><li>调用 <a href="#load_and_cache_examples">load_and_cache_examples(mode=“rehearsal”)</a> 加载训练集（由当前任务的 train.txt 和 memory.txt 组成）</li><li>如果不是第一个任务，则调用 <a href="#teacher_evaluate">teacher_evaluate(mode=“train”)</a> 使用老师模型预测训练集的 logits 分数 <code>t_logits</code> 和 <code>out_new_labels</code>。</li><li>调用 <a href="#train">train()</a> 进行训练。</li><li>存储模型的参数，分词器，模型。</li><li>如果 <code>args.do_eval</code> 为 Ture，对每个 checkpoint 调用 <a href="#evaluate">evaluate()</a> 的开发模式对开发集进行评估，并存储进 eval_results.txt 文件。</li><li>如果 <code>args.do_predict</code> 为 Ture，调用 <a href="#evaluate">evaluate()</a> 的测试模式对测试集进行评估和预测，并保存评估和预测结果。</li></ol><h1>损失函数</h1><p><a id="SupConLoss"> </a></p><h2 id="SupConLoss">SupConLoss()</h2><h4 id="init"><strong>init</strong>():</h4><h6 id="参数说明：-9">参数说明：</h6><p><strong>init</strong>(self, temperature=0.07, contrast_mode=‘all’, base_temperature=0.07, topk_th=False)</p><ul><li>temperature：温度参数，用于调整对比损失函数中余弦相似度的尺度。</li><li>contrast_mod：</li><li>base_temperature：基准温度参数，用于调整对比损失函数的基准尺度。</li><li>topk_th：</li></ul><h4 id="forward">forward():</h4><h6 id="参数说明：-10">参数说明：</h6><p>forward(self, features, labels=None, mask=None, entity_topk=None, ignore_index=CrossEntropyLoss(), per_types=6, aug_feature=None)</p><ul><li>mask：对比损失的掩码，同一标签的样本设为1，不同为0。</li><li>entity_topk: 实体 Top K，表示每个类别的前 K 个样本在对比中的重要性。</li><li>ignore_index: 忽略索引，默认为 CrossEntropyLoss()，表示在计算损失时需要忽略的标签索引。</li></ul><h6 id="用法：-6">用法：</h6><ol><li>根据输入的 <code>labels</code> 和 <code>mask</code> 构建 <code>mask</code>：不同标签的设为0，与自身的设为0，ignore_index 所对应的行设为0，“O”样本所在行设为0。</li><li>选择 Anchor：根据 <code>contrast_mode</code> 选择 anchor 样本，如果 <code>contrast_mode</code> 为 ‘one’, 则将第一个样本设为 anchor，如果 <code>contrast_mode</code> 为 ‘all’, 则将所有样本设为 anchor。</li><li>计算对比损失的 Logits：计算 anchor 和其他样本之间的余弦相似度。</li><li><code>entity_topk</code> 非空: 将 <code>mask</code> 中所有样本与 entity_topk样本设为1，与当前任务训练集的“O”样本设为 0。</li><li>根据监督对比损失函数公式计算损失值，返回所有 anchor 的平均损失值。</li></ol><h1>模型</h1><p><a id="MySftBertModel"> </a></p><h2 id="MySftBertModel">MySftBertModel()</h2><h4 id="forward-2">forward():</h4><ol><li>使用 BertModel 模型前向传播</li><li>提取特征 <code>features </code>：将 <code>ast_hidden_state</code> 通过一个 <code>mlp(Linear-ReLU-Linear)</code> 层变换并归一化后赋给 <code>features </code>。</li><li>提取 <code>logits</code>：将 <code>last_hidden_state</code> 依次通过dropout 层，线性分类器层后赋给 <code>logits</code>。</li><li>如果是非训练模式，直接返回 loss, features_enc, features, logits，其中 <code>loss = None</code>，<code>features_enc = last_hidden_state</code></li><li>计算损失值 <code>loss</code>。：<ul><li>根据 <code>loss_name</code> 计算损失函数的值。</li><li>如果不是第一个任务，计算当前任务样本的 logits 与真实标签的交叉熵损失，当前模型与老师模型 logits 的KL散度。将交叉熵损失或KL散度添加到 <code>loss</code> 中。</li></ul></li><li>返回 loss, features_enc, features, logits。</li></ol><h1>主函数</h1><p><a id="main"> </a></p><h2 id="main">main()</h2><h4 id="功能：-6">功能：</h4><ul><li>创建解释器，添加命令行参数。</li><li>迭代每个任务，调用 <a href="#get_labels_dy">get_labels_dy()</a> 获取当前任务及之前的所有标签集 <code>labels</code>，然后调用 <a href="#train_and_eval">train_and_eval()</a> 进行训练和评估。</li></ul>]]></content>
      
      
      <categories>
          
          <category> NER </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NER </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各分类简介</title>
      <link href="/2024/02/16/%E5%90%84%E9%A1%B9%E4%BA%8B%E5%AE%9C/"/>
      <url>/2024/02/16/%E5%90%84%E9%A1%B9%E4%BA%8B%E5%AE%9C/</url>
      
        <content type="html"><![CDATA[<h1>关于本站</h1><p>本站几经辗转，目前基于安知鱼主题1.6.12（是 heo的改版），这一版主题有两处可能导致博客崩溃的BUG（遇到同样问题的uu可以看一下我写的详细解决方案），总体还是非常美丽！！（狠狠心动了哈哈）</p><p>本站原用于星火杯比赛，拟作为校园开源平台——慧试使用，现作为个人博客，欢迎闯入我的小世界~👋</p><h1>XDU-CS-lab(月更)</h1><p><a href="https://github.com/Alive0103/XDU-CS-lab">https://github.com/Alive0103/XDU-CS-lab</a></p><p>西电计科软件方向课程资料，试卷，实验通关秘籍</p><p>仓库为本人(22级)计科资料存储地，涵盖自大一开始的部分课程设置，实验，期末试卷，学习心得以及部分速通技巧，只此盏灯，为你长明不息。</p><p>部分PPT已转为PDF格式，需要PPT源文件的uu可以给我发邮件</p><p>仅用于学术交流，内容仅供参考，请勿抄袭，否则后果自负。</p><p>⭐觉得有用的话点个星星~不迷路！你的星星就是我持续上传的动力！！！今日之你亦是昨日之我，于是乎，不遗余力地，我同你共享我的资源和故事。</p><h1>NER</h1><p>nlp领域的ner命名实体识别方向，我们的项目旨在解决机器学习灾难性遗忘问题，现已成功把SOTA的0.71的F1提高到0.75，好耶！感兴趣的uu可以移步瞧瞧，收获蛮多的（虽然感觉做起来还是挺痛苦的哈哈），强推李沐老师的《动手学深度学习》！！！</p><p>祝大家学深度学习一切顺利，不掉头发！🤯</p><p>另有NLP-NER方向相关学习成果(智慧典藏——面向动态互联网环境的持续记忆系统)，欢迎<a href="https://github.com/Alive0103/NLP-NER">移步探讨</a></p><h1>人类观察录</h1><p>这里收集了各式各样的人~明媚的，深沉的，我真诚地想记录下来每一个有趣的灵魂（才不要在时间的长河里抹掉你们的印记），欢迎常来看看我的赛博收集手册~</p><blockquote><p>说不定你就是其中珍贵的一页呢？</p></blockquote><p>这个分类其实想写一些我的奇幻经历，会慢慢更新哒，包括但不限于一些恐怖故事，还有一份万言书（希望还有时间以连载的形式更完）哈哈，害怕的宝宝晚上慎看🍀</p><p>还有还有，可能会夹杂一些寻人启事，人和人的相遇真的全凭缘分，有些人错过就是错过了，甚至连说再见的机会都没有，想在这里写下我仅存的印象，如果各位或者本人有幸能看到的话还请留下联系方式，这对我很重要，谢谢谢谢！！！</p><p>好像有点多？哈哈，因为这些同等重要💕</p><h1>技能点</h1><p>AI时代，何去何从，这是个问题，选“工程性技术”狠赚一笔，还是大热的人工智能，亦或是更加机械重复的方向，孰好孰坏？似乎没人能给出标准答案，大学的可能性在于尝试，于是乎，我的大学几乎尝试了计算机传统路线的所有可能。</p><p>前端三大件，Vue，深度学习，Pytorch，数模，烧板子，ACM……本博客技能点板块会记录学习过程中的所思所想，在精不在多，很高兴我的每一分努力都能被你看在眼里💕</p><blockquote><p>才不是万千替代品般的中庸者，欢迎来到我的风暴中心</p></blockquote><h2 id="前端（Vue）">前端（Vue）</h2><p>资料参考于尚硅谷和黑马，个人学习笔记，仅供参考</p><h2 id="数据结构（周更）">数据结构（周更）</h2><p>跟着<a href="https://programmercarl.com/">代码随想录</a>以刷题笔记呈现（C++/Java都有），不会的题可以来瞧瞧~共勉兄弟们！</p><h2 id="深度学习">深度学习</h2><p>记录了NER大模型开发微调的一些心得，比较小白向，希望对你有帮助，也希望路过的高手给出一些意见（不玻璃心）💪</p><h2 id="Java实践笔记（持续更新）">Java实践笔记（持续更新）</h2><ol><li><p>速成向，基础语法部分已完结！都是我认为的精华捏</p></li><li><p>JavaWeb更新中……预计10月底over</p></li></ol><p>预计2025/3左右会更新相关项目，可以多多关注~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pytorch安装环境问题</title>
      <link href="/2024/02/07/NER/pytorch%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/"/>
      <url>/2024/02/07/NER/pytorch%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1>自己安</h1><p>突然兴起想重装Anaconda和Pycharm,好家伙,整整两天才给全部整明白,最大的原因见文末，在此记录一下我踩的坑。</p><p>参考【PyTorch深度学习快速入门教程（绝对通俗易懂！）【小土堆】】 <a href="https://www.bilibili.com/video/BV1hE411t7RN/?share_source=copy_web&amp;vd_source=4bd852f834f2d9a6a8ce0609a36001d4">https://www.bilibili.com/video/BV1hE411t7RN/?share_source=copy_web&amp;vd_source=4bd852f834f2d9a6a8ce0609a36001d4</a></p><p>Anaconda（<code>Anaconda3-2023.09-0-Windows-x86 64.exe</code>）,pycharm，pytorch已下好且pytorch（本机没有满足要求的GPU，选的CPU）可正常激活，中文路径问题可参考CSDN通过配置环境变量解决，仅最后一步不对。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(pytorch) PS C:\Users\王越洋&gt; python</span><br><span class="line">Python 3.6.13 |Anaconda, Inc.| (default, Mar 16 2021, 11:37:27) [MSC v.1916 64 bit (AMD64)] on win32</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; import torch</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>但配置时报错如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">D:\ruanjian\Pycharm\PyCharm 2023.3.2\plugins\python\helpers\pydev\_pydev_bundle\pydev_import_hook.py:21: UserWarning: mkl-service package failed to import, therefore Intel(R) MKL initialization ensuring its correct out-of-the box operation under condition when Gnu OpenMP had already been loaded by Python process is not assured. Please install mkl-service package, see http://github.com/IntelPython/mkl-service</span><br><span class="line">  module = self._system_import(name, *args, **kwargs)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\王越洋\.conda\envs\pytorch\lib\site-packages\numpy\core\__init__.py&quot;, line 22, in &lt;module&gt;</span><br><span class="line">    from . import multiarray</span><br><span class="line">  File &quot;D:\ruanjian\Pycharm\PyCharm 2023.3.2\plugins\python\helpers\pydev\_pydev_bundle\pydev_import_hook.py&quot;, line 21, in do_import</span><br><span class="line">    module = self._system_import(name, *args, **kwargs)</span><br><span class="line">  File &quot;C:\Users\王越洋\.conda\envs\pytorch\lib\site-packages\numpy\core\multiarray.py&quot;, line 12, in &lt;module&gt;</span><br><span class="line">    from . import overrides</span><br><span class="line">  File &quot;D:\ruanjian\Pycharm\PyCharm 2023.3.2\plugins\python\helpers\pydev\_pydev_bundle\pydev_import_hook.py&quot;, line 21, in do_import</span><br><span class="line">    module = self._system_import(name, *args, **kwargs)</span><br><span class="line">  File &quot;C:\Users\王越洋\.conda\envs\pytorch\lib\site-packages\numpy\core\overrides.py&quot;, line 7, in &lt;module&gt;</span><br><span class="line">    from numpy.core._multiarray_umath import (</span><br><span class="line">  File &quot;D:\ruanjian\Pycharm\PyCharm 2023.3.2\plugins\python\helpers\pydev\_pydev_bundle\pydev_import_hook.py&quot;, line 21, in do_import</span><br><span class="line">    module = self._system_import(name, *args, **kwargs)</span><br><span class="line">ImportError: DLL load failed: 找不到指定的模块。</span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\王越洋\.conda\envs\pytorch\lib\code.py&quot;, line 91, in runcode</span><br><span class="line">    exec(code, self.locals)</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;D:\ruanjian\Pycharm\PyCharm 2023.3.2\plugins\python\helpers\pydev\_pydev_bundle\pydev_import_hook.py&quot;, line 21, in do_import</span><br><span class="line">    module = self._system_import(name, *args, **kwargs)</span><br><span class="line">  File &quot;C:\Users\王越洋\.conda\envs\pytorch\lib\site-packages\torch\__init__.py&quot;, line 613, in &lt;module&gt;</span><br><span class="line">    _C._initExtension(manager_path())</span><br><span class="line">  File &quot;D:\ruanjian\Pycharm\PyCharm 2023.3.2\plugins\python\helpers\pydev\_pydev_bundle\pydev_import_hook.py&quot;, line 21, in do_import</span><br><span class="line">    module = self._system_import(name, *args, **kwargs)</span><br><span class="line">  File &quot;C:\Users\王越洋\.conda\envs\pytorch\lib\site-packages\torch\cuda\__init__.py&quot;, line 685, in &lt;module&gt;</span><br><span class="line">    from . import amp</span><br><span class="line">  File &quot;D:\ruanjian\Pycharm\PyCharm 2023.3.2\plugins\python\helpers\pydev\_pydev_bundle\pydev_import_hook.py&quot;, line 21, in do_import</span><br><span class="line">    module = self._system_import(name, *args, **kwargs)</span><br><span class="line">  File &quot;C:\Users\王越洋\.conda\envs\pytorch\lib\site-packages\torch\cuda\amp\__init__.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    from .autocast_mode import autocast, custom_fwd, custom_bwd  # noqa: F401</span><br><span class="line">  File &quot;D:\ruanjian\Pycharm\PyCharm 2023.3.2\plugins\python\helpers\pydev\_pydev_bundle\pydev_import_hook.py&quot;, line 21, in do_import</span><br><span class="line">    module = self._system_import(name, *args, **kwargs)</span><br><span class="line">  File &quot;C:\Users\王越洋\.conda\envs\pytorch\lib\site-packages\torch\cuda\amp\autocast_mode.py&quot;, line 5, in &lt;module&gt;</span><br><span class="line">    import numpy as np</span><br><span class="line">  File &quot;D:\ruanjian\Pycharm\PyCharm 2023.3.2\plugins\python\helpers\pydev\_pydev_bundle\pydev_import_hook.py&quot;, line 21, in do_import</span><br><span class="line">    module = self._system_import(name, *args, **kwargs)</span><br><span class="line">  File &quot;C:\Users\王越洋\.conda\envs\pytorch\lib\site-packages\numpy\__init__.py&quot;, line 140, in &lt;module&gt;</span><br><span class="line">    from . import core</span><br><span class="line">  File &quot;D:\ruanjian\Pycharm\PyCharm 2023.3.2\plugins\python\helpers\pydev\_pydev_bundle\pydev_import_hook.py&quot;, line 21, in do_import</span><br><span class="line">    module = self._system_import(name, *args, **kwargs)</span><br><span class="line">  File &quot;C:\Users\王越洋\.conda\envs\pytorch\lib\site-packages\numpy\core\__init__.py&quot;, line 48, in &lt;module&gt;</span><br><span class="line">    raise ImportError(msg)</span><br><span class="line">ImportError: </span><br><span class="line">IMPORTANT: PLEASE READ THIS FOR ADVICE ON HOW TO SOLVE THIS ISSUE!</span><br><span class="line">Importing the numpy C-extensions failed. This error can happen for</span><br><span class="line">many reasons, often due to issues with your setup or how NumPy was</span><br><span class="line">installed.</span><br><span class="line">We have compiled some common reasons and troubleshooting tips at:</span><br><span class="line">    https://numpy.org/devdocs/user/troubleshooting-importerror.html</span><br><span class="line">Please note and check the following:</span><br><span class="line">  * The Python version is: Python3.6 from &quot;C:\Users\王越洋\.conda\envs\pytorch\python.exe&quot;</span><br><span class="line">  * The NumPy version is: &quot;1.19.2&quot;</span><br><span class="line">and make sure that they are the versions you expect.</span><br><span class="line">Please carefully study the documentation linked above for further help.</span><br><span class="line">Original error was: DLL load failed: 找不到指定的模块。</span><br></pre></td></tr></table></figure><p><s>初步怀疑问题在于</s>（是小白没错了，后面人家说和这个没关系，看到这个报错的uu不要惊慌）</p><p>但当时我不知道啊，遂运行提示命令，无果，约半小时后提示某文件没有admission，CSDN有文指出该问题可以重新更新conda，下载一小时没下完。两个都运行了两次左右，各种重装Anaconda，结果人家输出我没有admission，如果你和我一样装Anaconda时选的<code>给所有人装</code>的选项，记得在权限里设置<code>所有人可修改</code>即可解决。当然，不设置也可以。</p><p>最后，这个错无伤大雅，重点不在这，不要运行<code>conda update -n base -c defaults conda</code> 就是了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(pytorch) PS C:\Users\王越洋&gt; conda install pytorch torchvision torchaudio cpuonly -c pytorch</span><br><span class="line">Collecting package metadata (current_repodata.json): done</span><br><span class="line">Solving environment: done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">==&gt; WARNING: A newer version of conda exists. &lt;==</span><br><span class="line">  current version: 23.7.4</span><br><span class="line">  latest version: 24.1.0</span><br><span class="line"></span><br><span class="line">Please update conda by running</span><br><span class="line"></span><br><span class="line">    $ conda update -n base -c defaults conda</span><br><span class="line"></span><br><span class="line">Or to minimize the number of packages updated during conda update use</span><br><span class="line"></span><br><span class="line">     conda install conda=24.1.0</span><br><span class="line"></span><br><span class="line"># All requested packages already installed.</span><br></pre></td></tr></table></figure><p>这个报错的意思是你有库安了，但是没安全。</p><h1>深夜寻求某宝</h1><p>凌晨00:23，解决无果，遂面向某宝解决（cost20￥），次日早，某阿里员工给我一波各种操作，两小时后告诉我问题是numpy库没安全，然后各种调试，找版本，然后安，解决！</p><p>下午，感觉自己又行了，于是自己重新建了一个虚拟环境，把人家建的删了，报错依旧，重装numpy无果，<s>发疯发疯</s>，感觉这个人解决问题不能一劳永逸（其实是我没学会。。。人家还是很厉害滴）~</p><h1>晚上寻求拼夕夕🌟</h1><p>已是晚10：20,继第10次左右重新安装调试后，随便捞了个能安的人（cost15￥），看得出来他也很焦灼，甚至还出现了新错误:</p><p>(1)Environment创建失败（这个和库没关系，是说你的源或者网络问题，建议换源即可）</p><p>(2)系统找不到指定路径。这个就比较棘手了，人家配了环境变量，各种调试，无果。通过装<code>Anaconda3-2020.11 Windows-x86 64.exe</code>，再来一遍pip配置，成功！！！</p><p>通过pip安装就不会像通过conda安装报错，成功解决！！！</p><p>小问题：conda安装的虚拟环境位置在<code>C:/User/XXX/.conda/env/</code>下的,但这种方式安装的虚拟环境位置在Anaconda3的安装目录下，其他运行均正常，虽然还是会报版本不一致的错，但无碍。本次配置终于完成！！</p><h1>结果</h1><p>综上，出现此类错误的人建议装低版本一点的Anaconda(卸的时候记得用自带的工具卸，写完检查环境变量删干净没)，安装时记得把PATH选项勾上（要不然要自己配，容易配错），最新版的Anaconda应该是有小毛病（库不全），谨慎安装！！！</p><p>祝看到这里的各位PyTorch学习顺利！🌟</p>]]></content>
      
      
      <categories>
          
          <category> NER </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
